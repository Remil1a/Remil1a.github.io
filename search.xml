<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Learn_the_Rudiments_of_Docker</title>
    <url>/2020/05/20/Learn-the-Rudiments-of-Docker/</url>
    <content><![CDATA[<h1 id="什么是Docker"><a href="#什么是Docker" class="headerlink" title="什么是Docker"></a>什么是Docker</h1><p>我以初学者的角度来说，网络上各种解释已经非常到位了。然而作为初学者，看到那些个架构图还是非常云里雾里的。因为学习都是从最基础的开始，个人偏好以实战为主。所以简单来张图吧。现存的Docker教程起手都是对架构一通解释，其实没有太大必要，个人认为初学者需要先做出效果然后再学习对应架构中的位置会更加清晰，当然，这需要有点计算机基础。</p>
<a id="more"></a>
<p>就三张图吧 图片来源网络，也是感觉挺不错就拿过来了，前提是了解过kvm以及其他的虚拟化比如vmware、hyper-v之类的</p>
<p><img src="/2020/05/20/Learn-the-Rudiments-of-Docker/1.jpg" alt="1"></p>
<p><img src="/2020/05/20/Learn-the-Rudiments-of-Docker/2.jpg" alt="2"></p>
<p><img src="/2020/05/20/Learn-the-Rudiments-of-Docker/3.jpg" alt="3"></p>
<p>Docker实际上就是一个应用程序+一堆运行库+一个rootfs组成的环境，由于没有hypervisor层，所以各方面性能都会比VM要强，但是隔离性也差，目前作为初学者知道这些就可以了，更适用于部署应用的场景，如果衍生到云计算可以说是PaaS的角色。</p>
<h1 id="如何安装Docker"><a href="#如何安装Docker" class="headerlink" title="如何安装Docker"></a>如何安装Docker</h1><p>Docker的安装非常简单，在<a href="https://docs.docker.com/get-docker/" target="_blank" rel="noopener">这个链接</a>里可以找到官网的安装方法。Docker提供了rpm，deb和二进制包的安装方法，在桌面系统如MacOS和Windows还有桌面版应用（Windows中的不太好用）。这边采用官网的方法+阿里云的源去安装（主要是国外源太慢了）。</p>
<h2 id="Docker的版本"><a href="#Docker的版本" class="headerlink" title="Docker的版本"></a>Docker的版本</h2><p>Docker一共有三个版本，这边先引用一段官方的解释。</p>
<blockquote>
<p>Docker Engine has three types of update channels, <strong>stable</strong>, <strong>test</strong>, and <strong>nightly</strong>:</p>
<ul>
<li>The <strong>Stable</strong> channel gives you latest releases for general availability.</li>
<li>The <strong>Test</strong> channel gives pre-releases that are ready for testing before general availability (GA).</li>
<li>The <strong>Nightly</strong> channel gives you latest builds of work in progress for the next major release.</li>
</ul>
</blockquote>
<p>简单来说 Docker目前有三个版本，Stable（稳定），Test（测试）和Nightly(实时更新版本)</p>
<p>前两个比较好理解 有点像游戏的正式服和测试服，而nightly主要是开发者维护的一个版本，一般是白天将各自的代码提交到一个中心，晚上做编译得到的版本，这种版本功能新，bug也多，适合一些关注Docker的开发者和有一定动手解决bug能力的人。作为初学者使用Stable版就够了。</p>
<h2 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h2><p>官网的流程有一个卸载旧版本docker的命令，如果需要的话可以执行，这篇教程使用的是新部署的CentOS7，所以没有这一步。不过还是把命令贴上来</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure>
<p>接下来就是安装了。由于不管是光盘中的源还是CentOS的自带源都没有安装Docker的部分，所以我们还需要指定一个源让系统去下载Docker的安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure>
<p>然后就可以进行docker安装了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y docker-ce-cli docker-ce containerd.io</span><br></pre></td></tr></table></figure>
<h2 id="启动docker"><a href="#启动docker" class="headerlink" title="启动docker"></a>启动docker</h2><p>跟其他服务一样 使用systemctl就可以启动docker了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<p>之后可以使用 <code>docker version</code>命令验证docker是否安装成功</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">version</span></span><br><span class="line"><span class="attr">Client:</span> <span class="string">Docker</span> <span class="string">Engine</span> <span class="bullet">-</span> <span class="string">Community</span></span><br><span class="line"><span class="attr"> Version:</span>           <span class="number">19.03</span><span class="number">.12</span></span><br><span class="line"> <span class="string">API</span> <span class="attr">version:</span>       <span class="number">1.40</span></span><br><span class="line"> <span class="string">Go</span> <span class="attr">version:</span>        <span class="string">go1.13.10</span></span><br><span class="line"> <span class="string">Git</span> <span class="attr">commit:</span>        <span class="number">48</span><span class="string">a66213fe</span></span><br><span class="line"><span class="attr"> Built:</span>             <span class="string">Mon</span> <span class="string">Jun</span> <span class="number">22</span> <span class="number">15</span><span class="string">:46:54</span> <span class="number">2020</span></span><br><span class="line"> <span class="string">OS/Arch:</span>           <span class="string">linux/amd64</span></span><br><span class="line"><span class="attr"> Experimental:</span>      <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Server:</span> <span class="string">Docker</span> <span class="string">Engine</span> <span class="bullet">-</span> <span class="string">Community</span></span><br><span class="line"><span class="attr"> Engine:</span></span><br><span class="line"><span class="attr">  Version:</span>          <span class="number">19.03</span><span class="number">.12</span></span><br><span class="line">  <span class="string">API</span> <span class="attr">version:</span>      <span class="number">1.40</span> <span class="string">(minimum</span> <span class="string">version</span> <span class="number">1.12</span><span class="string">)</span></span><br><span class="line">  <span class="string">Go</span> <span class="attr">version:</span>       <span class="string">go1.13.10</span></span><br><span class="line">  <span class="string">Git</span> <span class="attr">commit:</span>       <span class="number">48</span><span class="string">a66213fe</span></span><br><span class="line"><span class="attr">  Built:</span>            <span class="string">Mon</span> <span class="string">Jun</span> <span class="number">22</span> <span class="number">15</span><span class="string">:45:28</span> <span class="number">2020</span></span><br><span class="line">  <span class="string">OS/Arch:</span>          <span class="string">linux/amd64</span></span><br><span class="line"><span class="attr">  Experimental:</span>     <span class="literal">false</span></span><br><span class="line"><span class="attr"> containerd:</span></span><br><span class="line"><span class="attr">  Version:</span>          <span class="number">1.2</span><span class="number">.13</span></span><br><span class="line"><span class="attr">  GitCommit:</span>        <span class="number">7</span><span class="string">ad184331fa3e55e52b890ea95e65ba581ae3429</span></span><br><span class="line"><span class="attr"> runc:</span></span><br><span class="line"><span class="attr">  Version:</span>          <span class="number">1.0</span><span class="number">.0</span><span class="bullet">-rc10</span></span><br><span class="line"><span class="attr">  GitCommit:</span>        <span class="string">dc9208a3303feef5b3839f4323d9beb36df0a9dd</span></span><br><span class="line"><span class="attr"> docker-init:</span></span><br><span class="line"><span class="attr">  Version:</span>          <span class="number">0.18</span><span class="number">.0</span></span><br><span class="line"><span class="attr">  GitCommit:</span>        <span class="string">fec3683</span></span><br></pre></td></tr></table></figure>
<p>如果出现以上一些版本信息说明安装到位了。</p>
<h2 id="更改Docker-Registry源位置"><a href="#更改Docker-Registry源位置" class="headerlink" title="更改Docker Registry源位置"></a>更改Docker Registry源位置</h2><p>首先了解一下何为Docker Registry。就如同目前我们使用的CentOS一样，Docker需要一个远程的Image仓库。我们启动各种各样的基于Docker的服务是先从Registry将Image下载下来，再将Image放到相应的Container里。当然Image，Registry都可以自己制作，不依赖外网也是完全可以运行的。不过这边先用国内的仓库感受一下Docker的基本操作和用法。然后再学习如何搭建自己的Registry</p>
<p>首先注册一下阿里云，用支付宝或者淘宝账户就能登录了。</p>
<p>然后找到控制台，找容器镜像服务，开通一下就行。届时会给一个属于自己的加速链接，后面会用上。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;</span><br><span class="line">  "registry-mirrors": ["你的链接地址"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<h1 id="跑一下Hello-World"><a href="#跑一下Hello-World" class="headerlink" title="跑一下Hello World"></a>跑一下Hello World</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run hello-world</span><br><span class="line">Unable to find image 'hello-world:latest' locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">0e03bdcc26d7: Pull complete </span><br><span class="line">Digest: sha256:d58e752213a51785838f9eed2b7a498ffa1cb3aa7f946dda11af39286c3db9a9</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta"> $</span><span class="bash"> docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>
<p>这里能看到</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-Network-Manage</title>
    <url>/2019/11/15/Linux-Network-Manage/</url>
    <content><![CDATA[<h1 id="基础网络概念"><a href="#基础网络概念" class="headerlink" title="基础网络概念"></a>基础网络概念</h1><p>我们自己搭建的环境一般是在虚拟机里搭建，现在也有很多环境都是使用虚拟机的。所以本文主要以虚拟机（VMware Workstation）的环境为主，会包含一些虚拟网络的知识。如果是真实服务器使用物理网卡相对会比较简单。不过命令都是相同的。接下来介绍一下基础网络概念。因为管理Linux一般是用Xshell，SecureCRT等终端软件连接进行操作，所以网络如果不通的话基本什么也做不了。还是很关键的。</p>
<a id="more"></a>
<h2 id="虚拟网卡"><a href="#虚拟网卡" class="headerlink" title="虚拟网卡"></a>虚拟网卡</h2><p>在使用VMware Workstation安装虚拟机时会让我们选择虚拟网卡。虚拟网卡有三种模式。<strong>NAT</strong>，<strong>仅主机</strong>和<strong>桥接</strong>。这三种模式各有不同的使用场景和工作方式，下面简单介绍一下</p>
<ul>
<li><p>NAT</p>
<p>这个顾名思义，会借用主机的IP地址和外部通信，与物理机共享IP地址。但是由于做了NAT，外部主机无法访问虚拟机。虚拟机可以访问外部设备。</p>
</li>
<li><p>仅主机</p>
<p>做实验的话，这个模式用的最多，也是需要重点讲的。仅主机模式相当于在你的电脑上创建了一个虚拟交换机，这个虚拟交换机一般叫VMnet x x为数字。可以在虚拟网络编辑器里自行创建，VMWare Workstation自带了一张仅主机的虚拟网卡。默认情况下，仅主机模式的网卡只能和物理机以及同虚拟交换机的虚拟机通信。且他们的IP地址要在同一网段才能通信，后面会用实际例子来说明。</p>
</li>
<li><p>桥接</p>
<p>这个往往是外部主机和虚拟机需要互通的时候会用到的模式，在这种模式下，如果桥接模式桥接物理网卡，则虚拟机可以和外部主机通信。在生产环境会用的比较多。</p>
</li>
</ul>
<h2 id="Linux网卡命名"><a href="#Linux网卡命名" class="headerlink" title="Linux网卡命名"></a>Linux网卡命名</h2><p>一般来说，在VMWare Workstation中，你的虚拟机加了几块网卡，在命令行中使用ip a命令就可以看到几块网卡。</p>
<p><img src="/2019/11/15/Linux-Network-Manage/1.png" alt="1"></p>
<p>上面是我刚装好的Linux，有一个仅主机模式的网卡，有一个lo0。lo0是本地环回网卡，跟平时做路由器实验的lo0一样，逻辑上的接口。自己访问自己的时候就是用的这块网卡。不用管他。</p>
<p>可以看到第二块网卡叫eno16777736。虽然不是很重要但是还是说明一下这种奇怪的命名方式。先摘抄一段话</p>
<blockquote>
<p>Network interface names<br>Traditionally, network interfaces in Linux are enumerated as eth0, eth1, eth2, and so on. However, the mechanism which sets these names can cause changes to which interface gets which name as devices are added and removed.<br>The default naming behavior in Red Hat Enterprise Linux 7 is to assign fixed names based on firmware, device topology, and device type. </p>
<p>Interface names have the following characters:<br>​    Ethernet interfaces begin with en, WLAN interfaces begin with wl, and WWAN<br>​    interfaces begin with ww.<br>​    The next character(s) represents the type of adapter with an o for on-board, s for<br>​    hotplug slot, and p for PCI geographic location.<br>​    Not used by default but also available to administrators, an x is used to incorporate a<br>​    MAC address.<br>​    Finally, a number N is used to represent an index, ID, or port.<br>​    If the fixed name cannot be determined, the traditional names such as ethN will be<br>​    used. </p>
<p>For example, the first embedded network interface may be named eno1 and a PCI card network interface may be named enp2s0.<br>The new names make it easier to distinguish the relationship between a port and its name if the user knows both, but the trade off is that users cannot assume a system with one interface calls that interface eth0. </p>
</blockquote>
<p>简单来说就是</p>
<p>LAN用 en<br>WLAN用 wl<br>集成网卡：o<br>独立网卡：s<br>独立的不是热插拔的pci:p</p>
<p>wwan用的是mini PCI-E口，现在新的笔记本电脑上，这个口也可以接mSATA口的固态硬盘，但要主板支持，如thinkpad x220。不是所有的wwan口都支持mSATA。</p>
<p>在CentOS7中，有别于传统的eth0，eth1这样命名。7中采用了更科学的命名方式（也更长了）。掌握规律的话，还是很好理解的。</p>
<h3 id="为什么需要这么复杂的命名方式？"><a href="#为什么需要这么复杂的命名方式？" class="headerlink" title="为什么需要这么复杂的命名方式？"></a>为什么需要这么复杂的命名方式？</h3><p>服务器通常有多块网卡，有板载集成的，同时也有插在PCIe插槽的。<br>Linux系统的命名原来是eth0,eth1这样的形式，但是这个编号往往不一定准确对应网卡接口的物理顺序。<br>为解决这类问题，dell开发了biosdevname方案。<br>systemd v197版本中将dell的方案作了进一步的一般化拓展。<br>目前的Centos既支持dell的biosdevname，也支持systemd的方案。</p>
<p><img src="/2019/11/15/Linux-Network-Manage/2.png" alt="1"></p>
<p>可以看一下这张图，有板载网卡和PCI网卡的情况下，很难说清楚哪个是eth0</p>
<p>在CentOS7中，命名顺序如下：</p>
<ol>
<li>如果从BIOS中能够取到可用的，板载网卡的索引号，则使用这个索引号命名，例如:eno1，如不能则尝试2</li>
<li>如果从BIOS中能够取到可以用的，网卡所在的PCI-E热插拔插槽的索引号，则使用这个索引号命名，例如:ens1，如不能则尝试3</li>
<li>如果能拿到设备所连接的物理位置信息，则使用这个信息命名，例如:enp2s0，如不能则尝试4</li>
<li>传统的kernel命名方法，例如:eth0，这种命名方法的结果不可预知的，即可能第二块网卡对应eth0，第一块网卡对应eth1。</li>
<li>使用网卡的MAC地址来命名，这个方法一般不使用。</li>
</ol>
<p>biosdevname和net.ifnames两种命名规范<br>net.ifnames的命名规范为:   设备类型+设备位置+数字<br>设备类型：<br>​    en 表示Ethernet<br>​    wl 表示WLAN<br>​    ww 表示无线广域网WWAN</p>
<p>设备位置如下：</p>
<p><img src="/2019/11/15/Linux-Network-Manage/3.png" alt="1"></p>
<p>实际的例子:<br>​    eno1 板载网卡<br>​    enp0s2 pci网卡<br>​    ens33  pci网卡<br>​    wlp3s0 PCI无线网卡<br>​    wwp0s29f7u2i2   4Gmodem<br>​    wlp0s2f1u4u1  连接在USB Hub上的无线网卡<br>​    enx78e7d1ea46da pci网卡</p>
<p>而biosdevname的命名规范为</p>
<p><img src="/2019/11/15/Linux-Network-Manage/4.png" alt="1"></p>
<p>实际的例子:<br>​    em1 板载网卡<br>​    p3p4 pci网卡<br>​    p3p4_1 虚拟网卡</p>
<p>那么我们的网卡到底是经过怎样的顺序才会是这么个名字呢。</p>
<p>来看看systemd中的实际执行顺序：<br>按照如下顺序执行udev的rule<br>1./usr/lib/udev/rules.d/60-net.rules<br>2./usr/lib/udev/rules.d/71-biosdevname.rules<br>3./lib/udev/rules.d/75-net-description.rules<br>4./usr/lib/udev/rules.d/80-net-name-slot.rules<br>60-net.rules<br>​    使用/lib/udev/rename_device这个程序，去查询/etc/sysconfig/network-scripts/下所有以ifcfg-开头的文件<br>​    如果在ifcfg-xx中匹配到HWADDR=xx:xx:xx:xx:xx:xx参数的网卡接口<br>​    则选取DEVICE=yyyy中设置的名字作为网卡名称。<br>71-biosdevname.rules<br>​    如果系统中安装了biosdevname，且内核参数未指定biosdevname=0，且上一步没有重命名网卡，则按照biosdevname的命名规范，从BIOS中取相关信息来命名网卡。<br>​    主要是取SMBIOS中的type 9 (System Slot) 和 type 41 (Onboard DevicesExtended Information)<br>​    不过要求SMBIOS的版本要高于2.6，且系统中要安装biosdevname程序。<br>75-net-description.rules<br>​    udev通过检查网卡信息，填写如下这些udev的属性值<br>​    ID_NET_NAME_ONBOARD<br>​    ID_NET_NAME_SLOT<br>​    ID_NET_NAME_PATH<br>​    ID_NET_NAME_MAC<br>80-net-name-slot.rules<br>​    如果在60-net.rules，71-biosdevname.rules这两条规则中没有重命名网卡，且内核未指定net.ifnames=0参数则udev依次尝试使用以下属性值来命名网卡，如果这些属性值都没有，则网卡不会被重命名。<br>​    ID_NET_NAME_ONBOARD<br>​    ID_NET_NAME_SLOT<br>​    ID_NET_NAME_PATH<br>上边的71-biosdevname.rules 是实际执行biosdevname的policy75-net-description.rules和80-net-name-slot.rules实际执行Scheme 1,2,3<br>根据上述的过程，可见网卡命名受 biosdevname和net.ifnames这两个内核参数影响。这两个参数都可以在grub配置中提供。<br>biosdevname=0是系统默认值（dell服务器默认是1），net.ifnames=1是系统默认值:<br>​    vi /boot/grub/grub.conf<br>​    kernel /boot/ biosdevname=1<br>​    initrd /boot/initrd.img </p>
<p>在上面Centos7中命名的策略顺序是系统默认的。<br>如系统BIOS符合要求，且系统中安装了biosdevname，且biosdevname=1启用，则biosdevname优先；<br>如果BIOS不符合biosdevname要求或biosdevname=0，则仍然是systemd的规则优先。<br>如果用户自己定义了udevrule来修改内核设备名字，则用户规则优先。</p>
<p>内核参数组合使用的时候，其结果如下：<br>​    默认内核参数(biosdevname=0，net.ifnames=1):  网卡名”enp5s2”<br>​    biosdevname=1，net.ifnames=0：网卡名 “em1”<br>​    biosdevname=0，net.ifnames=0：网卡名 “eth0” (最传统的方式,eth0 eth1傻傻分不清)</p>
<h1 id="使用Network-Manager管理Linux网络"><a href="#使用Network-Manager管理Linux网络" class="headerlink" title="使用Network Manager管理Linux网络"></a>使用Network Manager管理Linux网络</h1><p>Network Manager是Centos7推荐的网络管理命令。相比于使用配置文件来管理网络，Network Manager（以后简称NM）更灵活方便。</p>
<p>在Centos7中，即使是最小化安装，也能够使用NM命令来管理网络，所以我们不需要安装任何组件就可以使用下面提到的所有命令。</p>
<p>但是首先要知道两个概念</p>
<ul>
<li><p>con</p>
<p>连接，逻辑设置。指的是一套具体配置方案</p>
</li>
<li><p>device</p>
<p>  设备，物理设备。例如ens33,virbr0,team0</p>
</li>
</ul>
<p>其中多个connection可以应用到同一个device，但同一时间只能启用其中一个connection。<br>这样的好处是针对一个网络接口，可以设置多个网络连接，比如静态IP和动态IP，再根据需要up相应的connection。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Device Management For AAA</title>
    <url>/2019/05/24/Device-Management-For-AAA/</url>
    <content><![CDATA[<h1 id="基本的设备管理"><a href="#基本的设备管理" class="headerlink" title="基本的设备管理"></a>基本的设备管理</h1><p>设备在上架以后，一般会配置远程访问方便管理员调试设备，先看两个最基本的管理方式。</p>
<a id="more"></a>
<h2 id="通过Telnet管理设备"><a href="#通过Telnet管理设备" class="headerlink" title="通过Telnet管理设备"></a>通过Telnet管理设备</h2><p><img src="/2019/05/24/Device-Management-For-AAA/1.png" alt="1"></p>
<p>拓扑如下，VMnet16中有一台ACS5.2设备（Cisco的老产品，现在已由ISE取代，这里为了实验演示采用ACS5.2）。在R1上配置telnet远程访问。在R2上测试。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##IP配置略</span></span><br><span class="line"></span><br><span class="line">R1(config)<span class="comment">#line vty 0 4 \\进入虚拟线路vty0～4配置</span></span><br><span class="line">R1(config-line)<span class="comment">#password cisco \\配置登录密码为Cisco</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##在R2上测试</span></span><br><span class="line">R2<span class="comment">#telnet 172.16.1.254</span></span><br><span class="line">Trying 172.16.1.254 ... Open</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">User Access Verification</span><br><span class="line"></span><br><span class="line">Password: </span><br><span class="line">R1&gt;<span class="built_in">enable</span></span><br><span class="line">% No password <span class="built_in">set</span> \\由于没有设置<span class="built_in">enable</span>密码，所以无法进入特权模式</span><br><span class="line">R1&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##在R1上配置enable密码</span></span><br><span class="line">R1(config)<span class="comment">#enable password cisco \\使用明文的方式存储密码 可以使用show run命令看到</span></span><br><span class="line">R1<span class="comment">#show run | in enable password</span></span><br><span class="line"><span class="built_in">enable</span> password cisco</span><br><span class="line"></span><br><span class="line"><span class="comment">##这里推荐使用密文的方式存储密码。</span></span><br><span class="line">R1(config)<span class="comment">#no enable password cisco \\将之前配置的enable密码去掉</span></span><br><span class="line">R1(config)<span class="comment">#enable secret cisco  \\使用密文的方式存储密码</span></span><br><span class="line">R1(config)<span class="comment">#do show run | in enable  </span></span><br><span class="line"><span class="built_in">enable</span> secret 5 <span class="variable">$1</span><span class="variable">$3</span>/N0<span class="variable">$wqldLLB3LOtZd0DDhfHpj</span>/ \\可以发现这边的密码已经看不到原文了</span><br><span class="line">R1(config)<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h2 id="通过SSH管理设备"><a href="#通过SSH管理设备" class="headerlink" title="通过SSH管理设备"></a>通过SSH管理设备</h2><p>以上是Telnet方式管理设备的基本配置，如果做了这个配置，只要telnet客户端和telnet服务器之间的网络能够连通，就可以直接在客户端上使用telnet命令远程管理设备。但是这种方式是明文的。所有的内容都可以被数据包分析软件截获。例如Wireshark。</p>
<p><img src="/2019/05/24/Device-Management-For-AAA/2.png" alt="1"></p>
<p>这样一来网络安全就无法保障了。如果要保障数据的安全性，可以使用SSH的方式登录。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##在R1上配置SSH</span></span><br><span class="line">R1(config)<span class="comment">#ip domain name cisco \\随便设置一个域名</span></span><br><span class="line">R1(config)<span class="comment">#crypto key gen rsa \\生成ssh需要用到的key</span></span><br><span class="line">The name <span class="keyword">for</span> the keys will be: R1.cisco</span><br><span class="line">Choose the size of the key modulus <span class="keyword">in</span> the range of 360 to 4096 <span class="keyword">for</span> your</span><br><span class="line">  General Purpose Keys. Choosing a key modulus greater than 512 may take</span><br><span class="line">  a few minutes.</span><br><span class="line"></span><br><span class="line">How many bits <span class="keyword">in</span> the modulus [512]: \\直接回车 这里是key的长度 默认512</span><br><span class="line">% Generating 512 bit RSA keys, keys will be non-exportable...</span><br><span class="line">[OK] (elapsed time was 1 seconds)</span><br><span class="line"></span><br><span class="line">R1(config)<span class="comment">#</span></span><br><span class="line">*May 24 01:28:36.150:  RSA key size needs to be atleast 768 bits <span class="keyword">for</span> ssh version 2 \\如果直接回车 会提示 ssh 版本2 需要至少768位的密钥长度 所以这里可以更改一下</span><br><span class="line">R1(config)<span class="comment">#crypto key gen rsa</span></span><br><span class="line">% You already have RSA keys defined named R1.cisco.</span><br><span class="line">% Do you really want to replace them? [yes/no]: yes</span><br><span class="line">Choose the size of the key modulus <span class="keyword">in</span> the range of 360 to 4096 <span class="keyword">for</span> your</span><br><span class="line">  General Purpose Keys. Choosing a key modulus greater than 512 may take</span><br><span class="line">  a few minutes.</span><br><span class="line"></span><br><span class="line">How many bits <span class="keyword">in</span> the modulus [512]: 768</span><br><span class="line">% Generating 768 bit RSA keys, keys will be non-exportable...</span><br><span class="line">[OK] (elapsed time was 0 seconds)</span><br><span class="line"></span><br><span class="line">R1(config)<span class="comment">#</span></span><br><span class="line">*May 24 01:31:50.641: %SSH-5-ENABLED: SSH 1.99 has been enabled</span><br><span class="line">R1(config)<span class="comment">#ip ssh version 2 \\将SSH的版本设为V2</span></span><br><span class="line">R1(config)<span class="comment">#line vty 0 4 \\进入远程连接的VTY接口</span></span><br><span class="line">R1(config-line)<span class="comment">#transp in ssh \\设置远程连接的协议只能是SSH</span></span><br><span class="line">R1(config)<span class="comment">#username cisco privilege 0 password cisco \\在服务器上创建一个用户，这里privilege如果不是0，进入时直接就是特权模式，不需要输入特权密码。为了安全起见 将privilege设为0.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##在R2上测试</span></span><br><span class="line">R2<span class="comment">#ssh -l cisco 172.16.1.254</span></span><br><span class="line">R1&gt;en</span><br><span class="line">Password: </span><br><span class="line">R1<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p><img src="/2019/05/24/Device-Management-For-AAA/3.png" alt="1"></p>
<p>可以看到再进行抓包就抓不到了。</p>
<h1 id="通过AAA管理设备"><a href="#通过AAA管理设备" class="headerlink" title="通过AAA管理设备"></a>通过AAA管理设备</h1><h2 id="AAA是什么"><a href="#AAA是什么" class="headerlink" title="AAA是什么"></a>AAA是什么</h2><ul>
<li>Authentication（认证）<ul>
<li>对用户的身份进行认证。例如通过用户名和密码，指纹等。</li>
</ul>
</li>
<li>Authorization（授权）<ul>
<li>授权用户能够使用的命令</li>
<li>授权用户访问的资源</li>
<li>授权用户获得的信息</li>
<li>主要是在用户都有效的情况下区分普通用户和特权用户</li>
</ul>
</li>
<li>Accounting（审计）<ul>
<li>记录用户做了什么事情。类似于生活中的摄像头。</li>
</ul>
</li>
</ul>
<h2 id="什么情况下使用AAA"><a href="#什么情况下使用AAA" class="headerlink" title="什么情况下使用AAA"></a>什么情况下使用AAA</h2><p>在网络特别简单，用户比较少的情况下可以用本地账号认证，不需要AAA。</p>
<ul>
<li><p>在有较多NAS（Network Access Server）时。</p>
</li>
<li><p>在登录管理的设备较多的时候。</p>
</li>
<li><p>VPN拨入的时候</p>
</li>
</ul>
<p>Client和NAS可能会用到例如ssh，telnet等协议</p>
<p>还有拨入服务例如 ipsec vpn，pppoe等。</p>
<p>那么在NAS服务器需要做身份验证的时候，就可以找AAA服务器做认证、授权和审计。AAA服务器和NAS服务器之间的通讯使用的是RADIUS或者TACACS+。</p>
<h2 id="AAA的配置"><a href="#AAA的配置" class="headerlink" title="AAA的配置"></a>AAA的配置</h2><p>Cisco路由器的AAA配置分为以下几步：</p>
<ul>
<li>在路由器上指定AAA服务器</li>
<li>在AAA服务器上指定AAA客户端（路由器或者其他网络设备）</li>
</ul>
<p><img src="/2019/05/24/Device-Management-For-AAA/1.png" alt="1"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##先在R1上配置线下保护策略</span></span><br><span class="line">R1(config)<span class="comment">#aaa new-model \\开启AAA</span></span><br><span class="line">R1(config)<span class="comment">#aaa authentication login noacs line none </span></span><br><span class="line"><span class="comment">##解释：</span></span><br><span class="line">login：登录认证策略</span><br><span class="line">noacs：策略名字叫noacs</span><br><span class="line">策略为先使用线下密码认证（line），如果没有线下密码就不认证</span><br><span class="line">该策略的作用是，在网络或者配置出现问题时，Console口始终是可以正常使用的</span><br><span class="line"></span><br><span class="line"><span class="comment">##然后再调用线下策略</span></span><br><span class="line">R1(config)<span class="comment">#line con 0</span></span><br><span class="line">R1(config-line)<span class="comment">#login authe noacs \\登录策略使用noacs</span></span><br><span class="line">R1(config-line)<span class="comment">#password cisco</span></span><br></pre></td></tr></table></figure>
<p>在配置完线下保护策略以后，就可以指定AAA服务器了。</p>
<p>AAA服务器有两种指定方法</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##AAA服务器指定方法一</span></span><br><span class="line">R1(config)<span class="comment">#tacacs server ACS</span></span><br><span class="line">R1(config-server-tacacs)<span class="comment">#address ipv4 192.168.2.233</span></span><br><span class="line">R1(config-server-tacacs)<span class="comment">#key cisco</span></span><br><span class="line">R1(config-server-tacacs)<span class="comment">#exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##AAA服务器指定方法二</span></span><br><span class="line">R1(config)<span class="comment">#aaa group server tacacs+ T.group</span></span><br><span class="line">R1(config-sg-tacacs+)<span class="comment">#server-private 192.168.2.233 key cisco</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##随便用哪个都行</span></span><br></pre></td></tr></table></figure>
<h2 id="ACS服务器基本配置"><a href="#ACS服务器基本配置" class="headerlink" title="ACS服务器基本配置"></a>ACS服务器基本配置</h2><p>接下来在ACS服务器上添加AAA客户端</p>
<p><img src="/2019/05/24/Device-Management-For-AAA/4.png" alt="1"></p>
<p><img src="/2019/05/24/Device-Management-For-AAA/5.png" alt="1"></p>
<ol>
<li>随便写个设备名</li>
<li>指定AAA客户端的IP地址</li>
<li>将tacacs+打勾</li>
<li>配置共享密码cisco</li>
<li>提交 submit</li>
</ol>
<p>然后在ACS服务器上添加用户组和用户</p>
<p><img src="/2019/05/24/Device-Management-For-AAA/6.png" alt="1"></p>
<p>随便添加一个组</p>
<p><img src="/2019/05/24/Device-Management-For-AAA/7.png" alt="1"></p>
<p><img src="/2019/05/24/Device-Management-For-AAA/8.png" alt="1"></p>
<p>再添加一个用户</p>
<p><img src="/2019/05/24/Device-Management-For-AAA/9.png" alt="1"></p>
<ol>
<li>随便写个用户名</li>
<li>选择用户组 点select</li>
<li>设置密码</li>
<li>设置enable密码</li>
</ol>
<p>设置完用户以后就可以在R1上看看效果了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">R1<span class="comment">#test aaa group T.group acsuser aptx4869 new-code \\测试一下AAA服务器</span></span><br><span class="line">Sending password</span><br><span class="line">User successfully authenticated \\测试成功</span><br><span class="line"></span><br><span class="line">USER ATTRIBUTES</span><br><span class="line"></span><br><span class="line">username             0   <span class="string">"acsuser"</span></span><br><span class="line">reply-message        0   <span class="string">"password: "</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##然后就可以开始配置AAA的策略了</span></span><br><span class="line">R1(config)<span class="comment">#aaa authentication login AAA group T.group \\创建一个登录认证用的AAA策略。叫AAA。送到T.group这个AAA认证组。</span></span><br><span class="line"></span><br><span class="line">R1(config)<span class="comment">#line vty 0 4 </span></span><br><span class="line">R1(config-line)<span class="comment">#login authe AAA \\登录使用AAA认证策略进行认证。</span></span><br><span class="line">R2<span class="comment">#ssh -l acsuser 172.16.1.254</span></span><br><span class="line">password: </span><br><span class="line">R1&gt;en</span><br><span class="line">Password: </span><br><span class="line">R1<span class="comment">#</span></span><br></pre></td></tr></table></figure>
<h2 id="AAA对命令进行授权"><a href="#AAA对命令进行授权" class="headerlink" title="AAA对命令进行授权"></a>AAA对命令进行授权</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##在上面的基础上我们已经做了AAA的认证，接下来做授权，指定用户可以使用的命令</span></span><br><span class="line">R1(config)<span class="comment">#aaa authorization config-commands \\开启命令授权</span></span><br><span class="line">R1(config)<span class="comment">#aaa authorization exec command group tacacs+ \\创建一个授权组</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables&amp;firewalld</title>
    <url>/2018/12/23/iptables-firewalld/</url>
    <content><![CDATA[<h1 id="Linux包过滤防火墙概述"><a href="#Linux包过滤防火墙概述" class="headerlink" title="Linux包过滤防火墙概述"></a>Linux包过滤防火墙概述</h1><ul>
<li>netfilter<ul>
<li>位于Linux内核中的包过滤功能体系</li>
<li>这个叫Linux防火墙的“内核态”</li>
</ul>
</li>
<li>iptables<ul>
<li>位于/sbin/iptables，用来管理防火墙规则的工具</li>
<li>这个叫“用户态”</li>
</ul>
</li>
</ul>
<p>Linux中的防火墙主要针对于网络层以及IP数据包，可以处理IP地址，端口等信息</p>
<p>当然在更新到7版本后，出现了firewalld。其实跟iptables是类似的。它们只是一种服务。iptables服务会把配置好的防火墙策略交由内核层面的netfilter网络过滤器来处理，而firewalld服务则是把配置好的防火墙策略交由内核层面的nftables包过滤框架来处理。这边先介绍iptables。</p>
<a id="more"></a>
<h1 id="iptables中的表、链结构"><a href="#iptables中的表、链结构" class="headerlink" title="iptables中的表、链结构"></a>iptables中的表、链结构</h1><p>iptables service是一种静态的防火墙管理工具，用户可以通过命令将规则写入/etc/sysconfig/iptables中，再执行reload。其实reload是对旧的规则进行了清空，再写入新的规则。这种哪怕写入一条规则也要reload生效的防火墙叫静态防火墙。</p>
<ul>
<li>规则链<ul>
<li>规则：可以对数据包进行过滤或处理</li>
<li>链：容纳各种规则</li>
<li>链的分类：根据处理包的不同时机有不同的链分类</li>
</ul>
</li>
<li>默认的5种规则链<ul>
<li>INPUT：入站数据包</li>
<li>OUTPUT：出站数据包</li>
<li>FORWARD：处理转发数据包</li>
<li>POSTROUTING：路由选择后的包</li>
<li>PREROUTING：路由选择前的包</li>
</ul>
</li>
</ul>
<p>当然用户还可以自定义链。这个放在后面再说。如果文字看的不太明白 可以看下图</p>
<p><img src="/2018/12/23/iptables-firewalld/2.png" alt="1"></p>
<ul>
<li><p>规则表</p>
<ul>
<li>表：表用来容纳各种规则链</li>
</ul>
</li>
<li><p>默认有4种规则表</p>
<h1 id="raw表：是否对该数据包进行状态追踪"><a href="#raw表：是否对该数据包进行状态追踪" class="headerlink" title="raw表：是否对该数据包进行状态追踪"></a>raw表：是否对该数据包进行状态追踪</h1><h1 id="mangle表：为数据包设置标记"><a href="#mangle表：为数据包设置标记" class="headerlink" title="mangle表：为数据包设置标记"></a>mangle表：为数据包设置标记</h1><h1 id="nat表：修改数据包中的源、目IP地址或端口"><a href="#nat表：修改数据包中的源、目IP地址或端口" class="headerlink" title="nat表：修改数据包中的源、目IP地址或端口"></a>nat表：修改数据包中的源、目IP地址或端口</h1><h1 id="filter表：确定是否放行该数据包"><a href="#filter表：确定是否放行该数据包" class="headerlink" title="filter表：确定是否放行该数据包"></a>filter表：确定是否放行该数据包</h1></li>
</ul>
<p>规则表之间以 <strong>raw mangle nat filter</strong>的顺序进行匹配</p>
<p>以下是默认表、链结构示意图：</p>
<p><img src="/2018/12/23/iptables-firewalld/1.png" alt="2"></p>
<p>规则链内会进行顺序匹配，有匹配到则停止，若没有匹配上，就会按默认规则处理。</p>
<h1 id="iptables基本语法"><a href="#iptables基本语法" class="headerlink" title="iptables基本语法"></a>iptables基本语法</h1><ul>
<li><p>语法构成</p>
<h1 id="iptables-t-表名-选项-链名-条件-j-控制类型"><a href="#iptables-t-表名-选项-链名-条件-j-控制类型" class="headerlink" title="iptables [-t 表名] 选项 [链名][条件] [-j 控制类型]"></a>iptables [-t 表名] 选项 [链名][条件] [-j 控制类型]</h1></li>
</ul>
<h2 id="使用REJECT拒绝ICMP"><a href="#使用REJECT拒绝ICMP" class="headerlink" title="使用REJECT拒绝ICMP"></a>使用REJECT拒绝ICMP</h2><p>下面简单做个实验来体验一下iptables。先看一下拓扑图。</p>
<p><img src="/2018/12/23/iptables-firewalld/3.png" alt="3"></p>
<p>图中的cloud-1就是centos7主机。有两块网卡，eth0和eth1，IP如图所示。R1和R2分别用两台cisco 3725模拟主机。R1和R2都配置了默认路由指向Linux主机。那么先来做一下测试吧。</p>
<blockquote>
<p>注意，如果要让Linux主机能够有数据包的转发功能，要修改一个配置文件，在/etc/sysctl.conf中将net.ipv4.ip_forward的值修改为1.如下所示，顺便再清空一下iptables，完毕以后可以使用iptables -L查看</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# vi /etc/sysctl.conf </span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line">[root@remilia ~]# iptables -F \\删除所有链中的规则</span><br><span class="line">[root@remilia ~]# iptables -X \\删除所有用户自定义链</span><br><span class="line">[root@remilia ~]# iptables -Z \\把所有链的计数器清空（归归归归零）</span><br></pre></td></tr></table></figure>
<p>完毕以后我们来看一下R1和R2 以及R1与Linux主机，R2与Linux主机之间能否互通吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">R1(config)#</span><span class="bash"><span class="keyword">do</span> ping 192.168.80.10 \\R1 ping Linux主机</span></span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.80.10, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 8/12/24 ms</span><br><span class="line"><span class="meta">R1(config)#</span><span class="bash"><span class="keyword">do</span> ping 192.168.10.10 \\R1 ping R2</span></span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.10.10, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 16/22/28 ms</span><br></pre></td></tr></table></figure>
<p>现在图中应该是网络全通的。那么我们先写一个规则，让R1 ping不通Linux主机。</p>
<p>现在先来分析一下，R1如果要Ping Linux主机，使用的是ICMP，以及这算是入站，所以应该是input，然后如果不想让这个包通过，应该是属于filter表。那么命令就出来了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# iptables -t filter -I INPUT -p icmp -j REJECT</span><br><span class="line">[root@remilia ~]# iptables -L -t filter</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">REJECT     icmp --  anywhere             anywhere             reject-with icmp-port-unreachable</span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p>其中 -I 代表 insert 插入 这条规则默认会在规则链的最上面添加,也可以使用 -I 后面跟序列号指定序号。-A则是在末尾添加。</p>
<blockquote>
<p>注意，reject和drop的区别在于，reject会有明确的错误提示，而drop只是丢弃，对于icmp来说，就会显示超时。</p>
</blockquote>
<p>来看看这么写会有什么效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">R1(config)#</span><span class="bash"><span class="keyword">do</span> ping 192.168.80.10</span></span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.80.10, timeout is 2 seconds:</span><br><span class="line">UUUUU</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure>
<p>很明显，这里出现U代表不可达，而且出现的很快 明显看得出来是被拒绝了。</p>
<h2 id="使用DROP拒绝ICMP"><a href="#使用DROP拒绝ICMP" class="headerlink" title="使用DROP拒绝ICMP"></a>使用DROP拒绝ICMP</h2><p>那么如果使用drop呢,我们可以先用删除命令把刚才写的规则删掉写一个新的，或者使用-I添加在最前面。我这边就先把之前写的删除再添加吧。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# iptables -D INPUT 1</span><br><span class="line">[root@remilia ~]# iptables -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p>可以看到之前的规则已经被清空了。</p>
<p>接下来看看用DROP会有什么不同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# iptables -t filter -I INPUT -p icmp -j DROP</span><br><span class="line">[root@remilia ~]# iptables -L</span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DROP       icmp --  anywhere             anywhere            </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination</span><br></pre></td></tr></table></figure>
<p>规则写好了 接下来用R1来测试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">R1(config)#</span><span class="bash"><span class="keyword">do</span> ping 192.168.80.10</span></span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.80.10, timeout is 2 seconds:</span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure>
<p>可以看到这边由于linux主机那边的操作是<strong>DROP</strong>而非<strong>REJECT</strong>导致R1发出去的包根本没有任何提示。直接被丢弃了。而R1并不知道，还在等待对方回复，思科路由器默认超过两秒以后就属于超时，所以出现的是<strong>“…..”</strong>代表超时</p>
<p>当然 还可以使用<code>iptables -t filter -P</code>来设置默认策略 例如<code>iptables -t filter -P FORWARD DROP</code>代表将FORWARD的默认策略设置为丢弃。这边就不再演示了。在上面的命令中，每次iptables -L显示出来的内容中的（policy ）中的内容就代表默认策略。</p>
<h2 id="使用SNAT和DNAT做地址转换"><a href="#使用SNAT和DNAT做地址转换" class="headerlink" title="使用SNAT和DNAT做地址转换"></a>使用SNAT和DNAT做地址转换</h2><p>iptables中还有一个很重要的内容是地址转换。跟网络中的NAT有点类似。还是刚才的拓扑图，我将在Linux主机上做SNAT（源地址网络地址转换）把R1 Ping向R2的包 源地址变为200.1.1.1 。那么R2会认为是200.1.1.1给他发了ICMP echo request 他需要回复 ICMP echo reply，那么回包就变成了 SIP R2的IP DIP 200.1.1.1 这个时候查表转发，有一条默认路由 指向Linux主机 那么Linux主机便会收到这个包，这个时候再做一个DNAT（目标网络地址转换）。将 DIP 200.1.1.1 变为R1的IP 这样就能够实现ping通了。同时我会在 R2上开启 debug 。当然 要先在Linux主机上做两次NAT。</p>
<p>照惯例会先清空iptables，这边就不再演示了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# iptables -t nat -I POSTROUTING -s 192.168.80.0/24 -o eth1 -j SNAT --to-source 200.1.1.1</span><br><span class="line">[root@remilia ~]# iptables -L -t nat </span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">SNAT       all  --  192.168.80.0/24      anywhere             to:200.1.1.1</span><br></pre></td></tr></table></figure>
<p>这边解释一下命令-s代表源地址 相当于我们在路由交换中做NAT的时候的那个ACL,-o是 out interface 就是出接口的意思。那么源地址转换做好了。按照刚才的分析 我们还需要做目标地址转换。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# iptables -t nat -I PREROUTING -i eth1 -d 200.1.1.1 -p icmp -j DNAT --to-destination 192.168.80.80</span><br><span class="line">[root@remilia ~]# iptables -L -t nat</span><br><span class="line">Chain PREROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">DNAT       icmp --  anywhere             200.1.1.1            to:192.168.80.80</span><br><span class="line"></span><br><span class="line">Chain INPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line"></span><br><span class="line">Chain POSTROUTING (policy ACCEPT)</span><br><span class="line">target     prot opt source               destination         </span><br><span class="line">SNAT       all  --  192.168.80.0/24      anywhere             to:200.1.1.1</span><br></pre></td></tr></table></figure>
<p>这个就比较简单了 解释一下 -i 代表 接受包的接口 </p>
<blockquote>
<p> 参考自iptables的man手册:-i :Name of an interface via which a packet was received (only for packets entering the INPUT, FORWARD and  PREROUTING  chains).</p>
</blockquote>
<p>那么来看一下效果吧</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">R1(config)#</span><span class="bash"><span class="keyword">do</span> ping 192.168.10.10 \\在R1上ping R2 能通</span></span><br><span class="line"></span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.10.10, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 20/21/24 ms</span><br><span class="line"></span><br><span class="line"><span class="meta">R2#</span><span class="bash">debug ip icmp </span></span><br><span class="line">ICMP packet debugging is on</span><br><span class="line"><span class="meta">R2#</span><span class="bash"></span></span><br><span class="line">*Mar  1 04:04:15.698: ICMP: echo reply sent, src 192.168.10.10, dst 200.1.1.1</span><br><span class="line">*Mar  1 04:04:15.734: ICMP: echo reply sent, src 192.168.10.10, dst 200.1.1.1</span><br><span class="line">*Mar  1 04:04:15.754: ICMP: echo reply sent, src 192.168.10.10, dst 200.1.1.1</span><br><span class="line">*Mar  1 04:04:15.778: ICMP: echo reply sent, src 192.168.10.10, dst 200.1.1.1</span><br><span class="line">*Mar  1 04:04:15.798: ICMP: echo reply sent, src 192.168.10.10, dst 200.1.1.1</span><br><span class="line"><span class="meta">R2#</span><span class="bash"></span></span><br><span class="line"></span><br><span class="line">\\此时可以看出R2认为是200.1.1.1在ping他。</span><br></pre></td></tr></table></figure>
<h1 id="Firewalld"><a href="#Firewalld" class="headerlink" title="Firewalld"></a>Firewalld</h1><ul>
<li>在CentOS7.0以后的版本中，加入了新的Firewalld服务。以下是firewalld的简介。</li>
</ul>
<p>Firewalld提供了动态的防火墙管理，支持区域的定义，为网络和及其关联的接口或源分配信任级别。它支持IPv4，IPv6，以太桥。它的配置分为实时的和永久的，同时它也为应用程序和服务提供了接口，可以直接将规则添加进iptables和ip6tables等。</p>
<blockquote>
<p> firewalld provides a dynamically managed firewall with support for network/firewall “zones” to assign a level of trust to a network and its associated connections, interfaces or sources. It has support for IPv4, IPv6, Ethernet bridges and also for IPSet firewall settings. There is a separation of the runtime and permanent configuration options. It also provides an interface for services or applications to add iptables, ip6tables and ebtables rules directly. </p>
</blockquote>
<p><img src="/2018/12/23/iptables-firewalld/4.png" alt="3"></p>
<p>firewalld架构如图所示。首先能看到图中也出现了iptables。要注意的是，firewalld是动态防火墙。可以回顾上面提到的iptables service静态防火墙的概念。</p>
<blockquote>
<p>用户可以通过命令将规则写入<code>/etc/sysconfig/iptables</code>中，再执行reload。其实reload是对旧的规则进行了清空，再写入新的规则。这种哪怕写入一条规则也要reload生效的防火墙叫静态防火墙。</p>
</blockquote>
<p>而人们经常提到的firewalld取代了iptables只是取代了iptables的service部分，其backends（后端，或者说底层）还是依靠iptables。firewalld动态的好处在于，每次创建，改变，删除时，不需要重启进程就可以应用规则。我们可以把iptables的服务关掉，然后把firewalld打开（系统应该是默认打开的），之后使用<code>iptables -L</code> 查看，依然可以看到很多规则。</p>
<blockquote>
<p>Being dynamic, it enables creating, changing, and deleting the rules without the necessity to restart the firewall daemon each time the rules are changed.</p>
</blockquote>
<h2 id="区域（Zones）"><a href="#区域（Zones）" class="headerlink" title="区域（Zones）"></a>区域（Zones）</h2><p>Firewalld使用区域来将网络划分到不同的安全级别的区域（Zones）中。一个接口只能属于一个区域，但是一个区域能够有多个网络接口。系统预设了多个防火墙区域。预设的防火墙区域配置放在<code>/usr/lib/firewalld/zones/</code>中。生效的放在<code>/etc/firewalld/zones</code>中</p>
<p>firewalld基本语法是这样的：<code>firewall-cmd [OPTIONS...]</code> </p>
<p>例如我们可以通过firewall-cmd查看系统预设的区域：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@oolong-tea ~]# firewall-cmd --get-zones</span><br><span class="line">block dmz drop external home internal public trusted work</span><br></pre></td></tr></table></figure>
<p>能够看到系统本身就预设了很多区域。那么我们可以先来认识一下这些预设的区域。</p>
<h3 id="block-阻塞"><a href="#block-阻塞" class="headerlink" title="block(阻塞)"></a>block(阻塞)</h3><p>任何连入的ipv4连接都会贝icmp-host-prohibited消息拒绝，ipv6连接都会被icmp6-adm-prohibited拒绝。</p>
<blockquote>
<p>Any incoming network connections are rejected with an icmp-host-prohibited message for <code>IPv4</code> and icmp6-adm-prohibited for <code>IPv6</code>. Only network connections initiated from within the system are possible.</p>
</blockquote>
<h3 id="dmz"><a href="#dmz" class="headerlink" title="dmz"></a>dmz</h3><p>用户定义的区域，可以被公共接入，也可以有限制的访问内部网络。仅接受经过选择的连接</p>
<blockquote>
<p>For computers in your demilitarized zone that are publicly-accessible with limited access to your internal network. Only selected incoming connections are accepted.</p>
</blockquote>
<h3 id="drop（丢弃）"><a href="#drop（丢弃）" class="headerlink" title="drop（丢弃）"></a>drop（丢弃）</h3><p>任何接收的网络数据包都被丢弃，没有任何回复。仅能有发送出去的网络连接。</p>
<blockquote>
<p>Any incoming network packets are dropped without any notification. Only outgoing network connections are possible.</p>
</blockquote>
<h3 id="external（外部）"><a href="#external（外部）" class="headerlink" title="external（外部）"></a>external（外部）</h3><p>特别为路由器使用的伪装区域，不信任这个区域的设备，认为这个区域的设备会危害你的电脑，只放行经过选择的连接</p>
<blockquote>
<p>For use on external networks with masquerading enabled, especially for routers. You do not trust the other computers on the network to not harm your computer. Only selected incoming connections are accepted</p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Python_Basic</title>
    <url>/2018/08/09/Python-Basic/</url>
    <content><![CDATA[<h2 id="Python为何这么火"><a href="#Python为何这么火" class="headerlink" title="Python为何这么火"></a>Python为何这么火</h2><p>Python的定位非常明确，它是一种<strong>简单易用</strong>但又<strong>专业严谨</strong>的语言。或者说叫胶水语言。普通人也很容易入门。Python可以把各个基本程序拼接在一起协同运作。任何一个人只要愿意学习，可以在几天的时间内学会Python的基础部分。然后做很多很多事情，这种投入产出比是任何其他语言无法具备的。</p>
<a id="more"></a>
<p>打个比方 我们都知道C语言和C++ Java这种语言比较常用，那么如果我们以造一辆车做比喻，C是从头开始造。先造发动机，再造挡风玻璃，车门，雨刮，轮胎。甚至连一颗螺丝钉都是完全为这辆车打造的。最后造出来的是一辆独一无二的车。这个开发周期可能要一到两年。</p>
<p>而如果使用Python造一辆车，轮子不用自己造，有很多轮子别人已经帮你写好了。这些轮子可能是拿C语言写的。你只需要选一个适合你的。同理，底盘，挡风玻璃等都可以选别人造好的。这样造车，周期会非常短。可能只需要一个星期就能跑起来。当然，这辆车肯定相对来说没有C语言造出来的车要好。毕竟人家是定制的。我这个是拼接的。但是如果不合适我可以把轮子直接换一个。非常灵活。</p>
<p>如果有人说，Python开发的程序没有C开发的程序跑得快，执行效率低。我想说的是，很多Python的模块就是拿C写的。打个比方，Python做的事情就是指挥这些模块去做事。是个指挥者的角色。我们做的很多时候都是逻辑。而不是方法。例如，一个数据来了 交给某个Python模块，这个模块是拿C写的，然后返回给你结果，你再拿到这个结果给另一个模块处理。很少有纯Python的程序。执行效率当然没有纯C写出来的程序高。但是也差不了多少。</p>
<h2 id="Python内置类型"><a href="#Python内置类型" class="headerlink" title="Python内置类型"></a>Python内置类型</h2><p>Python的程序分为<strong>模块</strong> <strong>语句</strong> <strong>表达式</strong> 和<strong>对象</strong></p>
<ul>
<li>程序由模块组成</li>
<li>模块包含语句，条件，循环….等等</li>
<li>语句包含表达式</li>
<li><p>表达式创建和处理对象。</p>
<p>为什么使用内置对象呢，内置对象是程序自带的，本身就支持的东西。比方说数字，字符，列表等等。并且可以基于内建对象创建新对象。</p>
</li>
</ul>
<p>那么内置对象有哪些呢？下面列出了常用的内置对象。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>对象类型</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>Numbers（数字）</td>
<td>1234，3.1415926，0b111，3+4j</td>
</tr>
<tr>
<td>Strings（字符串）</td>
<td>‘remilia’，‘ipconfig’，’\r\n’</td>
</tr>
<tr>
<td>Lists（列表）</td>
<td>[1,2,[12,3]],[1,’1’,’Playstation’],list[range(10)]</td>
</tr>
<tr>
<td>Dictionaries（字典）</td>
<td>{‘food’:’Hamburg’,’PS4’:’Playstation4’,’1’:123}</td>
</tr>
<tr>
<td>Tuples（元组）</td>
<td>(1,’test’,4,6)</td>
</tr>
<tr>
<td>Files（文件）</td>
<td>open(‘dns.txt’),open(r’D:\Learn\ccna.ppt’)</td>
</tr>
<tr>
<td>Sets（集合）</td>
<td>set(‘abc’),{‘a’,’b’,’c’}</td>
</tr>
</tbody>
</table>
</div>
<p>大部分都是我们熟悉的。接下来看第一个 数字。这个是我们生活中也会用到的。Python中处理的每个东西都是对象。所以这些很关键。</p>
<p>Python的安装就不去说了。Windows版在官网上的都能找到。MacOS和Linux都能在官网上找到。安装过程网上都有教程。</p>
<h2 id="Python内置类型-数字"><a href="#Python内置类型-数字" class="headerlink" title="Python内置类型-数字"></a>Python内置类型-数字</h2><p>首先每个对象我都会用以下这张表来概述特点。这些特点需要牢记。数字类型的特点如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>分类</th>
<th>可变</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number（数字）</td>
<td>Numeric（数值）</td>
<td>不可变</td>
</tr>
</tbody>
</table>
</div>
<p>那么来解释一下吧</p>
<ul>
<li>类型：就是对象的类型 在内置类型里列出了常用的类型。现在说明的是数字。</li>
<li>分类：或者说特征，数字类型的特点就是里面只能放数值。常见的数值有整数，浮点数和虚数等。</li>
<li>可变：对象一旦定义就是不可变的。比方说定义了A=999 那么除非重新再赋值A=666 不然是没办法改变其中的值的。这个可以跟下面要讲的字符串做对比。先这么记着。</li>
</ul>
<p>接下来来看一下数字类型的对象能够接受的值吧。</p>
<ul>
<li>1234，-24，0，999999   这些都是<strong>整数</strong>。</li>
<li>1.23，1.5666，3.1415926   4E210 这些都是<strong>浮点数</strong>。</li>
<li>0o177，0x12a，ob1010101011   这些分别是<strong>八进制</strong>，<strong>十六进制</strong>和<strong>二进制数</strong>。</li>
<li>3+4j，3.0+4j 这些都是<strong>复数</strong></li>
<li>set(‘test’)，{1,2,3,4} 这些是集合</li>
<li>Decimal(‘1.0’)，Fraction(1,3) 小数和分数 右边那个是$\frac{1}{3}$</li>
<li>bool(X),True,False 布尔和常量 布尔值就像 真，假这种。</li>
</ul>
<p>那么下面列出一些数字对象的基本操作</p>
<ul>
<li>表达式操作符</li>
</ul>
<p>+(加)，-(减)，*(乘)，/(除)，**(乘方)，&gt;&gt; 移位</p>
<p>这里要说明一下移位。移位是指将数字往前或者往后移动一位。例如算IP地址的时候经常会记下面的一串数字</p>
<p>64 32 16 8 4 2 1</p>
<p>那么例如8往后移动2位应该是2</p>
<p>下面来实际操作一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>+<span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>**<span class="number">2</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">6</span>*<span class="number">5</span></span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span><span class="number">-2</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span><span class="number">-9</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span> &gt;&gt; <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">8</span> &lt;&lt; <span class="number">2</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure>
<h3 id="内建数学函数"><a href="#内建数学函数" class="headerlink" title="内建数学函数"></a>内建数学函数</h3><p>内建数学函数可以理解为Python自带的数学函数例如</p>
<p>pow()乘方，abs()求绝对值，round()四舍五入，int, hex,oct,bin等等</p>
<p>那么我们也通过实际操作感受一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">4</span>,<span class="number">2</span>) \\四的二次方</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(<span class="number">-100</span>) \\求<span class="number">100</span>的绝对值</span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">4.6</span>) \\四舍五入<span class="number">4.6</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">4.4</span>) \\四舍五入<span class="number">4.4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">4.5</span>) \\四舍五入<span class="number">4.5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="number">0b01101</span>) \\将<span class="number">0b01101</span>(二进制<span class="number">01101</span>)转换成int(十进制数)</span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hex(<span class="number">15</span>) \\将十进制的<span class="number">15</span>转换成<span class="number">16</span>进制数</span><br><span class="line"><span class="string">'0xf'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">0x0fab</span>) \\将十六进制数的<span class="number">0x0fab</span>转换成八进制数</span><br><span class="line"><span class="string">'0o7653'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="工具模块"><a href="#工具模块" class="headerlink" title="工具模块"></a>工具模块</h3><p>之前也有说过Python有很多别人写好的模块。这里直接导入别人写好的模块 随机数模块random。</p>
<p>然后我们来看看用随机数模块如何快速生成随机数。这个如果有学过C语言应该知道 让计算机生成随机数可以调用rand()函数，但是每次生成的序列是一样的。而且还要有种子值之类的。写起来还比较麻烦。下面看看Python怎么做的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> random</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"><span class="number">80</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"><span class="number">75</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"><span class="number">14</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>random.randint(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line"><span class="number">92</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>接下来我们来对比一下C语言生成随机数怎么写</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include &lt;stdio.h&gt; </span><br><span class="line">include &lt;stdlib.h&gt; </span><br><span class="line">include &lt;time.h&gt; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">float</span> s; </span><br><span class="line">    srand((<span class="keyword">int</span>)time(<span class="number">0</span>)); </span><br><span class="line">    s = (<span class="keyword">float</span>)rand() / RAND_MAX; </span><br><span class="line">    s = <span class="number">3</span> + (<span class="number">5</span><span class="number">-3</span>) * s; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, s); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相比之下C语言就复杂的多了。这是我们第一次接触模块，后面还会经常用到。</p>
<p>再来看一组实例吧，我刚开始学C语言的时候，老师会出一个题，要求给定几个数，让程序返回最大值。这个看似简单的任务真的当时做的头都是大的。写的很复杂。先来看用C怎么写的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxfun</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">int</span> i,j,N;</span><br><span class="line"> <span class="keyword">int</span> sum = <span class="number">0</span>,max = <span class="number">0</span>; </span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;N);</span><br><span class="line"> <span class="keyword">int</span> a[N];</span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++)&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">  <span class="keyword">if</span>(a[i]&gt;max)&#123;</span><br><span class="line">   max = a[i];</span><br><span class="line">   sum = i;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,N,sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看，这么复杂的程序，在python里，只需要简单的几行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max([<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">4</span>,])</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
<p>其中用[]框起来的是列表 后面我们会提到。总之python实现排序是如此简单，别人已经跟你写好了。你只需要告诉他需要干嘛就行了。非常好用。不需要了解实现方法。python有很多很多模块，都是已经写好了的。你只需要关心 把什么东西传进去，把得到的东西再给什么模块处理就行了，不需要关心他到底是怎么找的。这就是python在写起来很快的原因。当然，前提条件是你要知道有这么个东西。比方说数学模块其实有很多东西的。</p>
<p><img src="/2018/08/09/Python-Basic/1.png" alt="1"></p>
<p>前提是你要很懂数学 才能很好的去利用这些工具和模块</p>
<h2 id="Python内置类型-字符串"><a href="#Python内置类型-字符串" class="headerlink" title="Python内置类型-字符串"></a>Python内置类型-字符串</h2><p>字符串的特点如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>特点</th>
<th>是否可变</th>
</tr>
</thead>
<tbody>
<tr>
<td>String（字符）</td>
<td>序列</td>
<td>不可变</td>
</tr>
</tbody>
</table>
</div>
<p>字符串应该是用的比较多的。待会儿解释一下什么叫序列类型。以及不可变是什么概念。</p>
<p>字符串是可以单引号，双引号和三引号框起来。反过来说，用这些符号框起来的就代表里面的是字符串。先体验一下吧。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Playstation3'</span></span><br><span class="line"><span class="string">'Playstation3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"Playstation3"</span></span><br><span class="line"><span class="string">'Playstation3'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"""Playstation4"""</span></span><br><span class="line"><span class="string">'Playstation4'</span></span><br></pre></td></tr></table></figure>
<p>那么除了我们常用的英文字母，数字，中文等字符串，还有一些特殊的东西我们要了解</p>
<h3 id="转意符号"><a href="#转意符号" class="headerlink" title="转意符号\"></a>转意符号\</h3><p>我们都知道单引号有特殊的意义 用于把字符串引起来，但是如果我想要输出正常的单引号又该怎么办呢？这个时候就需要使用转意符号，告诉程序这里的单引号没有特殊意义。就是一个普通的字符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Python'</span>Cisco<span class="string">'</span></span><br><span class="line"><span class="string">  File "&lt;stdin&gt;", line 1</span></span><br><span class="line"><span class="string">    '</span>Python<span class="string">'Cisco'</span></span><br><span class="line">                ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure>
<p>如果这么去做 会直接报错。那么现在在Python和Cisco之间的单引号前面加一个转意符号\</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Python\'Cisco'</span></span><br><span class="line"><span class="string">"Python'Cisco"</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>除了上述这种情况，其实很多时候我们会碰到\t \r\n这种特殊符号。这个\t代表一个tab \r代表回车\n代表换行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Cisco\tHuawei'</span>)</span><br><span class="line">Cisco	Huawei</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>你会发现中间空了一块出来，这就是制表符（table）的效果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Cisco\nHuawei'</span>)</span><br><span class="line">Cisco</span><br><span class="line">Huawei</span><br></pre></td></tr></table></figure>
<p>\n就是回车。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'Cisco\rHuawei'</span>)</span><br><span class="line">Huawei</span><br></pre></td></tr></table></figure>
<p>\r为换行。</p>
<blockquote>
<p>换行和回车的区别：</p>
<p>在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。</p>
<p>于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。</p>
<p>这就是“换行”和“回车”的由来。</p>
<p>后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。</p>
<p>回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return</p>
<p>换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed</p>
<p>符号    ASCII码      意义</p>
<p>\n        10        换行NL</p>
<p>\r        13        回车CR</p>
<p>在不同的操作系统这几个字符表现不同，比如在WIN系统下，这两个字符就是表现的本义，在UNIX类系统，换行\n就表现为光标下一行并回到行首，在MAC上，\r就表现为回到本行开头并往下一行，至于ENTER键的定义是与操作系统有关的。通常用的Enter是两个加起来。</p>
<p>不同操作系统下的含义：</p>
<p>\n:  UNIX 系统行末结束符</p>
<p>\r\n: window 系统行末结束符</p>
<p>\r:  MAC OS 系统行末结束符</p>
</blockquote>
<h3 id="原始字符串r"><a href="#原始字符串r" class="headerlink" title="原始字符串r"></a>原始字符串r</h3><p>如果我们想输出一个Windows里的路径例如D:\World of Warcraft\test\WoW64.exe 这里面会有多个斜杠。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'D:\World of Warcraft\test\WoW64.exe'</span>)</span><br><span class="line">D:\World of Warcraft	est\WoW64.exe</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>你会发现这边\test由于出现了\t，程序会认为这是一个制表符。我们也不能保证Windows里的路径一定不出现这种特殊的东西。有两种办法解决。第一种是在每个斜杠前面加上\转意，来表示后面的斜杠没有特殊意义。这样比较麻烦。另一种办法就是使用r 原始字符串，代表后面的所有内容均是普通字符串，没有任何其他意义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">r'D:\World of Warcraft\test\WoW64.exe'</span>)</span><br><span class="line">D:\World of Warcraft\test\WoW64.exe</span><br></pre></td></tr></table></figure>
<h3 id="什么叫有序或者说序列类型"><a href="#什么叫有序或者说序列类型" class="headerlink" title="什么叫有序或者说序列类型"></a>什么叫有序或者说序列类型</h3><p>之前提到了字符串是一种有序的类型，什么叫有序呢？就是字符串里的每个字符都有对应的位置。可以通过索引的办法提取出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>String = <span class="string">'Playstation4'</span> \\将Playstation4的值赋予给变量String</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[<span class="number">0</span>]  \\提取变量String的第<span class="number">0</span>号位置的值</span><br><span class="line"><span class="string">'P'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[<span class="number">3</span>] \\提取变量String的第<span class="number">3</span>号位置的值</span><br><span class="line"><span class="string">'y'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>计算机数数都是从0开始的。所以Playstation4对应的位置就是</p>
<p><img src="/2018/08/09/Python-Basic/2.png" alt="2"></p>
<h3 id="什么叫可变类型"><a href="#什么叫可变类型" class="headerlink" title="什么叫可变类型"></a>什么叫可变类型</h3><p>刚才提到了序列，接下来谈谈可变。字符串的类型是不可变，也就是说你不能更改字符串里的某一个字的值。要想更改，只能重新整个赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>String = <span class="string">'Playstation4'</span> \\将Playstation4赋值给变量String</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[<span class="number">3</span>] = <span class="string">'O'</span> \\将String变量的第三位更改成字符串O</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'str'</span> object does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure>
<p>这边报错了 。代表字符串确实是不可变的，后面在讲列表的时候这种操作就是可以被执行的。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>python的多态说法非常多。这边直接拿实际操作举例吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'-'</span>*<span class="number">10</span>)</span><br><span class="line">----------</span><br></pre></td></tr></table></figure>
<p>上面代码的意思是 打印- 后面*10代表 -乘10。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Cisco'</span>*<span class="number">4</span></span><br><span class="line"><span class="string">'CiscoCiscoCiscoCisco'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3</span>*<span class="number">2</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>如果是C语言这种 直接拿字符串乘一个数字是肯定会报错的。但是python这种语言的多态特性就可以做到这种事情</p>
<h3 id="循环迭代"><a href="#循环迭代" class="headerlink" title="循环迭代"></a>循环迭代</h3><p>只要是序列类型 都可以用For循环进行迭代处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str = <span class="string">'Cisco'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> str:</span><br><span class="line"><span class="meta">... </span>    print(x)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">C</span><br><span class="line">i</span><br><span class="line">s</span><br><span class="line">c</span><br><span class="line">o</span><br></pre></td></tr></table></figure>
<p>第一次循环会迭代str里的第一个值C 然后打印出来 回车，第二次会迭代第二个值 i 打印出来 然后回车。以此类推。 每次循环迭代出的内容就会赋值给x。for循环可以对<strong>序列类型</strong>对象进行迭代。把每次迭代的结果进行输出。如果输出的时候不想要自动换行。可以这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> str:</span><br><span class="line"><span class="meta">... </span>    print(x,end=<span class="string">''</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Cisco&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>其中end=’’代表每次迭代以空为结束。</p>
<h3 id="索引和切片"><a href="#索引和切片" class="headerlink" title="索引和切片"></a>索引和切片</h3><p><strong>所有的序列类型都可以索引和切片</strong></p>
<p>拿字符串Playstation4来说。</p>
<p><img src="/2018/08/09/Python-Basic/2.png" alt="2"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>String = <span class="string">'Playstation4'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[<span class="number">3</span>]</span><br><span class="line"><span class="string">'y'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这是提取String字符串中3号位置的示例。[3]代表3号位置 这种方式叫索引。</p>
<p>也可以倒过来提取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[<span class="number">-1</span>]</span><br><span class="line"><span class="string">'4'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>除了索引，我们还可以进行切片</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[<span class="number">1</span>:<span class="number">7</span>]</span><br><span class="line"><span class="string">'laysta'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p> 对比上面的位置 我们会发现处于7号位置的’t’并没有出现。1号位的’l’出现了。</p>
<p>这种切片方式，左边的叫下边缘，右边的叫上边缘。默认上边缘是不要的。也就是输出了不包含上边缘</p>
<p>其他的切片方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[:<span class="number">7</span>] \\从<span class="number">0</span>位开始到<span class="number">6</span></span><br><span class="line"><span class="string">'Playsta'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[<span class="number">-2</span>:] \\从<span class="number">-2</span>开始一直到后面的所有位</span><br><span class="line"><span class="string">'n4'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[:<span class="number">-2</span>] \\从头开始到<span class="number">-2</span>位（<span class="number">-2</span>位不要）</span><br><span class="line"><span class="string">'Playstatio'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>String[:] \\所有都要</span><br><span class="line"><span class="string">'Playstation4'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="字符串的拼接格式问题"><a href="#字符串的拼接格式问题" class="headerlink" title="字符串的拼接格式问题"></a>字符串的拼接格式问题</h3><p>例如我们想把字符串拼一起</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Play'</span> + <span class="string">'Station'</span></span><br><span class="line"><span class="string">'PlayStation'</span></span><br></pre></td></tr></table></figure>
<p>字符串之间的拼接是没问题的。</p>
<p>如果再来一个4呢</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Play'</span> + <span class="string">'Station'</span> + <span class="number">4</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only concatenate str (<span class="keyword">not</span> <span class="string">"int"</span>) to str</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>你会发现报错 并且提示字符串不能和数字相加。这个时候需要做转换</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Play'</span> + <span class="string">'Station'</span> + str(<span class="number">4</span>)</span><br><span class="line"><span class="string">'PlayStation4'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><code>str(4)</code>代表将括号里的内容转换成字符串。这样就可以拼接了。</p>
<h2 id="字符串格式化表达式和方法"><a href="#字符串格式化表达式和方法" class="headerlink" title="字符串格式化表达式和方法"></a>字符串格式化表达式和方法</h2><p>在输出字符串的时候我们希望能够把字符串做格式化，显示出来干净整齐，格式统一。这就是字符串格式表达式的目的。</p>
<p>字符串格式化有两种方法。第一种是传统表达式方法，第二种是新方法。来体验一下</p>
<h3 id="传统方法（表达式）"><a href="#传统方法（表达式）" class="headerlink" title="传统方法（表达式）"></a>传统方法（表达式）</h3><p>String formatting expressions: ‘…%s…’(values)</p>
<p>%左边是一个格式化的字符串，包含一个或多个嵌套的转换目标，每个目标用%开始。</p>
<p>%右边提供一个或者多个对象(多个对象需要放在元组中)，这些对象用来替换%左边的转换对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'Playstation%d is %s'</span>%(<span class="number">4</span>,<span class="string">'belong to sony'</span>)</span><br><span class="line"><span class="string">'Playstation4 is belong to sony'</span></span><br></pre></td></tr></table></figure>
<p>能够看到。整个语句用%分隔开，分成左边和右边。左边是已经格式化了的字符串，右边是用来替换%d和%s的内容。</p>
<p>其中%d这个地方要替换的是整数</p>
<p>%s代表这个地方要替换的是字符串。</p>
<p>要替换的值放在元组里，元组在后面会介绍。其实就是用小括号括起来的东西。</p>
<p>一般%后面就会用到三个</p>
<p>%d—-整数</p>
<p>%s—-字符串</p>
<p>%f—-浮点</p>
<h4 id="完整表达式语法"><a href="#完整表达式语法" class="headerlink" title="完整表达式语法"></a>完整表达式语法</h4><p>%[(keyname)][flags][width][.precision]typecode</p>
<ul>
<li>keyname代表%后面其实还可以放一个字典的键值，由于字典还没有涉及到，这边先放着</li>
<li>flags可以指明字符串是左对齐(-)还是右对齐还是用0补齐,默认右对齐。</li>
<li>width代表整体宽度</li>
<li>如果是小数还可以用.后面跟数字来表示小数点位数 例如.2f表示保留小数点后2位的浮点数</li>
</ul>
<p>还是来实操感受一下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>example = <span class="string">'...%d....%-10d....%10d...%010d'</span>%(int,int,int,int)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(example)</span><br><span class="line">..<span class="number">.98765</span>...<span class="number">.98765</span>     ....     <span class="number">98765.</span>.<span class="number">.0000098765</span></span><br></pre></td></tr></table></figure>
<p>第一个%d代表直接输出</p>
<p>第二个%-10d代表左对齐输出，宽度10</p>
<p>第三个%10d代表右对齐输出，宽度10</p>
<p>%010d代表右对齐输出，宽度10，不足的位置用0补齐</p>
<p>得出的结果就如上所示了。</p>
<p>接下来看看关于浮点数的输出</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>float = <span class="number">6.123151253464567</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example = <span class="string">'%f|%.2f|%010.3f|%5.2f'</span>%(float,float,float,float)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(example)</span><br><span class="line"><span class="number">6.123151</span>|<span class="number">6.12</span>|<span class="number">000006.123</span>| <span class="number">6.12</span></span><br></pre></td></tr></table></figure>
<p>第一个%f啥也不做</p>
<p>第二个%.2f代表保留小数点后2位</p>
<p>第三个%010.3f代表右对齐，长度10位，不够的用0补齐</p>
<p>第四个%5.2f代表右对齐，保留小数点后2位并且占5位长度</p>
<h3 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h3><p>String formatting method calls:’…{}…’.format(values)</p>
<p>刚才讲的是传统的方法。现在来看一下新方法。</p>
<h4 id="完整语法"><a href="#完整语法" class="headerlink" title="完整语法"></a>完整语法</h4><p>{fieldname component !conversionflag :formatspec}</p>
<ul>
<li>Filename是指定参数的关键字或数字，后面跟可选的’.name’(属性)或者’[index]’(键值)成分引用</li>
<li>conversionflag可以是r,s或者a分别是该值上对repr，str，ascii内置函数的一次调用</li>
<li>formatspec指定如何表示该值，包括宽度，对齐方式，补零，小数点精确度等。</li>
</ul>
<p>还是来实操一下吧</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">'&#123;0&#125;,&#123;1&#125;,and &#123;2&#125;'</span>.format(<span class="string">'Playstation'</span>,<span class="string">'Nintendo'</span>,<span class="string">'Mircosoft'</span>)</span><br><span class="line"><span class="string">'Playstation,Nintendo,and Mircosoft'</span></span><br></pre></td></tr></table></figure>
<p>这是基于位置的方法，意思是0号位置是playstation，1号位置是nintendo，2号位置是microsoft。还有基于名字的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">'&#123;Playstation4&#125;,&#123;Switch&#125;,&#123;XboxOne&#125;'</span></span><br><span class="line">str.format(Playstation4=Sony,Switch=Nintendo,XboxOne=Microsoft)</span><br><span class="line">str.format(Playstation4=<span class="string">'Sony'</span>,Switch=<span class="string">'Nintendo'</span>,XboxOne=<span class="string">'Microsoft'</span>)</span><br><span class="line"><span class="string">'Sony,Nintendo,Microsoft'</span></span><br></pre></td></tr></table></figure>
<p>这就相当于有Playstation位，Switch位和XboxOne位。</p>
<p>当然 这两种方法可以混合起来用。</p>
<p>刚才提到了老方法可以控制宽度，小数点位数等。新方法当然也可以。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">'&#123;Sony:10&#125;,&#123;Microsoft:10&#125;,&#123;Nintendo:10&#125;'</span></span><br><span class="line">str.format(Sony=<span class="string">'Playstation4'</span>,Microsoft=<span class="string">'XboxOne'</span>,Nintendo=<span class="string">'Switch'</span>)</span><br><span class="line"><span class="string">'Playstation4,XboxOne   ,Switch    '</span></span><br></pre></td></tr></table></figure>
<p>跟老方法一样，:10代表宽度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str=<span class="string">'&#123;Sony:10&#125;,&#123;Microsoft:^10&#125;,&#123;Nintendo:&lt;10&#125;'</span></span><br><span class="line">str.format(Sony=<span class="string">'Playstation4'</span>,Microsoft=<span class="string">'XboxOne'</span>,Nintendo=<span class="string">'Switch'</span>)</span><br><span class="line"><span class="string">'Playstation4, XboxOne  ,Switch    '</span></span><br></pre></td></tr></table></figure>
<p>^代表居中。</p>
<p>&lt;代表左对齐</p>
<p>>代表右对齐</p>
<p>关于小数的操作方法和老方法一样，就不再赘述了。</p>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式较为复杂。我参考了</p>
<p><a href="http://www.regexlab.com/zh/regref.htm" target="_blank" rel="noopener">这里</a>和<a href="https://zh.wikipedia.org/wiki/正则表达式" target="_blank" rel="noopener">这里</a>来写。</p>
<p>正则表达式可以用来匹配一些特定的字符串。其实在BGP就有用到正则表达式。BGP的AS-PATH就是使用正则表达式来匹配AS号。</p>
<h3 id="如何匹配各种字符"><a href="#如何匹配各种字符" class="headerlink" title="如何匹配各种字符"></a>如何匹配各种字符</h3><p>在Python中想使用正则表达式需要引入re模块。使用<code>import re</code>来引入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'explorer.exe'</span>,<span class="string">'explorereexe'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">12</span>), match=<span class="string">'explorereexe'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'explorer.exe'</span>,<span class="string">'fjdlskajlf'</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>最简单的使用方法就像上面这样。</p>
<p>re.match代表使用re模块里面的match动作，括号中左边的就是正则表达式，用逗号隔开之后右边就是要匹配的东西。如果有匹配上，程序就会返回值。这边能看到确实匹配上了，匹配上的内容是0到12位。如果匹配不上就不会返回任何值。</p>
<p>这边能匹配上可能会有问题。我匹配的条件是<strong>explorer.exe</strong>给他匹配的东西是<strong>explorereexe</strong>。但是还是匹配上了。明明有个点不一样，为什么还是能匹配上？这边就需要了解正则表达式中符号的特殊意义。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>能匹配的东西</th>
</tr>
</thead>
<tbody>
<tr>
<td>\d</td>
<td>任意数字，即0～9</td>
</tr>
<tr>
<td>\w</td>
<td>任意字母，下划线或者数字就是A~Z,a-z,0~9以及_</td>
</tr>
<tr>
<td>\s</td>
<td>包括空格、制表符、回车换行等空字符</td>
</tr>
<tr>
<td>.</td>
<td>除了换行符号\n以外的所有字符</td>
</tr>
</tbody>
</table>
</div>
<p>所以难怪上面能匹配上了。点可以匹配除了换行以外的任意字符。</p>
<p>那如果只想匹配explorer.exe怎么办？这边就需要用到转意符。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'explorer\.exe'</span>,<span class="string">'explorer.exe'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">12</span>), match=<span class="string">'explorer.exe'</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'explorer\.exe'</span>,<span class="string">'exploreraexe'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="匹配多种字符的表达式"><a href="#匹配多种字符的表达式" class="headerlink" title="匹配多种字符的表达式"></a>匹配多种字符的表达式</h3><p>使用方括号[]扩起来一些字符，能够匹配其中的任意一个字符；用[^]扩起来一些字符，能够匹配除了其中这些字符之外的任意字符。只能匹配其中的一个或者除开其中的一个，不能是多个。下面看一些例子。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody>
<tr>
<td>[abc5@]</td>
<td>a,b,c,5,@</td>
</tr>
<tr>
<td><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup></td>
<td>除了a，b，c之外的任意字符</td>
</tr>
<tr>
<td>[a-k]</td>
<td>a-k之间的任意字母</td>
</tr>
<tr>
<td><sup><a href="#fn_A-F0-3" id="reffn_A-F0-3">A-F0-3</a></sup></td>
<td>除了A到F和0-3之间的任意字符</td>
</tr>
</tbody>
</table>
</div>
<p>下面来看几个实例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'[bcd][bcd]'</span>,<span class="string">'bc123'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">2</span>), match=<span class="string">'bc'</span>&gt; \\匹配上的是bc</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'[^abc]'</span>,<span class="string">'123'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">1</span>), match=<span class="string">'1'</span>&gt; \\匹配上的是<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="修饰匹配次数"><a href="#修饰匹配次数" class="headerlink" title="修饰匹配次数"></a>修饰匹配次数</h3><p> 前面章节中讲到的表达式，无论是只能匹配一种字符的表达式，还是可以匹配多种字符其中任意一个的表达式，都只能匹配一次。如果使用表达式再加上修饰匹配次数的特殊符号，那么不用重复书写表达式就可以重复匹配。</p>
<p>使用方法是：”次数修饰”放在”被修饰的表达式”后边。比如：”[bcd][bcd]” 可以写成 “[bcd]{2}”。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>{n}</td>
<td>表达式重复n次</td>
</tr>
<tr>
<td>{m,n}</td>
<td>表达式至少重复m次，最多重复n次</td>
</tr>
<tr>
<td>{m,}</td>
<td>表达式至少重复m次</td>
</tr>
<tr>
<td>?</td>
<td>匹配表达式至少出现0或者1次</td>
</tr>
<tr>
<td>+</td>
<td>表达式至少出现1次</td>
</tr>
<tr>
<td>*</td>
<td>表达式不出现或者出现任意次</td>
</tr>
</tbody>
</table>
</div>
<p>下面来看一组例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;'</span>,<span class="string">'192.168.1.100'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">13</span>), match=<span class="string">'192.168.1.100'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以用上述的表达式匹配IPv4地址。</p>
<p>IPv4的地址每8位都用点来分隔，数字的范围是0到9则用[0-9]匹配。 出现至少一次，最多三次，就用{1,3}匹配。小数点本身需要有\.来匹配。当然 这样写非常长。也不太好看。有没有简单方法呢。</p>
<h3 id="表示抽象意义的符号"><a href="#表示抽象意义的符号" class="headerlink" title="表示抽象意义的符号"></a>表示抽象意义的符号</h3><div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>于字符串开始的地方匹配，本身无意义</td>
</tr>
<tr>
<td>$</td>
<td>于字符串结束的地方匹配，本身无意义</td>
</tr>
<tr>
<td>()</td>
<td>在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰</td>
</tr>
<tr>
<td>\</td>
<td></td>
<td>左右表达式之间是或的关系，匹配左边或者右边。</td>
</tr>
</tbody>
</table>
</div>
<p>来看两组例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">re.match(<span class="string">'([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;'</span>,<span class="string">'192.168.1.1'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">11</span>), match=<span class="string">'192.168.1.1'</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.match(<span class="string">'^aaa'</span>,<span class="string">'aaafdafadfawfa'</span>)</span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">3</span>), match=<span class="string">'aaa'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>第一个例子是将上面的匹配IPv4地址进行了简化。用括号将[0-9]{1,3}\.扩起来。然后后面跟上{3}代表出现3次。后面再单独写[0-9]{1,3} 代表不带点 在单独出现一次。这样一来就能匹配到完整的IPv4地址</p>
<p>后面的则是^aaa,代表字符串必须以aaa开头。至于后面是什么不管。</p>
<h2 id="列表和字典"><a href="#列表和字典" class="headerlink" title="列表和字典"></a>列表和字典</h2><div class="table-container">
<table>
<thead>
<tr>
<th>对象</th>
<th>类型</th>
<th>可变</th>
</tr>
</thead>
<tbody>
<tr>
<td>List(列表)</td>
<td>Sequence(序列)</td>
<td>可变</td>
</tr>
<tr>
<td>Dictionaries(字典)</td>
<td>Mapping(映射)</td>
<td>可变</td>
</tr>
</tbody>
</table>
</div>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>一看到序列类型，我们就知道，一定可以根据索引提取内容，可以切片。可以改的。字符串我们体会过，根据某个位置去改值 是不行的。但是列表就可以。</p>
<p>列表的主要属性有以下几个：</p>
<ul>
<li><strong>任意</strong>对象的<strong>有序集合</strong></li>
<li>通过<strong>偏移</strong>读取</li>
<li>可变长度，异构以及任意嵌套</li>
<li>属于<strong>可变序列</strong>的分类</li>
<li>对象引用数组</li>
</ul>
<p>什么叫任意对象？就是说列表里放字符，数字，甚至再放列表都是可以的。有序就是可以通过索引的方式提取。通过操作来感受一下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="string">'cisco'</span>,<span class="number">123</span>,[<span class="string">'H3C'</span>,<span class="string">'BSD'</span>,<span class="string">'Linux'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="string">'cisco'</span>, <span class="number">123</span>, [<span class="string">'H3C'</span>, <span class="string">'BSD'</span>, <span class="string">'Linux'</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list [<span class="number">2</span>]</span><br><span class="line">[<span class="string">'H3C'</span>, <span class="string">'BSD'</span>, <span class="string">'Linux'</span>]</span><br></pre></td></tr></table></figure>
<p>又或者把0号位置的cisco改成大写的CISCO</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">0</span>]=<span class="string">'CISCO'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="string">'CISCO'</span>, <span class="number">123</span>, [<span class="string">'H3C'</span>, <span class="string">'BSD'</span>, <span class="string">'Linux'</span>], <span class="string">'Playstation'</span>]</span><br></pre></td></tr></table></figure>
<p>如果想要提取列表中的列表，则可以这样</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">2</span>][<span class="number">0</span>]</span><br><span class="line"><span class="string">'H3C'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list[<span class="number">2</span>][<span class="number">1</span>]</span><br><span class="line"><span class="string">'BSD'</span></span><br></pre></td></tr></table></figure>
<p>列表也可以直接用+号连接在一起。</p>
<h4 id="列表的常见操作方法"><a href="#列表的常见操作方法" class="headerlink" title="列表的常见操作方法"></a>列表的常见操作方法</h4><h5 id="len"><a href="#len" class="headerlink" title="len"></a>len</h5><p>使用len()可以提取列表的长度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="string">'CISCO'</span>, <span class="number">123</span>, [<span class="string">'H3C'</span>, <span class="string">'BSD'</span>, <span class="string">'Linux'</span>], <span class="string">'Playstation'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(list)</span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>这里显示list这个列表有4个元素。分别是CISCO 123 一个列表和 Playstation。计算长度是从1开始算的。</p>
<h5 id="in"><a href="#in" class="headerlink" title="in"></a>in</h5><p>也可以用 in 来判断</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'CISCO'</span> <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Cisco'</span> <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>以及所有序列类型都可以用for循环。这里不再赘述。</p>
<h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><p>我们可以通过append方法来往列表后面追加</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list.append(<span class="string">'Playstation'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="string">'cisco'</span>, <span class="number">123</span>, [<span class="string">'H3C'</span>, <span class="string">'BSD'</span>, <span class="string">'Linux'</span>], <span class="string">'Playstation'</span>]</span><br></pre></td></tr></table></figure>
<h5 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h5><p>插入操作。可以在列表中指定位置去插入。例如上面的list。在1位置插入。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list = [<span class="number">1</span>,<span class="string">'Cisco'</span>,<span class="string">'H3C'</span>,<span class="string">'Python'</span>] \\创建列表</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list \\显示列表</span><br><span class="line">[<span class="number">1</span>, <span class="string">'Cisco'</span>, <span class="string">'H3C'</span>, <span class="string">'Python'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list.insert(<span class="number">1</span>,<span class="string">'Playstation'</span>) \\在<span class="number">1</span>位置插入Playstation</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list  \\显示列表</span><br><span class="line">[<span class="number">1</span>, <span class="string">'Playstation'</span>, <span class="string">'Cisco'</span>, <span class="string">'H3C'</span>, <span class="string">'Python'</span>] \\<span class="number">1</span>位置变成了Playstation，其他元素往后顺移。</span><br></pre></td></tr></table></figure>
<h5 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h5><p>remove 可以移除列表中的某个元素。只能填具体的值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="number">1</span>, <span class="string">'Playstation'</span>, <span class="string">'Cisco'</span>, <span class="string">'H3C'</span>, <span class="string">'Python'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list.remove(<span class="string">'Cisco'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list</span><br><span class="line">[<span class="number">1</span>, <span class="string">'Playstation'</span>, <span class="string">'H3C'</span>, <span class="string">'Python'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是映射类型，是通过“键”来提取“值”。所以不能通过索引提取值。由于不是序列，所以也不能切片了。</p>
<p>创建字典的方法很简单 如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="string">'name'</span>:<span class="string">'leexu'</span>,<span class="string">'age'</span>:<span class="number">23</span>&#125;</span><br><span class="line"> a.get(<span class="string">'name'</span>)</span><br><span class="line"><span class="string">'leexu'</span></span><br></pre></td></tr></table></figure>
<p>可以通过get()来提取键值.</p>
<p>也可以用dict()来创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = dict(name=<span class="string">"leexu"</span>,age=<span class="number">23</span>)</span><br><span class="line">b</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'leexu'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="字典的增加和修改"><a href="#字典的增加和修改" class="headerlink" title="字典的增加和修改"></a>字典的增加和修改</h4><p>给字典增加键值对，如果键已经存在，则会覆盖，如果不存在，则增加新的键值对</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = dict(name=<span class="string">"leexu"</span>,age=<span class="number">23</span>)</span><br><span class="line">b</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'leexu'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br><span class="line">b[<span class="string">'name'</span>]=<span class="string">'lixu'</span></span><br><span class="line">b</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'lixu'</span>, <span class="string">'age'</span>: <span class="number">23</span>&#125;</span><br><span class="line">b[<span class="string">'job'</span>]=<span class="string">'teacher'</span></span><br><span class="line">b</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'lixu'</span>, <span class="string">'age'</span>: <span class="number">23</span>, <span class="string">'job'</span>: <span class="string">'teacher'</span>&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Spanning Tree</title>
    <url>/2018/07/17/Spanning-Tree/</url>
    <content><![CDATA[<h1 id="生成树概览"><a href="#生成树概览" class="headerlink" title="生成树概览"></a>生成树概览</h1><p>在较简单的交换网络中，为了防止出现单点故障，经常会做冗余链路来提高整个交换网络的可靠性。</p>
<a id="more"></a>
<p><img src="/2018/07/17/Spanning-Tree/1.png" alt="1"><br>如图所示，若switch0和switch2下方均接入了若干PC，当网络中任意一点出现故障时，整个网络将会变得不可用，这显然是不行的。所以一般会在SWITCH0和SWITCH2之间再连一根线，这种拓扑就是有冗余链路的拓扑。这样可以防止网络中的单点故障问题。但是也随之带来了新问题。那就是网络环路。而生成树就是为了破除冗余链路带来的环路问题而被提出的。</p>
<h1 id="802-1d"><a href="#802-1d" class="headerlink" title="802.1d"></a>802.1d</h1><h2 id="BPDU报文"><a href="#BPDU报文" class="headerlink" title="BPDU报文"></a>BPDU报文</h2><p>   交换机之间通过BPDU报文的交互来计算生成树。生成树之所以叫生成树，是因为破环就是在环形的冗余链路中计算出一个无环的树形结构。</p>
<p>   BPDU报文一共有两种：配置BPDU（configuration BPDU）和TCN（topology change notification）</p>
<h2 id="配置BPDU"><a href="#配置BPDU" class="headerlink" title="配置BPDU"></a>配置BPDU</h2><p>2.1 交换网络在刚开始运行的阶段，所有交换机都会从所有的端口发送BPDU，大家都认为自己是root，随着BPDU的泛洪和收集，根据BPDU中的信息，交换机会算出一个结果。root会被选举出来，整个交换网络有且只有一个root。（选举root的过程先不提，后面再说。）在此之后由root以默认的每隔2s为周期发送BPDU，所有的非root交换机从自己的根端口收到BPDU，再从自己的指定端口产生bpdu发出去。被block的非指定端口会不断侦听链路上的bpdu，当其在一段时间内没有收到bpdu，则认为链路出现故障。开始新的收敛阶段。</p>
<blockquote>
<p>a)  A Bridge that believes itself to be the Root (all Bridges start by believing themselves to be the Root until they discover otherwise) originates Configuration Messages (by transmitting Configuration BPDUs) on all the LANs to which it is attached, at regular intervals. </p>
<p>b)  A Bridge that receives a Configuration BPDU on what it decides is its Root Port conveying better information (i.e., highest priority Root Identifier, lowest Root Path Cost, highest priority transmit- ting Bridge and Port), passes that information on to all the LANs for which it believes itself to be the Designated Bridge. </p>
<p>c)  A Bridge that receives inferior information, on a Port it considers to be the Designated Port on the LAN to which it is attached, transmits its own information in reply, for all other Bridges attached to that LAN to hear. </p>
</blockquote>
<p>配置BPDU的结构如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. Protocol ID:       2 bytes (0x0000 IEEE 802.1D)</span><br><span class="line"> 2. Version ID:        1 byte (0x00 Config &amp; TCN / 0x02 RST / 0x03 MST / 0x04 SPT  BPDU) </span><br><span class="line"> 3. BPDU Type:         1 byte (0x00 STP Config BPDU, 0x80 TCN BPDU, 0x02 RST/MST Config BPDU)</span><br><span class="line"> 4. Flags:             1 byte</span><br><span class="line">   bits  : usage</span><br><span class="line">       1 : 0 or 1 for Topology Change</span><br><span class="line">       2 : 0 (unused) or 1 for Proposal in RST/MST/SPT BPDU</span><br><span class="line">     3-4 : 00 (unused) or</span><br><span class="line">           01 for Port Role Alternate/Backup in RST/MST/SPT BPDU</span><br><span class="line">           10 for Port Role Root in RST/MST/SPT BPDU</span><br><span class="line">           11 for Port Role Designated in RST/MST/SPT BPDU</span><br><span class="line">       5 : 0 (unused) or 1 for Learning in RST/MST/SPT BPDU</span><br><span class="line">       6 : 0 (unused) or 1 for Forwarding in RST/MST/SPT BPDU</span><br><span class="line">       7 : 0 (unused) or 1 for Agreement in RST/MST/SPT BPDU</span><br><span class="line">       8 : 0 or 1 for Topology Change Acknowledgement</span><br><span class="line"> 5. Root ID:           8 bytes (CIST Root ID in MST/SPT BPDU)</span><br><span class="line">   bits  : usage</span><br><span class="line">     1-4 : Root Bridge Priority</span><br><span class="line">    5-16 : Root Bridge System ID Extension</span><br><span class="line">   17-64 : Root Bridge MAC Address</span><br><span class="line"> 6. Root Path Cost:    4 bytes (CIST External Path Cost in MST/SPT BPDU)</span><br><span class="line"> 7. Bridge ID:         8 bytes (CIST Regional Root ID in MST/SPT BPDU)</span><br><span class="line">   bits  : usage</span><br><span class="line">     1-4 : Bridge Priority </span><br><span class="line">    5-16 : Bridge System ID Extension</span><br><span class="line">   17-64 : Bridge MAC Address</span><br><span class="line">  8. Port ID:          2 bytes</span><br><span class="line">  9. Message Age:      2 bytes in 1/256 secs</span><br><span class="line"> 10. Max Age:          2 bytes in 1/256 secs</span><br><span class="line"> 11. Hello Time:       2 bytes in 1/256 secs</span><br><span class="line"> 12. Forward Delay:    2 bytes in 1/256 secs</span><br><span class="line"> 13. Version 1 Length: 1 byte (0x00 no ver 1 protocol info present. RST, MST, SPT BPDU only)</span><br><span class="line"> 14. Version 3 Length: 2 bytes (MST, SPT BPDU only)</span><br><span class="line">                    ——————摘自维基百科</span><br></pre></td></tr></table></figure>
<p>每个字段的意义大体如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>字节</th>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>2</td>
<td>协议（protocol）</td>
<td>代表上层协议（BPDU），该值总为0.</td>
</tr>
<tr>
<td>1</td>
<td>版本（version）</td>
<td>802.1d总为0</td>
</tr>
<tr>
<td>1</td>
<td>类型（Type）</td>
<td>配置BPDU为0x00、TCN BPDU为0x80</td>
</tr>
<tr>
<td>1</td>
<td>标识（Flag）</td>
<td>LSB最低有效位置位表示TC标识，MSB最高有效位置位表示TCA标识</td>
</tr>
<tr>
<td>8</td>
<td>根ID（Root ID）</td>
<td>根桥的桥ID</td>
</tr>
<tr>
<td>4</td>
<td>路径开销（Path Cost）</td>
<td>到达根桥的开销</td>
</tr>
<tr>
<td>8</td>
<td>网桥ID（Bridge ID）</td>
<td>BPDU发送桥的ID</td>
</tr>
<tr>
<td>2</td>
<td>端口ID（Port ID）</td>
<td>BPDU发送网桥的端口ID（优先级+端口号）</td>
</tr>
<tr>
<td>2</td>
<td>消息寿命（Message age）</td>
<td>从根网桥发出BPDU之后的秒数，每经过一个网桥都-1，所以本质上是到达根桥的跳数。</td>
</tr>
<tr>
<td>2</td>
<td>最大寿命（Max age）</td>
<td>当一段时间未收到任何BPDU，生存期到达MAX age时，网桥认为该端口连接的链路发生故障。也可理解为BPDU的最大寿命，默认20s</td>
</tr>
<tr>
<td>2</td>
<td>HELLO时间（Hello Time）</td>
<td>根网桥连续发出BPDU之间的时间间隔，默认2s</td>
</tr>
<tr>
<td>2</td>
<td>转发延迟（Forward Delay）</td>
<td>在侦听和学习状态停留的时间，默认15s。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="TCN-BPDU"><a href="#TCN-BPDU" class="headerlink" title="TCN BPDU"></a>TCN BPDU</h2><p>3.1 TCN BPDU在网络拓扑发生变化时产生。TYPE字段为0x80，FLAG字段LSB和MSB位均置。</p>
<p>   当网络拓扑发生变化的时候，最先意识到变化的交换机会从根端口发送TCN到上一层交换机，一直到根交换机，上层交换机除了接着向其上层发送TCN之外，也会回一个TCA的确认信息给前一个交换机。当根接受到TC后发送TCA回最开始的交换机并向所有交换机发送TC。交换机收到ROOT发来的TC后，会将MAC地址表的老化时间缩减为15S（一个转发延迟），这个TC会一直持续35S（20+15）。</p>
<h2 id="STP的运行"><a href="#STP的运行" class="headerlink" title="STP的运行"></a>STP的运行</h2><p>4.1 STP采用四个步骤来解决二层环路：</p>
<p>​ 4.1.1 在一个交换网络中选举一个root bridge</p>
<p>​ 4.1.2 在每个非根交换机上选举一个根端口（RP）</p>
<p>​ 4.1.3 为每个segment选举一个指定端口（DP）</p>
<p>​ 4.1.4 阻塞非指定端口</p>
<p>4.2 比较原则</p>
<p>​ 4.2.1 STP需要网络设备相互交换消息来检测桥接环路，这个消息就叫<strong>BPDU（桥协议数据单元）</strong>即使是阻塞的端口也会不断收到BPDU。</p>
<p>​ 4.2.2 生成树总是按照以下步骤来生成一个无环的拓扑：</p>
<ul>
<li>最低的桥ID</li>
<li>到根桥最低的路径开销</li>
<li>最低的发送者桥ID</li>
<li>最低的发送者端口ID</li>
</ul>
<p>交换机使用这四个步骤分别选举出根交换机，根端口和指定端口。并且会保存各个端口收到的最好的BPDU。每收到一个新的BPDU，都会和这个最优的BPDU进行比较。如果收到的BPDU比保存的BPDU更优，则更新。反之则不做任何操作。</p>
<blockquote>
<p>注意：</p>
<p>根桥的角色是可以抢占的。桥ID中的MAC地址指的是交换机的背板MAC地址 使用show version | in bia查看。</p>
<p>sw1-huiju#show version | in Base<br>Base ethernet MAC Address       : 00:23:5E:26:D9:80</p>
<p>端口ID中的MAC是指端口的MAC地址。思科交换机上可使用show interfaces | in bia查看</p>
<p>sw1-huiju#show interfaces | in bia<br>  Hardware is EtherSVI, address is 0023.5e26.d9c0 (bia 0023.5e26.d9c0)<br>  Hardware is EtherSVI, address is 0023.5e26.d9c1 (bia 0023.5e26.d9c1)<br>  Hardware is EtherSVI, address is 0023.5e26.d9c2 (bia 0023.5e26.d9c2)<br>  Hardware is EtherSVI, address is 0023.5e26.d9c3 (bia 0023.5e26.d9c3)<br>  Hardware is EtherSVI, address is 0023.5e26.d9c4 (bia 0023.5e26.d9c4)<br>  Hardware is EtherSVI, address is 0023.5e26.d9c5 (bia 0023.5e26.d9c5)<br>  Hardware is EtherSVI, address is 0023.5e26.d9c6 (bia 0023.5e26.d9c6)</p>
</blockquote>
<p>接下来看几组802.1d的选举实例：</p>
<p><img src="/2018/07/17/Spanning-Tree/2.png" alt="2">)</p>
<p>如图所示，交换机X和Y的优先级分别是1111和2222，拓扑中存在冗余链路。BPDU在经过交换后，会进行两个参数的比较来选出根桥。一是优先级。在不手动进行更改的情况下。两台交换机的优先级都为32768。所以优先级这一块是比较不出来的。这种情况下会去比较MAC地址。MAC地址是比小的。所以交换机X胜出。</p>
<p>​      <img src="/2018/07/17/Spanning-Tree/3.png" alt="3"></p>
<p>​     接下来看这组选举实例。先进行根桥的选举。根桥选举先看优先级。交换机X，Y，Z都是32768 所以比较不出来。那么就会看交换机的MAC地址。交换机Z的最小。胜出。所以交换机Z是根桥。根桥上所有的端口都是指定端口，处于转发状态。之后在非根交换机上选举根端口。</p>
<p>​     根端口的定义是去往根桥最小的路径开销。那么按照下面这幅图</p>
<p><img src="/2018/07/17/Spanning-Tree/4.png" alt="4"></p>
<p>由图上的100Base-T和10Base-T可得，X和Y之间的链路开销会比XZ以及XY之间的大。所以交换机X和Y的port0胜出。为根端口。</p>
<p>接下来在XY之间的链路选举指定端口。由于交换机X的MAC地址较小。所以交换机X胜出。交换机X的port1为指定端口。那么就只剩下交换机Y的port1了。它就是NDP非指定端口。会被阻塞。</p>
<h2 id="STP端口状态"><a href="#STP端口状态" class="headerlink" title="STP端口状态"></a>STP端口状态</h2><h3 id="为什么要有STP端口状态"><a href="#为什么要有STP端口状态" class="headerlink" title="为什么要有STP端口状态"></a>为什么要有STP端口状态</h3><p>   由于交换网络中存在传播的延迟。拓扑变更可能会发生在网络的任何时间，任何网段。如果二层接口直接从生成树的block状态过渡到转发状态。就可能会导致临时的环路。为了缓解这种问题，在一个端口开始转发数据之前，它应该等待新的拓扑信息传播到整个交换网络中。</p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>   阻塞状态到转发状态通常需要30～50秒，主要涉及到以下的计时器：</p>
<p>   <strong>Hello时间：</strong>根桥发送配置BPDU的时间间隔。默认是2s</p>
<p>   <strong>转发延迟：</strong>端口由侦听过渡到学习状态，学习状态过渡到转发状态所需要的时间。默认是15s</p>
<p>   <strong>最大存活时间：</strong> 在丢弃BPDU之前，网桥用来存储BPDU的时间。缺省为20s。如果连续20秒收不到BPDU。则进入侦听（listening）状态。</p>
<p>   网络中的生成树拓扑依附于根桥的计时器，根桥将BPDU中的计时器传递给第二层的所有交换机。</p>
<h3 id="STP各端口状态"><a href="#STP各端口状态" class="headerlink" title="STP各端口状态"></a>STP各端口状态</h3><div class="table-container">
<table>
<thead>
<tr>
<th>状态名称</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td>Disable</td>
<td>不收发任何报文</td>
</tr>
<tr>
<td>Blocking</td>
<td>不接受也不转发帧，接受但不发送BPDU，不学习MAC地址。</td>
</tr>
<tr>
<td>Listening</td>
<td>不接受也不转发帧，接受并发送BPDU，不学习MAC地址。</td>
</tr>
<tr>
<td>Learning</td>
<td>不接受也不转发帧，接受并发送BPUD，学习MAC地址。</td>
</tr>
<tr>
<td>Forwarding</td>
<td>接受并转发帧，接受并发送BPDU，学习MAC地址。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="STP端口状态转换过程"><a href="#STP端口状态转换过程" class="headerlink" title="STP端口状态转换过程"></a>STP端口状态转换过程</h3><p><img src="/2018/07/17/Spanning-Tree/5.png" alt="5"></p>
<h2 id="STP拓扑变更"><a href="#STP拓扑变更" class="headerlink" title="STP拓扑变更"></a>STP拓扑变更</h2><h3 id="TCN-BPDU概述"><a href="#TCN-BPDU概述" class="headerlink" title="TCN BPDU概述"></a>TCN BPDU概述</h3><p><strong>当网络拓扑出现变化时，最先发现变化的交换机将发送TCN BPDU。</strong></p>
<p><strong>发生以下事件时，交换机认为是拓扑变更，发送TCN BPDU</strong></p>
<ul>
<li>对于处于转发和监听状态的端口，过渡到block状态</li>
<li>端口进入转发状态，且这个网桥已经有指定接口</li>
<li>非根桥设备在它的指定端口收到TCN BPDU</li>
</ul>
<h3 id="TCN-BPDU-1"><a href="#TCN-BPDU-1" class="headerlink" title="TCN BPDU"></a>TCN BPDU</h3><p><strong>TCN BPDU包含3个字段，它与配置BPDU除了type字段之外的前3个字段完全相同</strong></p>
<h3 id="拓扑变更的过程"><a href="#拓扑变更的过程" class="headerlink" title="拓扑变更的过程"></a>拓扑变更的过程</h3><p>最先发现拓扑变更的交换机发送TCN，上游交换机接受到TCN会立即回送TCA被置位的BPDU来作确认。在上游交换机确认这个TCN之前，最先发现拓扑变更的交换机会持续发送TCN BPDU。</p>
<p>接下来上游交换机将在自己的根端口产生另外的TCN BPDU，并且这整个过程会重复，一直到这个拓扑变更被root知道为止。</p>
<h3 id="拓扑变更案例"><a href="#拓扑变更案例" class="headerlink" title="拓扑变更案例"></a>拓扑变更案例</h3><p><img src="/2018/07/17/Spanning-Tree/6.png" alt="6"></p>
<p>如图，假设Switch A发生了故障，SwitchB会感知到链路故障，然后向它的RP发送TCN BPDU，当上游交换机收到Switch B发来的TCN BPDU后会回送一个TCN ACK代表收到了Switch B的TCN BPDU。同时也会向其RP发送TCN BPDU。以此类推，目的是为了让ROOT收到TCN BPDU。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>Huawei</tag>
        <tag>H3C</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic Switching</title>
    <url>/2018/07/17/Basic-Switching/</url>
    <content><![CDATA[<h1 id="交换机工作原理"><a href="#交换机工作原理" class="headerlink" title="交换机工作原理"></a>交换机工作原理</h1><p>以太网交换机，在不做特别说明的情况下，一般指的是二层交换机。这种设备工作在OSI参考模型的第二层。依靠二层消息中的源和目标转发数据，可以提供多个接口，让各种设备互相连接起来。</p>
<a id="more"></a>
<p>交换机主要有三个功能</p>
<ul>
<li>地址学习</li>
<li>帧的转发和过滤</li>
<li>环路防止</li>
</ul>
<h2 id="地址学习"><a href="#地址学习" class="headerlink" title="地址学习"></a>地址学习</h2><p><img src="/2018/07/17/Basic-Switching/1.png" alt="1"></p>
<p>首先在刚开机时，MAC地址表是空的。交换机依靠这张表转发数据。可是在刚开机时，这张表里没有任何信息。这里以思科的设备为例。在设备上使用show mac address-table查看mac地址表</p>
<p><img src="/2018/07/17/Basic-Switching/2.png" alt="2"></p>
<p>这张表根据设备的不同，存储条目的上限也有不同。交换机学习mac地址的过程如下：</p>
<p>假设主机A发送数据帧给主机C。会带着自己的源mac地址发送数据。这里先不管目标mac是多少，交换机会先从E0接口学习到一个条目。那就是E0接口连接的设备mac地址是0260.8c01.1111.这是由源地址学习过来的。那么交换机上的mac表这时会多一个条目，变成如下所示的样子。</p>
<p><img src="/2018/07/17/Basic-Switching/3.png" alt="3"></p>
<p>但是这个时候给C的消息由于mac表中依然没有对应C的条目，所以这个时候交换机会做一个操作叫做泛洪。泛洪是指，当交换机收到未知的单播帧（目标mac地址在mac表中没有对应条目）时，将会把这个数据发送给除了收到这个帧的接口的所有接口，在图中，交换机会将从E0收到的未知单播帧发给E1，E2，E3。这样一来C一定会收到这个消息。C在回复A的时候由于之前已经记录过一次MAC地址，所以回复的帧不会泛洪，并且同时可以由E2学习到C的MAC地址。</p>
<h2 id="帧的过滤"><a href="#帧的过滤" class="headerlink" title="帧的过滤"></a>帧的过滤</h2><p><img src="/2018/07/17/Basic-Switching/4.png" alt="4"></p>
<h1 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h1><p>由于交换机在不做任何配置的情况下，收到广播会往所有接口转发，这样一来，广播域的范围便是整个交换机本身。会带来不便与管理和安全隐患。所以人们希望能够通过某种技术在交换机上逻辑地分隔广播范围。VLAN技术便应运而生了。</p>
<ul>
<li>一个VLAN中的所有设备都是在同一广播域内，不同VLAN为不同的广播域。</li>
<li>VLAN之间相互隔离，广播不能跨越VLAN传播，所以不同的VLAN之间的设备一般需要通过三层设备实现互相通信</li>
<li>一个VLAN一般就是一个子网。</li>
<li>VLAN的成员大多数是基于端口划分的。划分VLAN就是对交换机的端口划分。</li>
<li>VLAN工作在二层</li>
</ul>
<h2 id="VLAN工作原理"><a href="#VLAN工作原理" class="headerlink" title="VLAN工作原理"></a>VLAN工作原理</h2><p>交换机内部的数据一律带有VLAN Tag，当一个数据进入交换机端口时，如果没有带VLAN Tag，且该端口配置了PVID（Port VLAN ID）那么该数据就会被标记上端口的PVID。如果该数据已经带了VLAN Tag，那么即使该端口已经配置了PVID，交换机也不会再给数据帧标记VLAN Tag.PVID是指“端口缺省ID”的意思。</p>
<p>交换机端口类型一共有三种，由于端口类型不同所以对帧的处理过程也不同。</p>
<ol>
<li><p>Access端口处理帧的流程：</p>
<p>1） 收到一个二层帧</p>
<p>2） 判断该帧有没有VLAN tag</p>
<ul>
<li>没有，则标记上Access端口的PVID，进行第三步</li>
<li>有Tag，则比较该Tag和端口的PVID是否一致。若一致，进行第三步，否则丢弃。</li>
</ul>
<p>3） 根据帧的目标MAC地址和VLAN ID查找VLAN配置信息，决定从哪个端口把帧发送出去。</p>
<p>4） 交换机根据查到的出接口发送帧。</p>
<ul>
<li>当数据从access接口发出时，交换机先剥离VLAN Tag。然后再发送出去。</li>
<li>当数据帧从Trunk接口发出时，直接发送帧。</li>
<li>当数据从Hybrid接口发出时，交换机先判断VLAN在本端口的属性时Untag还是Tag。如果是Untag，则剥离VLAN Tag之后再发送，如果是Tag，则直接发送帧。</li>
</ul>
</li>
<li><p>Trunk端口处理帧的过程</p>
<p>1） 收到一个二层帧。</p>
<p>2） 判断帧是否有VLAN Tag。</p>
<ul>
<li>没有Tag，则标记上Trunk端口的PVID，进行下一步处理。</li>
<li>有Tag，则判断该trunk接口是否允许该Tag通过，允许则进行下一步处理，否则丢弃。</li>
</ul>
<p>3） 二层交换机根据目标MAC和VLAN ID，查找VLAN信息并把帧转发出去。</p>
<p>4） 交换机根据查到的出接口转发数据帧。</p>
<ul>
<li>当数据从access接口发出时，先剥离VLAN tag 再发送出去。</li>
<li>当数据从trunk接口发出时，直接发送帧。</li>
<li>当数据从hybird接口发出时，交换机先判断该接口的属性时tag还是untag。如果是tag则直接发送，如果是untag则剥离标签后再发送。</li>
</ul>
</li>
</ol>
<h1 id="Native-Vlan"><a href="#Native-Vlan" class="headerlink" title="Native Vlan"></a>Native Vlan</h1><p>在802.1q中，Native Vlan是不打标签的Vlan。默认的Native Vlan是Vlan1。建议将一个生僻的Vlan设置为Native Vlan。两个互联的交换机的Native Vlan必须一致。否则将会出现流量互串的问题。</p>
<p><img src="/2018/07/17/Basic-Switching/5.png" alt="5"></p>
<p>如上图，首先两边的vlan2互相通信肯定是没有问题的，但是当vlan3，vlan4通信时就会出现问题了。首先假设vlan3的用户发送一个数据，到了左边交换机的trunk接口，发现vlan3时native vlan 不打标签，就直接出去了。到了右边的交换机，由于native vlan为4，右边的交换机会认为这个流量属于vlan4。</p>
<h1 id="私有VLAN（PVLAN）"><a href="#私有VLAN（PVLAN）" class="headerlink" title="私有VLAN（PVLAN）"></a>私有VLAN（PVLAN）</h1><ol>
<li><p>私有VLAN的概念</p>
<ul>
<li>将一个vlan划分为几个单独的vlan，这些vlan都是用同一个ip段</li>
<li>尽管网络设备都处于同一子网中，但是它们属于不同的pvlan，pvlan之间的通信还是需要通过默认网关实现。</li>
<li>每个pvlan包括一个<strong>主vlan</strong>和多个<strong>辅助vlan</strong>。所有辅助vlan都映射到主vlan。</li>
<li>辅助vlan分为<strong>团体vlan</strong>和<strong>隔离vlan</strong>。</li>
<li>相同团体vlan能够互通，但是团体vlan之间必须通过设置SVI或者Vlan-if或者路由器接口才能通信。</li>
<li>相同vlan内部以及隔离vlan之间都是不能互通的，只能与混杂接口通信。</li>
<li><strong>一个主vlan只能有一个isolate vlan</strong></li>
</ul>
</li>
<li><p>PVLAN端口类型</p>
<ul>
<li><p>isolate（隔离）</p>
<p>只能和混杂模式的端口通信</p>
</li>
<li><p>promiscuous（混杂）</p>
<p>可以和任意其他端口通信</p>
</li>
<li><p>community（团体）</p>
<p>只能和混杂端口和属于同一团体的端口通信</p>
</li>
</ul>
</li>
<li><p>配置实例</p>
<p><img src="/2018/07/17/Basic-Switching/6.png" alt="6"></p>
<p>如图，DNS WWW SMTP服务器属于同一子网，两台DNS服务器属于同一个community vlan，所以能够互通。www和smtp属于isolate vlan。因此彼此无法互访。只能和混杂模式的路由器通信。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>Huawei</tag>
        <tag>H3C</tag>
      </tags>
  </entry>
  <entry>
    <title>IPv4 Address</title>
    <url>/2018/07/14/IPv4-Address/</url>
    <content><![CDATA[<h1 id="IPv4地址概述"><a href="#IPv4地址概述" class="headerlink" title="IPv4地址概述"></a>IPv4地址概述</h1><p>IPv4地址长度为32位。包括网络号和主机号。网络号和主机号就像人的姓名一样，人的名字分“姓”和“名”。姓是表明家族的字。姓最初代表有共同血缘、血统、血族关系的种族称号。是一种代表整体的概念。而名则代表这个整体中的某个个体。</p>
<a id="more"></a>
<p>类似的，IPv4地址也有这种概念：网络号部分惟一地标识了一条物理链路或逻辑链路，对于与该链路相连的所有设备来说网络号是一样的，就像人的姓一样。一个家族的人都是相同的姓。而主机号部分惟一地标识了该链路上的具体设备。</p>
<p>有几种方式可以表示IP地址的32位。例如11000000.10101000.00000001.00000001。这个可以用十进制表示成19216811。由此可见，用二进制表示IP地址很麻烦。而全部用十进制表示的话计算起来又很耗时。所以给出一种较好的解决方法。</p>
<p><img src="/2018/07/14/IPv4-Address/1.png" alt="8"></p>
<p>32位地址包含4个字节，每个字节都可以用0～255之间的十进制数表示。而每个十进制用点号分隔。这种写法叫点分十进制。如上所示。</p>
<p>但是要注意的是，路由器不是按照这种方式读取的。更多的时候是按照32位二进制串读取。且IP地址不像其他网络层地址（如Apple Talk和NetWare）那样，网络号和主机号是固定不变的。相反，IP地址的网络号和主机号可以在32位的界线内发生变化。因为TCP/IP从最初设计出来可以灵活地应用于任何网络，从很简单的几个功能发展成一个庞大的协议簇。TCP/IP这种适应性使得IP地址管理变得很困难。</p>
<h1 id="首个八位组字节规则"><a href="#首个八位组字节规则" class="headerlink" title="首个八位组字节规则"></a>首个八位组字节规则</h1><p>对于大，中，小型网络。会有三种地址分类。分别是A.B.C三类地址。这三类的网络号和主机号是规定好了的。这种地址也叫做有类地址。</p>
<ul>
<li>A类地址—— 用于大型网络，第一个八位组是网络号，后三个八位组是主机号。8位的网络号最多可以有256个网络，而每个网络地址后面的主机号可以提供的主机数量为$2^{24}$（IP地址共32位，去掉8个网络位，得出主机位一共有24个）</li>
<li>B类地址—— 用于中型网络。前2个八位组表示网络号，后2个八位组表示主机号。网络号和主机号地址都是$2^{16}$方个。</li>
<li>C类地址—— 前3个8位表示网络号，最后一个8位表示主机号。跟A类地址正好相反。能提供256个主机。可以提供$2^{24}$个网络</li>
</ul>
<p>那么对于ABC三类地址，需要用某一特定方法区分开来。人们规定，A类地址首个八位组的第一位总被设置为0。B类地址首个八位组第一，二位恒为10。C类地址首个八位组前三位恒为110。这么一来ABC三类地址的范围就如下所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">地址类</th>
<th style="text-align:center">范围</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A类</td>
<td style="text-align:center">1～126</td>
</tr>
<tr>
<td style="text-align:center">B类</td>
<td style="text-align:center">128～191</td>
</tr>
<tr>
<td style="text-align:center">C类</td>
<td style="text-align:center">192～223</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注：回环地址（典型的像127.0.0.1）向自己发送流量，发送到这个地址的数据将直接被送回给发送进程，不会离开设备。</p>
</blockquote>
<h1 id="地址掩码"><a href="#地址掩码" class="headerlink" title="地址掩码"></a>地址掩码</h1><p>表示整个链路的地址，非某台特定的主机。可以用IP地址的网络部分来表示。比方说李小狼，可以用李来表示这个人的姓。同样的。主机位部分全为0就可以用来表示整个链路。例如192.168.1.0。这是一个C类地址。主机位部分为最后四个八位组。全为0。如果分配给某个机构，那么这个机构有权决定后8位的使用。</p>
<p>每一台设备和接口都将被分配惟一的、主机号明确的地址。比方说192.168.1.1。不管是路由器还是主机。除了要确定自身的地址以外，还要知道自身所属的网络。例如上面提到的192.168.1.1。它属于192.168.1.0。</p>
<p>不过确认自己所属的网络由掩码来单独完成。掩码也是一个32位的字符串。和IP地址类似的。用点分十进制来表示，但是掩码并不是一种地址。人的姓名之所以能够很快的分辨出来是因为我们人为有规定了，第一个字或者头两个字是姓，后面的都是名。正因为这样我们才能够在对方报上姓名的时候很快分出姓氏和名字。但是IP地址不一样。没有这种规定，所以要依靠掩码来区分网络位（姓）和主机位（名）</p>
<p>对于有类地址来说，人们规定了三种掩码。</p>
<ul>
<li><p>A类地址的掩码为255.0.0.0</p>
</li>
<li><p>B类地址的掩码为255.255.0.0</p>
</li>
<li><p>C类地址的掩码为255.255.255.0</p>
</li>
</ul>
<p>而对于每一位IPv4地址，设备会拿它与地址掩码的对应位进行布尔AND操作。或者叫逻辑与运算。逻辑运算是一种运算方式，跟加减乘除类似，加法得出的结果叫和，乘法得出的叫积。逻辑运算得出的都叫“真值”。对于与运算，真值表如下：</p>
<p><img src="/2018/07/14/IPv4-Address/2.png" alt="2"></p>
<p>那么对于我们熟知的192.168.1.1来说，由上述可知C类地址的掩码为255.255.255.0。如果转换成二进制一一对应起来做与运算就可以算出网络地址。过程如下</p>
<p>11000000.10101000.00000001.00000001</p>
<p>11111111.11111111.11111111.00000000</p>
<p>与运算得</p>
<p>11000000.10101000.00000001.00000000结果为192.168.1.0.</p>
<p>所以为什么要用掩码？到目前为止好像使用首个八位组的规则要更简单一点，也不用进行如此复杂的计算。</p>
<h1 id="子网和子网掩码"><a href="#子网和子网掩码" class="headerlink" title="子网和子网掩码"></a>子网和子网掩码</h1><p>到目前为止的定义中，一个有类地址仅能使用在一个单一网络中；为了建立一个网络，每个数据链路都必须使用不同的地址，以便这些网络可以被惟一地标识。如果每个数据链路都是用一个单独的A，B或者C类地址，那么就算用尽所有的IPv4地址，也只能提供少于1700万个数据链路分配地址。这种方法显然是不切实际的。在之前的内容中，我们知道如果要充分地使用主机地址的空间，那么在数据链路172.21.0.0中设备数目可超过65000个。这显然过于庞大且不好管理，更主要的是在大多数情况下根本没有如此巨大的网络。</p>
<p><img src="/2018/07/14/IPv4-Address/3.png" alt="3"></p>
<p>想让A，B，C类地址实用化的惟一方法是对网络地址进行划分。例如将172.21.0.0再进行划分，变成子网地址。由于IPv4地址的主机部分可以随意使用且IPv4地址的网络号由分配给接口的地址掩码确定，所以如上图所示。分配给网络的B类地址172.21.0.0由5个数据链路将主机和路由器连接起来，每个链路都需要一个网络地址。照目前的情况，172.21.0.0必须分配给其中的一个数据链路，则另外4个链路还需要4个地址。</p>
<p>可以注意到上图的掩码并不是标准的16位的B类地址的掩码。而是被扩展了8位，所以IP地址前24位都是网络位。也就是说，掩码使路由器和主机把读取到的前8位的主机地址作为网络地址的一部分。结果就变成了，主网络地址（172.21.0.0）用于整个网络，而每一个数据链路则变为一个子网（subnet）；一个子网总是属于A，B，C这三种地址空间。</p>
<p>所以现在我们知道，IPv4地址包括三个部分：网络部分，子网部分和主机部分。地址掩码现在变成了子网掩码。地址的前两个八位组仍然是172.21.但是第三个八位组的主机位已经由子网位替代。变化的范围是0～255。在上图的网络中有子网1、2、3、4、5。（172.21.1.0～172.21.5.0）。在单一的B类地址下最多可以有256个子网。对应的掩码也如上图所示。这就是通过向主机位借位用作子网位，子网掩码使得一个单一的网络第一可以用于多个数据链路。</p>
<p>子网掩码有三种写法：</p>
<ul>
<li>点分十进制：255.255.255.0</li>
<li>位计数：172.21.0.0/24</li>
<li>十六进制：0xFFFFFF00</li>
</ul>
<h1 id="子网规划"><a href="#子网规划" class="headerlink" title="子网规划"></a>子网规划</h1><p>网络设计人员需要根据地址空间与网络详细的匹配程度来选择最合理的子网划分方案。在规划子网和子网掩码时，可以使用相同的计算公式计算一个主网地址下可用的子网数以及每个子网内可用的主机数。公式为$2^n-2$。其中n代表子网位数。减2表示减去主机位全0的地址（网络地址。相当于一个人的名字中只有姓。这种地址是不可用的）和全1的地址（广播地址，向这个地址发送消息相当于给该网络中的所有人发送消息，也不可用）。例如。给定一个A类地址10.0.0.0，子网掩码为10.0.0.0/16。意味着有8位是子网空间，也就是可以产生$2^8-2=254$个子网。每个子网可以有$2^{16}-2=65534$个主机地址。要注意的是，如果以8位组为界限，就无法对C类地址进行划分了。</p>
<p><img src="/2018/07/14/IPv4-Address/4.png" alt="4"></p>
<p>如图所示，如果分配C类地址，这里将无法进行划分所以我们要打破8位组界限。子网划分的核心思想是向主机位借位充当网络位。所以在这个网络中共有5条数据链路，所以至少要划分5个子网地址。图上还指明了每个子网需要分配的主机数。其中两个以太网最多需要25个主机地址。所以完整的子网划分最小需求是5个子网，每个子网至少要25个主机地址。</p>
<p>之后使用公式$2^n-2$ 可以计算出，3个子网位和5个主机位即可满足需求：$2^3-2=6$,$2^5-2=30$ 带有3位子网位的C类地址掩码可以用点分十进制表示为255.255.255.224.</p>
<p>这边直接给出比较简单的计算方式</p>
<ul>
<li>你选择的子网掩码将会产生$2^x$个子网，x代表掩码位数。举个例子，192.168.1.1/24借2位。则x=2 会产生4个子网</li>
<li>每个子网有$2^y-2$个主机，y为主机位的长度。还是按照上面的例子。如果借两位，就变成了192.168.1.1/26.这样一来主机位的长度就是$32-26=6$位。则每个子网有$2^6-2=30$个主机。</li>
<li>有效子网，或者说每个网络的范围是256-10进制的子网掩码。得到的叫块大小(Block Size)。这个很奇妙。按照192.168.1.1/26来说，将掩码转换成十进制就是255.255.255.192.这样拿$256-192=64$.也就是说，每个网络的块大小是64。所以第一个网络的范围是192.168.1.0～192.168.1.63.第二个就是192.168.1.64～192.168.1.127。以此类推。</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>Huawei</tag>
        <tag>H3C</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI and TCP/IP protocol stacks</title>
    <url>/2018/07/13/OSI-and-TCP-IP/</url>
    <content><![CDATA[<h1 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h1><h2 id="为何会有OSI参考模型的提出"><a href="#为何会有OSI参考模型的提出" class="headerlink" title="为何会有OSI参考模型的提出"></a>为何会有OSI参考模型的提出</h2><p>很久以前，各大硬件厂商如HP，IBM等都根据自己的协议生产了不同的软硬件，这就导致了设备间相互通讯非常困难。这是一个什么概念？</p>
<p>举个例子，以前的中国，阎锡山为了做山西土皇帝，山高皇帝远，在自己势力范围内建造窄轨铁路，蒋介石国军的火车无法进入山西境内，无法便利调动军队、物资，实现一人独大的军阀割据格局。以互联网的眼光看，如果标准轨道铁路网是一个互联网，那阎锡山的窄轨铁路就是一个自我封闭的局域网，为了打破这种非标准化的私有标准，需要制定一个大家都遵守的国际标准。</p>
<a id="more"></a>
<p>于是，国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合开发了这个七层的参考模型。初衷是为了让各大厂商之间的设备遵循这个规定，生产出的设备可以畅通无阻地互相通信。模型层次结构如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名字</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Application(应用层)</td>
<td style="text-align:center">应用程序接入网络的接口</td>
</tr>
<tr>
<td style="text-align:center">Presentation(表示层)</td>
<td style="text-align:center">数据的表示</td>
</tr>
<tr>
<td style="text-align:center">Session(会话层)</td>
<td style="text-align:center">管理及区分会话</td>
</tr>
<tr>
<td style="text-align:center">Transport(传输层)</td>
<td style="text-align:center">提供端到端的连接</td>
</tr>
<tr>
<td style="text-align:center">Network(网络层)</td>
<td style="text-align:center">数据的分发</td>
</tr>
<tr>
<td style="text-align:center">Data Link(数据链路层)</td>
<td style="text-align:center">接入媒体</td>
</tr>
<tr>
<td style="text-align:center">Physical(物理层)</td>
<td style="text-align:center">二进制的传输</td>
</tr>
</tbody>
</table>
</div>
<h2 id="网络分层的目的以及每一层的作用"><a href="#网络分层的目的以及每一层的作用" class="headerlink" title="网络分层的目的以及每一层的作用"></a>网络分层的目的以及每一层的作用</h2><p>为了能把一个复杂的问题简单化，OSI参考模型讲数据的传输给分成了七层，每一层都有自己的任务。</p>
<p>以上的列表是官方的定义。那么按照我自己的理解再说一遍。</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>首先还是引用一段官方的定义</p>
<blockquote>
<p>Network Processes to Applications</p>
<ul>
<li>Provides network services to application processes (such as electronic mail , file transfer, and terminal emulation)</li>
<li>Provides user authentication</li>
</ul>
</blockquote>
<p>这里说的是提供应用程序进程的网络接口。首先要理解接口的定义。这里的接口不是指路由器交换机这种设备的物理接口，而是指逻辑上的。举个例子。如果你使用浏览器，浏览器上会有标签页，刷新，收藏等按钮。如果你想打开一个新标签页，就可以点击加号。</p>
<p><img src="/2018/07/13/OSI-and-TCP-IP/1.png" alt="1"></p>
<p>这种叫UI(User Interface)用户接口。意思是用户和机器交互的接口。如果我想要做某个操作，我需要电脑能够给我提供操作的空间，例如我想打开新的标签页，我就需要浏览器这个程序上有个加号。同样的。我的应用程序想要通过网络传输一些数据，也是需要类似的“接口”的。这个接口由应用层提供。典型的例如HTTP就是应用层协议。它可以让网页的内容在服务器和客户端之间传输。</p>
<h3 id="表示层"><a href="#表示层" class="headerlink" title="表示层"></a>表示层</h3><p>官方定义如下</p>
<blockquote>
<p>Data Representation</p>
<ul>
<li>Ensures that data is readable by receiving system</li>
<li>Formats data</li>
<li>Negotiates data transfer syntax for application layer</li>
</ul>
</blockquote>
<p>这里表示层的主要作用是 协商数据传输时使用的编码。我们还是拿HTTP这种常用的协议来举例子。在浏览网页时，我们可以查看网页上的各种信息，像图片，文字，视频等。那么在传输时，浏览器是如何知道图片以及文字的表达形式呢，传过来的那么多信息，程序是如何知道传的是图片还是文字还是视频呢？这就依靠我们表示层给出的信息来识别。我们一起来看一下网页的源代码。随便找一个</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>搭建Windows环境PS4直播服务器+支持OBS - PS4综合讨论区 - A9VG电玩部落论坛<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"http://bbs.a9vg.com/thread-4199530-1-1.html"</span> <span class="attr">rel</span>=<span class="string">"canonical"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"keywords"</span> <span class="attr">content</span>=<span class="string">"搭建Windows环境PS4直播服务器+支持OBS"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">" 搭建Windows环境PS4直播服务器+支持OBS ,A9VG电玩部落论坛"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"MSSmartTagsPreventParsing"</span> <span class="attr">content</span>=<span class="string">"True"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"MSThemeCompatible"</span> <span class="attr">content</span>=<span class="string">"Yes"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://bbs.a9vg.com/"</span> /&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"data/cache/style_2_common.css?7ru"</span> /&gt;</span><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"data/cache/style_2_forum_viewthread.css?7ru"</span> /&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="actionscript"><span class="keyword">var</span> STYLEID = <span class="string">'2'</span>, STATICURL = <span class="string">'static/'</span>, IMGDIR = <span class="string">'static/image/common'</span>, VERHASH = <span class="string">'7ru'</span>, charset = <span class="string">'utf-8'</span>, discuz_uid = <span class="string">'0'</span>, cookiepre = <span class="string">'WxSS_a648_'</span>, cookiedomain = <span class="string">'.a9vg.com'</span>, cookiepath = <span class="string">'/'</span>, showusercard = <span class="string">'0'</span>, attackevasive = <span class="string">'0'</span>, disallowfloat = <span class="string">'login|newthread'</span>, creditnotice = <span class="string">''</span>, defaultstyle = <span class="string">''</span>, REPORTURL = <span class="string">'aHR0cDovL2Jicy5hOXZnLmNvbS90aHJlYWQtNDE5OTUzMC0xLTEuaHRtbA=='</span>, SITEURL = <span class="string">'http://bbs.a9vg.com/'</span>, JSPATH = <span class="string">'static/js/'</span>;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>后面的就省略了。毕竟我们不是学习HTML语言。</p>
<p>这边可以在第五行看到这样一段代码:<code>charset=utf-8</code></p>
<p>简单介绍一下UTF-8。这是一种字符的编码方式，它支持英文，简中，繁重，日文韩文等不同国家的语言，使他们能够正常在网页中显示。所以浏览器才能正常显示中文信息。这都是表示层的功劳。</p>
<h3 id="会话层"><a href="#会话层" class="headerlink" title="会话层"></a>会话层</h3><p>官方定义如下：</p>
<blockquote>
<p>Interhost Communication</p>
<ul>
<li>Establishes,manages,ande terminates sessions between applications</li>
</ul>
</blockquote>
<p>会话层的作用很简单，在程序间建立，管理和结束会话。何为会话呢？我打开QQ和朋友聊天这是一种会话，聊天的同时我还在使用浏览器看视频，这是另一种会话。这两种会话的流量都是通过网络传输过来的，那么如何保证聊天的流量不会发送给浏览器，视频的流量又不会发给QQ呢？这一般是操作系统层面去实现的事情。每个应用程序都有属于自己的PID(进程号)这些号码在系统中是唯一的。所以系统根据进程号来区分不同的会话。</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>官方定义如下:</p>
<blockquote>
<p>End to End Connections</p>
<ul>
<li>Provides reliability through fault detection and recovery information flow contorl</li>
<li>Ensures data transport reliability</li>
<li>Handles transportation issues between hosts</li>
<li>Establishes,maintains,and terminates virtual circuits</li>
</ul>
</blockquote>
<p>主要是提供端到端的通信。可靠的传输以及流控。上面的三层我们一般也统称应用层。因为都是应用程序或者操作系统帮我们完成的，跟网络没有什么太大的关系。而传输层起到一个承上启下的作用。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>官方定义如下:</p>
<blockquote>
<p>Data Delivery</p>
<ul>
<li>Routes data packets</li>
<li>Selects best path to deliver data</li>
<li>Provides logical addressing and path selection</li>
</ul>
</blockquote>
<p>网络层主要的作用是路由数据包，选择一条最佳的路径以及提供逻辑地址去选路。典型的像IP地址就是一种逻辑地址。是人为规定的。可以随意更改。</p>
<h3 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h3><p>官方定义如下:</p>
<blockquote>
<p>Access to Media</p>
<ul>
<li>Defines how data is formatted for transmission and how access to network is controlled</li>
<li>Provides error detection</li>
</ul>
</blockquote>
<p>这里不太好理解 给出的定义是接入媒体，可以把这里的Media理解为硬件。接入硬件。需要提供一个接入硬件的方式。例如在以太网中，数据链路层使用MAC地址，而MAC地址是每个以太网设备在被制造出来时都会有的一个硬件地址。这便是接入硬件的意义。因为最终数据还是要发送到设备上的某个接口的。光靠三层的逻辑地址是不够的。</p>
<h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>官方定义如下:</p>
<blockquote>
<p>Binary Transmission</p>
<ul>
<li>Defines the electrical,mechanical,procedural,and functional specifications for activating,maintaing,and deactivating the physical link.</li>
</ul>
</blockquote>
<p>这里物理层主要是定义电器特性，比方说线速，电压等等物理特性。</p>
<h2 id="OSI参考模型总结"><a href="#OSI参考模型总结" class="headerlink" title="OSI参考模型总结"></a>OSI参考模型总结</h2><p>以上就是OSI参考模型的全部总结，总的来说它将网络通信这个复杂的过程通过分层给模块化了。每一层都有自己的任务。就像寄快递。</p>
<p>先将要寄的东西打包，这是应用层的数据。那么现在到了传输层，主要是提供一种传输方式。类似我们在寄快递的时候选择空运或者陆运。空运比较贵嘛，但是快，陆运便宜 但是慢。这边只是一个比喻，实际肯定没有这么简单。传输层主要会使用TCP和UDP两种协议。关于这个会在TCP/IP中详细谈到。那么在选择完了传输方式 例如决定使用TCP之后，就需要填写发件人（源地址）和收件人（目标地址）了。填写完毕以后交给快递公司，他们会把快递由一个转运中心发往另一个转运中心，并不是直接从源发往目标。这里的转运中心其实就到二层了。在传输过程中，二层地址，例如以太网中的MAC地址，是会不停变化的，就像一个快递由上海发往武汉，会先到上海的某个集散中心，然后发往武汉，然后又在武汉的集散中心转几圈，最后发往离目标最近的快递点，然后才开始配送，最终送到收件人手上。</p>
<h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h1><blockquote>
<p>1983年1月1日，在<a href="https://zh.wikipedia.org/wiki/%E5%9B%A0%E7%89%B9%E7%BD%91" target="_blank" rel="noopener">因特网</a>的前身（ARPA网）中，TCP/IP取代旧的<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">网络控制协议</a>（NCP，Network Control Protocol），从而成为今天的互联网的基石。最早的TCP/IP由<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E9%A1%BF%C2%B7%E7%91%9F%E5%A4%AB" target="_blank" rel="noopener">文顿·瑟夫</a>和<a href="https://zh.wikipedia.org/wiki/%E7%BD%97%E4%BC%AF%E7%89%B9%C2%B7%E5%8D%A1%E6%81%A9" target="_blank" rel="noopener">罗伯特·卡恩</a>两位开发，慢慢地通过竞争战胜其他一些网络协议的方案，比如<a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87" target="_blank" rel="noopener">国际标准化组织</a><a href="https://zh.wikipedia.org/wiki/ISO" target="_blank" rel="noopener">ISO</a>的<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型</a>。TCP/IP的蓬勃发展发生在1990年代中期。当时一些重要而可靠的工具的出世，例如页面描述语言<a href="https://zh.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>和浏览器<a href="https://zh.wikipedia.org/wiki/Mosaic" target="_blank" rel="noopener">Mosaic</a>，促成了互联网应用的飞速发展。 随着互联网的发展，目前流行的<a href="https://zh.wikipedia.org/wiki/IPv4" target="_blank" rel="noopener">IPv4</a>协议（网际协议版本四）已经接近它的功能上限。IPv4最致命的两个缺陷在于：</p>
<ul>
<li><p>地址只有32位，<a href="https://zh.wikipedia.org/wiki/IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">IP地址</a>空间有限；</p>
</li>
<li><p>不支持服务质量（<a href="https://zh.wikipedia.org/wiki/QoS" target="_blank" rel="noopener">Quality of Service</a>，QoS）的想法，无法管理带宽和优先级，故而不能很好的支持现今越来越多实时的语音和视频应用。因此<a href="https://zh.wikipedia.org/wiki/IPv6" target="_blank" rel="noopener">IPv6</a>（网际协议版本六）浮出水面，用以取代IPv4。</p>
</li>
<li><p>TCP/IP成功的另一个因素在于对为数众多的低层协议的支持。这些低层协议对应<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">OSI模型</a>中的第一层（物理层）和第二层（数据链路层）。每层的所有协议几乎都有一半数量支持TCP/IP，例如：<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="noopener">以太网</a>（Ethernet）、<a href="https://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF" target="_blank" rel="noopener">令牌环</a>（Token Ring）、<a href="https://zh.wikipedia.org/wiki/%E5%85%89%E7%BA%A4%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">光纤数据分布接口</a>（FDDI）、<a href="https://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">点对点协议</a>（PPP）、<a href="https://zh.wikipedia.org/wiki/X.25" target="_blank" rel="noopener">X.25</a>、<a href="https://zh.wikipedia.org/wiki/%E5%B8%A7%E4%B8%AD%E7%BB%A7" target="_blank" rel="noopener">帧中继</a>（Frame Relay）、<a href="https://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">ATM</a>、<a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E6%AD%A5%E5%85%89%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">Sonet</a>、<a href="https://zh.wikipedia.org/wiki/SDH" target="_blank" rel="noopener">SDH</a>等。</p>
<p>​                                                ——————摘抄自<a href="https://zh.wikipedia.org/wiki/TCP/IP协议族" target="_blank" rel="noopener">维基百科TCP/IP协议族</a></p>
</li>
</ul>
</blockquote>
<p>TCP/IPv4协议族是现在互联网仍在使用的协议族，尽管IPv4的问题非常多，但是由于IPv6普及的进程较缓慢，所以IPv4现在仍是互联网主要使用的协议。其协议族模型如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">典型应用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层(Application Layer)</td>
<td style="text-align:center">HTTP,FTP,DNS</td>
</tr>
<tr>
<td style="text-align:center">传输层(Transport Layer)</td>
<td style="text-align:center">TCP,UDP,RTP,SCTP</td>
</tr>
<tr>
<td style="text-align:center">网络层(Internet Layer)</td>
<td style="text-align:center">IP</td>
</tr>
<tr>
<td style="text-align:center">网络接口层(Link Layer)</td>
<td style="text-align:center">以太网,Wi-Fi,MPLS</td>
</tr>
</tbody>
</table>
</div>
<h2 id="应用层-1"><a href="#应用层-1" class="headerlink" title="应用层"></a>应用层</h2><p>这一层包括所有和应用程序协同工作的且利用网络交换程序专用数据的协议。这一层的处理过程是特有的。就是数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。</p>
<p>一些特定的程序被认为是运行在这一层。它们提供的服务可以直接支持用户的应用，例如HTTP，DNS，FTP，SMTP等。一旦从应用程序来的数据被编码成一个标准的应用层协议，它将被传送到IP栈的下一层。</p>
<h2 id="传输层-1"><a href="#传输层-1" class="headerlink" title="传输层"></a>传输层</h2><p>传输层协议能够解决端到端的可靠性问题，例如<strong>“数据是否已经到达目的地?”</strong>这样的问题和<strong>“数据是否按正确的顺序到达？”</strong>这样的问题。</p>
<ul>
<li>TCP（IP协议号6）是一种<strong>可靠，面向连接</strong>的传输协议。它提供一种可靠的字节流保证数据完整、无损并且按顺序到达。TCP尽量连续不断地测试网络的负载并且控制发送数据的速度以避免网络过载。另外，TCP试图将数据按照规定的顺序发送。这是它与UDP不同之处，这在实时数据流或者路由丢失率应用的时候可能成为一个缺陷。</li>
</ul>
<ul>
<li>UDP（IP协议号17）是一个无连接的数据报协议。它是一个“尽力传递”（best effort）或者说“不可靠”协议——不是因为它特别不可靠，而是因为它不检查数据包是否已经到达目的地，并且不保证它们按顺序到达。如果一个应用程序需要这些特性，那它必须自行检测和判断，或者使用TCP协议。 UDP的典型性应用是如流媒体（音频和视频等）这样按时到达比可靠性更重要的应用，或者如DNS查找这样的简单查询／响应应用，如果创建可靠的连结所作的额外工作将是不成比例地大。</li>
</ul>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><blockquote>
<p>TCP提供了一条看似点到点的连接，虽然实际上这条连接并不存在。TCP利用网络层可以提供无连接的，尽力而为转发的服务。这就像寄邮件，一叠信件一旦交给邮递员之后，谁也不能保证信件将按照原先叠放的顺序依次送达，也不能保证这些信件都能在同一天送到，甚至都不能保证全部送到。快递员只能承诺尽最大努力邮寄这些信件。</p>
<p>同样的，网络层不保证所有数据包都是使用相同的路径，因而也不保证数据包到达时仍旧保持发送时的顺序和间隔或者全部到达。</p>
<p>​                        ——————摘抄自TCP/IP协议卷一</p>
</blockquote>
<p>想象一下我们平时的打电话这个操作，电话呼叫是一个面向连接的服务。电话铃响后如果接通了代表通信双方互相建立了连接，然后才会开始交谈，如果没有接通，则不会进行数据的传送。同样的。TCP首先要建立连接，然后是传送数据。当数据传输完毕后要断开连接（挂电话）。</p>
<p>那么在无连接的服务上，TCP使用了三种基础的机制实现面向连接的服务</p>
<ul>
<li>使用序列号对数据包进行标记，以便TCP接受服务在向目的应用传递数据之前修正错序的数据包排序</li>
<li>TCP使用确认，校验和定时器系统提供可靠性。当接收者按照顺序识别出来数据包未能到达（例如收到的序列号为13456，则序列为2的数据丢失）或发生错误时，接收者将通知发送者，或者接收者在特定的时间内没有发送确认信息，那么发送者就认为在发送结束后数据包没有到达接受的地方。在这两种情况下，发送者都会考虑重传数据包。</li>
<li>TCP使用窗口机制调整数据包的流量；窗口机制可以减少因为接收方缓冲区满而造成的数据包丢失可能性。</li>
</ul>
<p>TCP在应用层数据上附加了一个报头，报头里包含了刚才提到的序列号，确认号等能够保证面向连接机制的一些关键信息。大部分协议都是在下层数据前面添加报头实现自己的功能的。TCP报头被封装在IP数据包内。下图为TCP报头。</p>
<p><img src="/2018/07/13/OSI-and-TCP-IP/2.png" alt="2"></p>
<p>下图为实际抓包得出的数据包（部分）</p>
<p><img src="/2018/07/13/OSI-and-TCP-IP/3.png" alt="3"></p>
<p>其中IP层不是我们关心的。我们只用知道TCP在IP层的协议号为6就行。协议号用来标识上层使用的是哪种协议，此处是TCP。</p>
<p>IP层下面便是TCP的报头数据了。从简要信息里我们可以看到几个参数的名字，例如Src Port，Dst Port ，Seq，Ack等。那么接下来一个个解释每个参数的意义。</p>
<ul>
<li>源端口(Source Port)和目标端口(Destination Port)</li>
</ul>
<p>  字段长度各为16位。所以源端口和目标端口取值范围则是2的16次方=65536</p>
<p>  由0开始，所以端口号的范围是0～65535。端口号指定了源和目标应用程序。也就是说可以用端口号来区分同是使用TCP的两个不同应用程序间的流量。应用程序的端口号+应用程序所在的主机IP地址统称为套接字（socket）。在网络上套接字惟一地标识了每一个应用程序。</p>
<ul>
<li>序列号(Sequence Number)</li>
</ul>
<p>  字段长度为32位。序列号用来确定数据在数据流中所在的位置，就像刚才说的一叠信件，发出去的时候信件的摆放顺序是1234567。如何才能保证发出去的信件和收到的信件顺序一样呢？序列号就是用来实现这个功能的。例如。如果这封信的序列号是1，这封信一共有1000个字，那么下一封信的序列号则为<code>1+1000+1=1002</code>。</p>
<ul>
<li>确认号(Acknowledgement Number)</li>
</ul>
<p>  字段长度为32位。序列号用来确定发送方发送的数据在数据流中的位置。一叠信件被收到以后，使用确认号来确定收件人下次希望接收的信件的序列号。如果发件人收到的确认号与他下一次准备发送（或者已经发送）的序列号不一样。那么主机将收到丢失的数据包。</p>
<ul>
<li>报头长度(Header Length)</li>
</ul>
<p>  又叫数据偏移量，长度是4位，它指定了以32位字节为单位的报头长度。因为TCP中有些字段是可选的导致长度不一致。所以这一字段标记出数据的起点是很有必要的。</p>
<ul>
<li>保留(Reserved)</li>
</ul>
<p>  字段长度为6位 通常为0。保留用。没有什么特殊意义。</p>
<ul>
<li>标记(Flags)</li>
</ul>
<p>  包括8个1位的标记，用于流控和连接控制，它们从左到右分别是：</p>
<p>  拥塞窗口减少(Congestion Windows Reduced,简称CWR)、ECN-Echo(ECE)、紧急(URG)、确认(ACK)、弹出(PSH)、复位(RST)、同步(SYN)、结束(FIN)。如下图所示。</p>
<p>  <img src="/2018/07/13/OSI-and-TCP-IP/4.png" alt="4"></p>
<p>  至于每一位的作用这边不需要太过深究。</p>
<ul>
<li>窗口大小(Window Size)</li>
</ul>
<p>  窗口大小主要用于流控。即流量控制。不妨假设，发送方发送数据很快，而接收方接受数据很慢。在这种情况下，为了不保证数据丢失，就需要流量控制。协调好通信双方的工作节奏。所谓窗口，可以理解成接收端所能提供的缓冲区大小。TCP利用一个滑动的窗口来告诉发送端对它所发送的数据能提供多大的缓冲区。由于窗口由16位bit所定义，所以接收端TCP 能最大提供65535个字节的缓冲。由此，可以利用窗口大小和第一个数据的序列号计算出最大可接收的数据序列号。</p>
<p>  <img src="/2018/07/13/OSI-and-TCP-IP/5.png" alt="5"></p>
<p>​    如上图所示，其实TCP在整个发送过程中，也在度量当前的网络状态，目的是为了维持一                个健康稳定的发送过程。发送的数据可以分为以下几类：</p>
<ul>
<li>已经发送的并且对端也确认了(Sent/ACKed)——发送窗外，缓冲区外</li>
<li>已经发送但是对端还未确认的(Unsent/Inside)——发送窗内 缓冲区内</li>
<li>要发送的但是还未发送的(Unsent/Inside)——发送窗内 缓冲区内</li>
<li>未发送且暂不发送的(Unsent/Outside)——发送窗外 缓冲区外</li>
</ul>
<p>​    TCP窗口就是这样逐渐滑动，发送新的数据。滑动的依据便是发送数据已经收到ACK，确认对端收到，才继续滑动窗口发送新的数据。可以看出来窗口的大小对于吞吐量有着重要的影响。</p>
<ul>
<li>校验和(Checksum)</li>
</ul>
<p>​    字段长度为16位，它包括报头和被封装的数据。校验和可以做错误检测</p>
<ul>
<li>紧急指针(Urgent Pointer)</li>
</ul>
<p>​    这个字段仅当URG标记置位时（就是Flag中的URG=1的时候）才被使用。这个16位数倍添加到序列号上用于指明紧急数据的结束。</p>
<ul>
<li>可选项(Options)</li>
</ul>
<p>​    字段用于指明TCP的发送进程要求的选项。最常用的便是最大段长度。用于通知接收方，表明发送者愿意接受的最大段长度。为了保证报头的长度时32个八位组的整数倍，所以用0填充这个字段剩余的部分。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>​    UDP提供了一种无连接、尽力而为的数据包转发服务。UDP的优点是不用花时间建立连接。直接发送数据。用UDP代替TCP，可以使发送小数据量的应用取得更好的性能优势。UDP报头非常简单。如下图</p>
<p><img src="/2018/07/13/OSI-and-TCP-IP/6.png" alt="6"></p>
<p>抓包结果如下</p>
<p><img src="/2018/07/13/OSI-and-TCP-IP/7.png" alt="7"></p>
<p>以上便是关于TCP IP中应用和传输层的内容，关于网络层以及下面的链路层内容，会在下面提到。</p>
<h2 id="网络层-1"><a href="#网络层-1" class="headerlink" title="网络层"></a>网络层</h2>]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>Huawei</tag>
        <tag>H3C</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF LSDB</title>
    <url>/2018/06/06/CCNPDAY7/</url>
    <content><![CDATA[<h1 id="OSPF的链路状态数据库（LSDB）"><a href="#OSPF的链路状态数据库（LSDB）" class="headerlink" title="OSPF的链路状态数据库（LSDB）"></a>OSPF的链路状态数据库（LSDB）</h1><p>一台路由器中所有的有效LSA都被存放在它的链路状态数据库中。正确的LSA可以描述一个OSPF区域网络拓扑的结构。因为一个区域中的每一台路由器都要利用这个数据库的信息来计算它自己的最短路径树，因此同一区域的数据库的统一性对于正确的路由器选择就变得十分重要。</p>
<a id="more"></a>
<p>查看OSPF链路状态数据库：</p>
<p><code>Show ip ospf database</code></p>
<p><img src="/2018/06/06/CCNPDAY7/fdb0c84b84ddc86c7f45be3985e48f6c.png" alt=""></p>
<p>图 1‑1 OSPF数据库信息截图</p>
<p>如前面提到的序列号、老化时间，当LSA在传递过程中按照转发延迟增加老化时间，当保存在LSDB中时，老化时间是逐渐增大的，当LSA的老化时间到达了1小时，那么它们将从OSPF域中被清除。这就意味着，在这里必须有一种机制来防止正常的LSA到达最大生存时间。这种机制就是链路状态刷新（link<br>state<br>refresh）。每隔30min始发这条LSA的路由器将泛洪扩散这条LSA的一个新拷贝，并将它的序列号增加1，老化时间设置为0。其他OSPF路由器一旦收到这个新拷贝，就会用这个新拷贝替换该LSA原来的拷贝，并重新计算老化时间。</p>
<h1 id="LSA的类型"><a href="#LSA的类型" class="headerlink" title="LSA的类型"></a>LSA的类型</h1><p>由于OSPF定义了多种路由器的类型，因而定义多种LSA的类型也是有必要的。</p>
<p>类型1：路由器LSA（Router LSA）</p>
<p>类型2：网络LSA（Network LSA）</p>
<p>类型3：网络汇总LSA（Network summary LSA）</p>
<p>类型4：ASBR汇总LSA（ASBR summary LSA）</p>
<p>类型5：AS外部LSA（External LSA）</p>
<p>类型6：组成员LSA</p>
<p>类型7：NSSA外部LSA（NSSA External LSA）</p>
<p>类型8：外部属性LSA</p>
<p>类型9：Opaque Link-Local LSA（链路本地范围）</p>
<p>类型10：Opaque Area LSA（本地区域范围）</p>
<p>类型11：Opaque AS LSA（AS范围）</p>
<h2 id="路由器LSA"><a href="#路由器LSA" class="headerlink" title="路由器LSA"></a>路由器LSA</h2><p>每一台路由器都会产生路由器LSA通告。这个最基本的LSA通告列出了路由器所有的链路或接口，并指明了它们的状态和沿每条链路方向出站的开销，以及该链路上所有已知的OSPF邻居。</p>
<p>路由器LSA在整个区域内部泛洪。</p>
<p><code>Show ip ospf database router</code>查看：</p>
<p><img src="/2018/06/06/CCNPDAY7/952334caa50ae4e3efe7a19b97aaccca.png" alt=""></p>
<p>图 2‑1 OSPF路由器LSA信息</p>
<h3 id="路由器LSA详细描述"><a href="#路由器LSA详细描述" class="headerlink" title="路由器LSA详细描述"></a>路由器LSA详细描述</h3><p>表 2‑1 1类LSA详细描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>LSA内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>OSPF Router with ID（1.1.1.1）</td>
<td>这台路由器的router-id</td>
</tr>
<tr>
<td>2</td>
<td>Router Link States（area 0）</td>
<td>这是一条1类LSA，属于区域0</td>
</tr>
<tr>
<td>3</td>
<td>LS age：1683</td>
<td>LSA老化时间</td>
</tr>
<tr>
<td>4</td>
<td>LS type：Router Links</td>
<td>LSA类型为路由器LSA</td>
</tr>
<tr>
<td>5</td>
<td>Link State ID：1.1.1.1</td>
<td>链路状态通告的名称为1.1.1.1（自己的router-id）</td>
</tr>
<tr>
<td>6</td>
<td>Advertising Router</td>
<td>通告路由器为1.1.1.1（自己的router-id）</td>
</tr>
<tr>
<td>7</td>
<td>LS Seq Number：80000004</td>
<td>LSA序列号</td>
</tr>
<tr>
<td>8</td>
<td>Chesksum：0xD71C</td>
<td>校验和</td>
</tr>
<tr>
<td>9</td>
<td>Length：48</td>
<td>LSA长度</td>
</tr>
<tr>
<td>10</td>
<td>Number of Links：2</td>
<td>链路的数量</td>
</tr>
</tbody>
</table>
</div>
<h2 id="网络LSA"><a href="#网络LSA" class="headerlink" title="网络LSA"></a>网络LSA</h2><p>每一个多路访问网络中的指定路由器（DR）将会产生网络LSA通告。网络LSA在同一区域内泛洪。</p>
<p><code>Show ip ospf database network</code> 查看：</p>
<p><img src="/2018/06/06/CCNPDAY7/12090e5dd7b032d3b1ae43091891a47d.png" alt=""></p>
<p>图 2‑2 OSPF网络LSA信息</p>
<h3 id="网络LSA详细描述"><a href="#网络LSA详细描述" class="headerlink" title="网络LSA详细描述"></a>网络LSA详细描述</h3><p>表 2‑2 OSPF网络LSA详细描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>LSA内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>LS type：Network Links</td>
<td>LSA类型为网络LSA</td>
</tr>
<tr>
<td>2</td>
<td>Link State ID：12.1.1.2</td>
<td>链路状态通告的名称为12.1.1.2（DR路由器的接口ip地址）</td>
</tr>
<tr>
<td>3</td>
<td>Advertising Router</td>
<td>通告路由器为2.2.2.2（DR路由器的router-id）</td>
</tr>
<tr>
<td>4</td>
<td>LS Seq Number：80000003</td>
<td>LSA序列号</td>
</tr>
<tr>
<td>5</td>
<td>Chesksum：0xE06</td>
<td>校验和</td>
</tr>
<tr>
<td>6</td>
<td>Length：32</td>
<td>LSA长度</td>
</tr>
<tr>
<td>7</td>
<td>Network Mask：/24</td>
<td>网络掩码长度</td>
</tr>
<tr>
<td>8</td>
<td>Attached Router：1.1.1.1</td>
<td>该网络连接的所有路由器的Router-ID</td>
</tr>
<tr>
<td></td>
<td>Attached Router：2.2.2.2</td>
</tr>
</tbody>
</table>
</div>
<h2 id="网络汇总LSA"><a href="#网络汇总LSA" class="headerlink" title="网络汇总LSA"></a>网络汇总LSA</h2><p>由区域边界路由器（ABR）始发。ABR路由器将发送网络汇总LSA到一个区域，用来通告该区域外部其他区域的目的地址。</p>
<p><code>Show ip ospf database summary</code> 查看</p>
<p><img src="/2018/06/06/CCNPDAY7/051124e241e9020dcb5ca360a1801cf1.png" alt=""></p>
<p>图 2‑3 OSPF网络汇总LSA信息</p>
<h3 id="网络汇总LSA详细描述"><a href="#网络汇总LSA详细描述" class="headerlink" title="网络汇总LSA详细描述"></a>网络汇总LSA详细描述</h3><p>表 2‑3 OSPF网络汇总LSA详细描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>LSA内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>LS type：Summary Links（Network）</td>
<td>LSA类型为网络汇总LSA</td>
</tr>
<tr>
<td>2</td>
<td>Link State ID：23.1.1.0（Summary Network Number）</td>
<td>链路状态通告的名称为23.1.1.0（汇总网络号）</td>
</tr>
<tr>
<td>3</td>
<td>Advertising Router</td>
<td>通告路由器为2.2.2.2（ABR路由器的router-id）</td>
</tr>
<tr>
<td>4</td>
<td>LS Seq Number：80000002</td>
<td>LSA序列号</td>
</tr>
<tr>
<td>5</td>
<td>Chesksum：0x1208</td>
<td>校验和</td>
</tr>
<tr>
<td>6</td>
<td>Length：28</td>
<td>LSA长度</td>
</tr>
<tr>
<td>7</td>
<td>Network Mask：/24</td>
<td>网络掩码长度</td>
</tr>
<tr>
<td>8</td>
<td>Metric：1</td>
<td>该路由的开销</td>
</tr>
</tbody>
</table>
</div>
<h2 id="ASBR汇总LSA"><a href="#ASBR汇总LSA" class="headerlink" title="ASBR汇总LSA"></a>ASBR汇总LSA</h2><p>ASBR汇总LSA也是由ABR路由器始发的。用于在网络中通告ASBR所在的位置。</p>
<p><code>Show ip ospf database asbr-summary</code> 查看</p>
<p><img src="/2018/06/06/CCNPDAY7/068fd087945ca70f3553e0c7f55e82e1.png" alt=""></p>
<p>图 2‑4 OSPF ASBR汇总LSA信息</p>
<h3 id="ASBR汇总LSA详细描述"><a href="#ASBR汇总LSA详细描述" class="headerlink" title="ASBR汇总LSA详细描述"></a>ASBR汇总LSA详细描述</h3><p>表 2‑4 ASBR汇总LSA详细描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>LSA内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>LS type：Summary Links（AS Boundary Router）</td>
<td>LSA类型为ASBR汇总LSA</td>
</tr>
<tr>
<td>2</td>
<td>Link State ID：3.3.3.3（AS Boundary Router Address）</td>
<td>链路状态通告的名称为3.3.3.3（ASBR路由器Router-ID）</td>
</tr>
<tr>
<td>3</td>
<td>Advertising Router</td>
<td>通告路由器为2.2.2.2（ABR路由器的router-id）</td>
</tr>
<tr>
<td>4</td>
<td>LS Seq Number：80000001</td>
<td>LSA序列号</td>
</tr>
<tr>
<td>5</td>
<td>Chesksum：0xBE68</td>
<td>校验和</td>
</tr>
<tr>
<td>6</td>
<td>Length：28</td>
<td>LSA长度</td>
</tr>
<tr>
<td>7</td>
<td>Network Mask：/0</td>
<td>没有掩码</td>
</tr>
<tr>
<td>8</td>
<td>Metric：1</td>
<td>该路由的开销</td>
</tr>
</tbody>
</table>
</div>
<h2 id="AS外部LSA"><a href="#AS外部LSA" class="headerlink" title="AS外部LSA"></a>AS外部LSA</h2><p>始发于ASBR，用来通告ospf域外的目的网络，外部LSA是唯一不与区域相关联的LSA通告，在整个OSPF域内泛洪扩散。</p>
<p><code>Show ip ospf database external</code> 查看</p>
<p><img src="/2018/06/06/CCNPDAY7/e5ccf0994a06ab45b26d3bcd34d9b681.png" alt=""></p>
<p>图 2‑5 OSPF外部LSA信息</p>
<h3 id="外部LSA详细描述"><a href="#外部LSA详细描述" class="headerlink" title="外部LSA详细描述"></a>外部LSA详细描述</h3><p>表 2‑5 OSPF外部LSA详细描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>LSA内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>LS type：AS External Link</td>
<td>LSA类型为AS外部LSA</td>
</tr>
<tr>
<td>2</td>
<td>Link State ID：3.3.3.3（External Netwrok Number）</td>
<td>链路状态通告的名称为3.3.3.3（外部网络号）</td>
</tr>
<tr>
<td>3</td>
<td>Advertising Router</td>
<td>通告路由器为3.3.3.3（ASBR路由器的router-id）</td>
</tr>
<tr>
<td>4</td>
<td>LS Seq Number：80000001</td>
<td>LSA序列号</td>
</tr>
<tr>
<td>5</td>
<td>Chesksum：0x385</td>
<td>校验和</td>
</tr>
<tr>
<td>6</td>
<td>Length：36</td>
<td>LSA长度</td>
</tr>
<tr>
<td>7</td>
<td>Network Mask：/32</td>
<td>网络掩码长度</td>
</tr>
<tr>
<td>8</td>
<td>Metric Type：2</td>
<td>开销类型为2，不累加内部开销，内部metric依靠forward metric来计算</td>
</tr>
<tr>
<td>9</td>
<td>Metric：20</td>
<td>重分发进OSPF的路由的seed metric</td>
</tr>
</tbody>
</table>
</div>
<h3 id="OSPF的路由优先级"><a href="#OSPF的路由优先级" class="headerlink" title="OSPF的路由优先级"></a>OSPF的路由优先级</h3><p>O>O IA>外部（当metric相同的时候，O E1>O<br>N1，当metric不同的时候，选择metric小的；O E1>O E2 ; O N1>O N2）</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>OSPF</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF Neighbor State</title>
    <url>/2018/06/06/CCNPDAY6/</url>
    <content><![CDATA[<p>OSPF邻居状态机和网络类型</p>
<h1 id="OSPF邻居状态机"><a href="#OSPF邻居状态机" class="headerlink" title="OSPF邻居状态机"></a>OSPF邻居状态机</h1><p>OSPF路由器需要邻居路由器在几种邻居状态之间转换后，才能形成邻居之间的完全邻接关系。</p>
<ul>
<li>Down（失效状态）：这是一个邻居会话的初始状态，指明在一个deadinterval的时间内还没有收到来自邻居路由器的hello包。除非在NBMA网络中的那些邻居路由器，否则，hello包不会发送给那些失效的邻居路由器。在NBMA网络环境中，hello包每个pollinterval（2倍hello<br>interval）的时间发送一次。</li>
</ul>
<a id="more"></a>
<ul>
<li>Initial（初始状态）：表明在最近的deadinterval时间内收到了来自邻居路由器的hello包，但双向通信仍然没有建立。</li>
<li>Two-way（双向通信状态）：表明本地路由器已经在来自邻居路由器的hello包中的邻居字段看到了自己的路由器ID，意味双向通信建立成功。在多路访问的网络中，邻居路由器必须在这个状态或者更高状态时才有资格被选为该网络的DR或BDR。</li>
<li>ExStart（信息交换初始状态）：在这一状态下，本地路由器和它的邻居路由器将建立主/从关系，通过发送空的DBD报文，I/M/MS全部置1，进行主/从的选举，具有最高路由器ID的路由器将成为主路由器。</li>
<li>Exchange（信息交换状态）：在这一状态下，邻居路由器之间发起DBD包交换，由主路由器发起，从路由器通过使用主路由器的相同序列号进行隐式确认。通过DBD交换，得知本地路由器缺少的LSA，通过向邻居发送LSR请求完整的LSA，邻居路由器收到LSR之后发送LSU包含了请求的LSA，最后LSAck确认。</li>
<li>Loading（信息加载状态）：在这一状态，本地路由器将会向它的邻居路由器发送LSR，请求最新的LSA。虽然在Exchange状态已经经历这一过程，但是如果LSA条目过多，在Exchange状态没有更新完所有请求的LSA，将在这一阶段完成，也会出现在Exchange状态已经完成了所有的LSA通告，因此没有loading阶段。</li>
<li>Full（完全邻接状态）：路由器之间建立完全邻接状态，即收敛状态。</li>
</ul>
<h1 id="链路状态通告的扩散泛洪"><a href="#链路状态通告的扩散泛洪" class="headerlink" title="链路状态通告的扩散泛洪"></a>链路状态通告的扩散泛洪</h1><p>在路由器形成邻居关系后，需要建立邻接关系的路由器之间需要相互传递链路状态通告（LSA），LSA被发送给每个邻居，路由器保存接收到的LSA，并以此向每个邻居转发，除了发送该LSA的邻居之外。LSA几乎是立刻被转发的，相对于距离矢量路由更新而言，不需要先更新自己的路由表再进行发送，这就是当网络拓扑改变时，链路状态路由协议收敛速度远远快于距离矢量路由协议的原因。</p>
<p>关于链路状态通告泛洪的两个重要参数：</p>
<ol>
<li>序列号</li>
<li>老化时间</li>
</ol>
<p><img src="/2018/06/06/CCNPDAY6/88137ab0155e5c38f05d4a41a0f39148.png" alt=""></p>
<p>图 2‑1 OSPF LSA泛洪示意图</p>
<h2 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h2><p>当路由器A连接的子网172.22.4.0发生故障，因而路由器A向邻居路由器B和路由器D泛洪扩散一个LSA，以便通告该链路的新状态。路由器B和路由器D向它们的邻居扩散该LSA，依次类推。</p>
<p>路由器C在t1时刻，收到来自路由器B传递的LSA，路由器C将相关信息输入到链路状态数据库（LSDB），并向路由器F转发。在t3时刻，另一份相同的LSA拷贝经过A-D-E-F-C到达路由器C。路由器C发现LSDB中已经存在该LSA，那么路由器C会不会将该LSA继续转发给路由器B呢？答案是不转发，因为路由器C是从邻居路由器B收到这个通告的。</p>
<p>当路由器A发送LSA时，在每个拷贝中的序列号都是一样的。这个序列号和LSA的其他部分一起被保存在路由器的LSDB中，当路由器收到数据库中已存在的LSA且序列号相同时，路由器将丢弃这些信息。如果信息相同但是序列号更大，则接收的信息和新序列号被保存到数据库中，并且泛洪扩散。</p>
<p>序列号在数据包中占32bits，防止序列号耗尽问题，采用了棒棒糖形序列号空间。当路由器重启后，路由器发送序列号为最小值的LSA，邻居检查数据库时发现该路由器重启前LSA的序列号为0x00005de3，这时邻居将把这个LSA发给重启的路由器。</p>
<p>LSA的序列号最小值：0x80000001</p>
<p>LSA的序列号最大值：0x7FFFFFFF</p>
<h2 id="老化时间"><a href="#老化时间" class="headerlink" title="老化时间"></a>老化时间</h2><p>老化过程为泛洪扩散过程增加了另一层可靠性，定义了一个最大年龄差距（MaxAgeDiff）值。路由器可能接收到一个LSA的多个拷贝，其中序列号相同，年龄不同。如果年龄的差距小于MaxAgeDiff，则认为是正常的网络延迟造成了年龄差距，因此原有LSDB中的LSA继续保存，忽略新收到的LSA；如果年龄差距大于MaxAgeDiff，则认为网络发生异常，较新的LSA被记录下来，并将数据包扩散出去。OSPF的MaxAgeDiff为15min。</p>
<h1 id="OSPF接口信息"><a href="#OSPF接口信息" class="headerlink" title="OSPF接口信息"></a>OSPF接口信息</h1><p>Show ip ospf interface f0/0</p>
<p><img src="/2018/06/06/CCNPDAY6/79e13b231dacf871b2baf610b124b7a7.png" alt=""></p>
<p>接口状态：up，up</p>
<p>接口ip地址：12.1.1.1，掩码24位；接口宣告区域0</p>
<p>Ospf进程号1；路由器ID 1.1.1.1；网络类型：广播；开销：1</p>
<p>注：ospf开销计算公式：10\^8/接口带宽，10\^8为默认参考值，当网络中拥有100M链路和1000M链路，那么算出来的值都为1，无法区分链路的优劣，如果结果为小数，取整。</p>
<p>可以修改默认参考值来区分不同链路的开销值<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)\#router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">R1(config-router)\#auto-cost reference-bandwidth 100 （默认为100Mb）</span><br></pre></td></tr></table></figure></p>
<p>修改开销值：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)\#int f0/0</span><br><span class="line"></span><br><span class="line">R1(config-if)\#ip<span class="built_in"> ospf </span>cost 1</span><br></pre></td></tr></table></figure></p>
<p>传输延迟：1秒，LSA每经过一台路由器老化时间加1</p>
<p>修改传输延迟：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)\#int f0/0</span><br><span class="line"></span><br><span class="line">R1(config-if)\#ip<span class="built_in"> ospf </span>transmit-delay 1</span><br></pre></td></tr></table></figure></p>
<p>状态：BDR；优先级为1，用于选举DR/BDR</p>
<p>指定路由器ID：2.2.2.2；接口地址：12.1.1.2</p>
<p>备份指定路由器ID：1.1.1.1；接口地址：12.1.1.1</p>
<p>计时器：hello间隔：10秒，无效时间：40秒，等待时间：40秒，重传间隔：5秒（等待时间等于无效时间，在路由器宣告ospf接口后开始计时，等待时间过后开始选举DR/BDR）</p>
<p>Hello计时器：下一次发送hello的剩余时间</p>
<p>邻居路由器：形成邻接关系的路由器ID</p>
<h1 id="OSPF接口状态机"><a href="#OSPF接口状态机" class="headerlink" title="OSPF接口状态机"></a>OSPF接口状态机</h1><ul>
<li>失效（down）：初始化接口状态。这个阶段，接口上没有任何路由协议的通信</li>
<li>点到点（point to point）：这种接口状态适用于点到点、点到多点等网络类型的接口</li>
<li>等待（waiting）：这种接口状态适用于多路访问网络环境，选举DR/BDR前所经历的等待时间就是这个状态。</li>
<li>指定路由器（DR）：指定路由器</li>
<li>备份指定路由器（BDR）：备份指定路由器</li>
<li>DRohter：非DR,BDR的路由器</li>
</ul>
<h1 id="OSPF网络类型"><a href="#OSPF网络类型" class="headerlink" title="OSPF网络类型"></a>OSPF网络类型</h1><h2 id="点到点网络"><a href="#点到点网络" class="headerlink" title="点到点网络"></a>点到点网络</h2><p>点到点网络，像PPP,HDLC链路，连接单独一对路由器。在点到点网络上的有效邻居总是可以形成邻接关系的，不选举DR/BDR，使用224.0.0.5发送ospf数据包，hello间隔为10秒。</p>
<h2 id="广播型网络"><a href="#广播型网络" class="headerlink" title="广播型网络"></a>广播型网络</h2><p>多路访问网络可以连接多于两台的设备，例如以太网，不是所有路由器都形成邻接关系，需要选举DR/BDR，DR/BDR使用224.0.0.5发送ospf数据包给DRother，DRother使用224.0.0.6发送ospf数据包给DR/BDR，hello间隔为10秒。</p>
<h2 id="非广播多路访问（NBMA）网络"><a href="#非广播多路访问（NBMA）网络" class="headerlink" title="非广播多路访问（NBMA）网络"></a>非广播多路访问（NBMA）网络</h2><p>NBMA网络，例如帧中继，ATM等，可以连接两台以上的路由器，但是没有广播数据包的能力。不是所有路由器都形成邻接关系，需要选举DR/BDR，并且所有的OSPF数据包都为单播，hello间隔为30秒。</p>
<h2 id="点到多点网络（point-to-multipoint）"><a href="#点到多点网络（point-to-multipoint）" class="headerlink" title="点到多点网络（point-to-multipoint）"></a>点到多点网络（point-to-multipoint）</h2><p>点到多点网络可以看作是多个点到点链路的集合，不需要选举DR/BDR，ospf数据包以组播方式发送给每一个已知邻居，hello间隔为30秒。</p>
<p>表 5‑1 OSPF网络类型</p>
<p><img src="/2018/06/06/CCNPDAY6/7da38b82c0060861bfc4dd569a635d21.png" alt=""></p>
<h1 id="帧中继环境中的ospf"><a href="#帧中继环境中的ospf" class="headerlink" title="帧中继环境中的ospf"></a>帧中继环境中的ospf</h1><p>帧中继交换机：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Frame-relay switching</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span><span class="built_in"> ip </span>address</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">clock rate 64000</span><br><span class="line"></span><br><span class="line">frame-relay lmi-type cisco</span><br><span class="line"></span><br><span class="line">frame-relay intf-type dce</span><br><span class="line"></span><br><span class="line">frame-relay<span class="built_in"> route </span>102<span class="built_in"> interface </span>Serial0/1 201</span><br><span class="line"></span><br><span class="line">frame-relay<span class="built_in"> route </span>103<span class="built_in"> interface </span>Serial0/2 301</span><br><span class="line"></span><br><span class="line">interface Serial0/1</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span><span class="built_in"> ip </span>address</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">clock rate 64000</span><br><span class="line"></span><br><span class="line">frame-relay lmi-type cisco</span><br><span class="line"></span><br><span class="line">frame-relay intf-type dce</span><br><span class="line"></span><br><span class="line">frame-relay<span class="built_in"> route </span>201<span class="built_in"> interface </span>Serial0/0 102</span><br><span class="line"></span><br><span class="line">interface Serial0/2</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span><span class="built_in"> ip </span>address</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">clock rate 64000</span><br><span class="line"></span><br><span class="line">frame-relay lmi-type cisco</span><br><span class="line"></span><br><span class="line">frame-relay intf-type dce</span><br><span class="line"></span><br><span class="line">frame-relay<span class="built_in"> route </span>301<span class="built_in"> interface </span>Serial0/0 103</span><br></pre></td></tr></table></figure></p>
<p>点到多点网络类型：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf network </span>point-to-multipoint</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.3 103 broadcast</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.2 102 broadcast</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 1.1.1.1</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 1.1.1.1 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.1 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.2 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf network </span>point-to-multipoint</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.1 201 broadcast</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 2.2.2.2</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 2.2.2.2 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.2 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.3 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf network </span>point-to-multipoint</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.1 301 broadcast</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 3.3.3.3</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 3.3.3.3 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.3 0.0.0.0<span class="built_in"> area </span>0</span><br></pre></td></tr></table></figure></p>
<p>非广播网络类型：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.3 103</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.2 102</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 1.1.1.1</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 1.1.1.1 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.1 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">neighbor 123.1.1.2</span><br><span class="line"></span><br><span class="line">neighbor 123.1.1.3</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.2 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf </span>priority 0</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.3 201</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.1 201</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 2.2.2.2</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 2.2.2.2 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.2 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.3 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf </span>priority 0</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.3 301</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.1 301</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 3.3.3.3</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 3.3.3.3 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.3 0.0.0.0<span class="built_in"> area </span>0</span><br></pre></td></tr></table></figure></p>
<p>广播型网络：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf network </span>broadcast</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.3 103 broadcast</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.2 102 broadcast</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 1.1.1.1</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 1.1.1.1 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.1 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.2 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf network </span>broadcast</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf </span>priority 0</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.3 201 broadcast</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.1 201 broadcast</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 2.2.2.2</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 2.2.2.2 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.2 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.1.1.3 255.255.255.0</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf network </span>broadcast</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> ospf </span>priority 0</span><br><span class="line"></span><br><span class="line">serial restart-delay 0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.3 301 broadcast</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.1.1.1 301 broadcast</span><br><span class="line"></span><br><span class="line">router<span class="built_in"> ospf </span>1</span><br><span class="line"></span><br><span class="line">router-id 3.3.3.3</span><br><span class="line"></span><br><span class="line">log-adjacency-changes</span><br><span class="line"></span><br><span class="line">network 3.3.3.3 0.0.0.0<span class="built_in"> area </span>0</span><br><span class="line"></span><br><span class="line">network 123.1.1.3 0.0.0.0<span class="built_in"> area </span>0</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>OSPF</tag>
      </tags>
  </entry>
  <entry>
    <title>OSPF BASIC</title>
    <url>/2018/06/06/CCNPDAY5/</url>
    <content><![CDATA[<p><strong>OSPF路由协议基础部分</strong></p>
<h1 id="OSPF的概述"><a href="#OSPF的概述" class="headerlink" title="OSPF的概述"></a>OSPF的概述</h1><p>OSPF是一种链路状态路由协议。不同于距离矢量路由协议依照传闻进行路由选择的工作方式，链路状态路由器从其他路由器那里获取第一手信息。每台路由器会产生一些关于自己、本地直连链路、这些链路的状态和所有直连邻居的信息（LSA）。这些信息从一台路由器传送到另一台路由器，每台路由器都在一份信息拷贝，但绝不改动信息。最终目的是每台路由器都有一个相同的相关网络的信息，并且每台路由器以自己为根独立的计算各自的最优路径。</p>
<a id="more"></a>
<p><img src="/2018/06/06/CCNPDAY5/6e40fa14fa6154d667948bff3ca3b7eb.png" alt=""></p>
<p>图 1‑1 链路状态路由协议收敛过程</p>
<p>链路状态路由协议包括：</p>
<ul>
<li>OSPF</li>
<li>IS-IS</li>
</ul>
<p>OSPF正如它的命名一样，使用Dikstra的最短路径优先（SPF）算法，并且是一个开放的协议，即公有协议。</p>
<h1 id="OSPF的特点"><a href="#OSPF的特点" class="headerlink" title="OSPF的特点"></a>OSPF的特点</h1><ol>
<li>使用区域化的概念，这样可以有效的减少算法对CPU和内存的占用，构建一个层次化的网络拓扑。</li>
<li>支持无类路由，VLSM，CIDR</li>
<li>支持无大小限制、任意的度量值</li>
<li>局部更新</li>
<li>支持多条路径的等价负载均衡</li>
<li>使用组播地址更新（224.0.0.5和224.0.0.6）</li>
<li>支持认证</li>
</ol>
<h1 id="OSPF区域"><a href="#OSPF区域" class="headerlink" title="OSPF区域"></a>OSPF区域</h1><ul>
<li>Transit area（backbone area）传输区域或骨干区域</li>
</ul>
<p>只有area 0属于传输区域</p>
<ul>
<li>Regular areas（nonbackbone areas）常规区域或非骨干区域</li>
</ul>
<p>非0区域都属于常规区域</p>
<p>所有的常规区域必须与骨干区域相连。</p>
<p><img src="/2018/06/06/CCNPDAY5/bb5633ec9be61a396085fa8969f0313a.png" alt=""></p>
<p>图 3‑1 OSPF区域</p>
<p>通过区域的划分减少链路状态信息的泛洪，链路状态信息只在同一区域内同步；通过手工汇总减少路由条目；构造一个层次化的网络。</p>
<h1 id="路由器类型"><a href="#路由器类型" class="headerlink" title="路由器类型"></a>路由器类型</h1><ul>
<li>ABR：区域边界路由器(Area Border Router)连接区域0和其他一个或多个区域的路由器</li>
<li>ASBR：自治系统边界路由器(Autonomous System Boundary<br>Router)连接外部网络的路由器</li>
<li>内部路由器：R5、R6等</li>
<li>骨干路由器：R1</li>
</ul>
<h1 id="OSPF的数据报文"><a href="#OSPF的数据报文" class="headerlink" title="OSPF的数据报文"></a>OSPF的数据报文</h1><p><img src="/2018/06/06/CCNPDAY5/52c12786dd4db2fae0accf13dc538f56.png" alt=""></p>
<p>图 5‑1 OSPF报文结构</p>
<p>OSPF数据包承载在ip之上，协议号为89，分为OSPF数据包头部和OSPF数据包数据部分。</p>
<h2 id="OSPF报头结构"><a href="#OSPF报头结构" class="headerlink" title="OSPF报头结构"></a>OSPF报头结构</h2><p><img src="/2018/06/06/CCNPDAY5/5bdb92b8c7ab2958e56b27c248791836.png" alt=""></p>
<p>图 5‑2 OSPF报头结构</p>
<h3 id="OSPF报头详细描述"><a href="#OSPF报头详细描述" class="headerlink" title="OSPF报头详细描述"></a>OSPF报头详细描述</h3><p>表 5‑1 OSPF报头描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>报头内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>版本（version）</td>
<td>版本1用于实验阶段；</td>
</tr>
<tr>
<td></td>
<td></td>
<td>版本2用于ipv4；</td>
</tr>
<tr>
<td></td>
<td></td>
<td>版本3用于ipv6。</td>
</tr>
<tr>
<td>2</td>
<td>类型(type)</td>
<td>代码1，代表hello包；</td>
</tr>
<tr>
<td></td>
<td></td>
<td>代码2，代表DBD（数据库描述）包；代码3，代表LSR（链路状态请求）包；代码4，代表LSU（链路状态更新）包；代码5，代表LSack（链路状态确认）包</td>
</tr>
<tr>
<td>3</td>
<td>数据包长度（Packet Length）</td>
<td>OSPF数据包长度，包括头部长度</td>
</tr>
<tr>
<td>4</td>
<td>路由器ID（Router ID）</td>
<td>始发路由器的ID，唯一性，在启用ospf路由进程的时候选举，因此与选择router-id的接口是否宣告进ospf没有任何关系。</td>
</tr>
<tr>
<td>5</td>
<td>区域ID（Area ID）</td>
<td>始发路由器所在的区域</td>
</tr>
<tr>
<td>6</td>
<td>校验和（Checksum）</td>
<td>对整个OSPF数据包进行差错校验</td>
</tr>
<tr>
<td>7</td>
<td>认证类型（AuType）</td>
<td>正在使用的认证模式，0为不认证，1为明文认证，2为MD5认证</td>
</tr>
<tr>
<td>8</td>
<td>认证（Authentication）</td>
<td>如果AuType=0，不检查该字段，如果AuType=1，将包含一个密钥，如果AuType=2，这个认证字段将包含KEY ID、认证数据长度、加密序列号、认证密钥。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Router-ID"><a href="#Router-ID" class="headerlink" title="Router-ID"></a>Router-ID</h3><p>路由器ID是在OSPF区域内唯一标识一台路由器的ip地址。</p>
<p>Cisco路由器通过以下方式得到路由器ID：</p>
<ol>
<li>使用命令router-id手工配置</li>
<li>如果没有手工配置，路由器选择最大的环回接口ip地址作为router-id</li>
<li>如果没有换回接口，则使用最大的物理接口ip地址作为router-id<ol>
<li>OSPF hello报文</li>
</ol>
</li>
</ol>
<p>Hello包用于建立ospf邻居关系，并维护邻居关系，在两台路由器形成邻居之前，必须要相互认可几个参数：</p>
<p><img src="/2018/06/06/CCNPDAY5/01d08984d10e53b18cf52f82c5f5319c.png" alt=""></p>
<p>图 5‑3 OSPF hello报文结构</p>
<h3 id="hello报文详细描述"><a href="#hello报文详细描述" class="headerlink" title="hello报文详细描述"></a>hello报文详细描述</h3><p>表 5‑2 OSPF hello报文内容描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>报文内容</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>网络掩码（Network Mask）</td>
<td>发送ospf hello包的接口网络掩码</td>
<td>如果这个掩码和接收该hello包的接口网络掩码不匹配，该hello包被丢弃</td>
</tr>
<tr>
<td>2</td>
<td>Hello时间间隔（hello interval）</td>
<td>接口发送hello包的间隔时间，对于以太网链路和点到点链路，默认为10秒。非广播多路访问链路和点到多点链路是30秒。</td>
<td>如果发送和接收路由器没有相同的值，那么它们就不能建立一种邻居关系</td>
</tr>
<tr>
<td>3</td>
<td>路由器优先级（Router Priority）</td>
<td>用来选择DR和BDR路由器</td>
<td>如果该字段设置为0，那么该路由器将没有资格被选举为DR和BDR</td>
</tr>
<tr>
<td>4</td>
<td>路由器无效时间间隔（Router Dead Interval）</td>
<td>为hello interval的4倍，如果在这段时间内没有收到邻居路由器的hello包，认为邻居路由器失效。</td>
<td>如果收到hello包的时间和接收接口配置的deadinterval不匹配，那么这个hello包被丢弃</td>
</tr>
<tr>
<td>5</td>
<td>指定路由器（DR）</td>
<td>网络上指定路由器接口的ip地址</td>
<td>不是指定路由器的路由器ID</td>
</tr>
<tr>
<td>6</td>
<td>备份指定路由器（BDR）</td>
<td>网络上备份指定路由器接口的ip地址</td>
<td>N/A</td>
</tr>
<tr>
<td>7</td>
<td>邻居（Neighbor）</td>
<td>从网络上收到来自邻居的有效hello包，则会在这个字段列出所有的邻居RID</td>
<td>N/A</td>
</tr>
</tbody>
</table>
</div>
<h3 id="修改ospf的hello-interval和dead-interval"><a href="#修改ospf的hello-interval和dead-interval" class="headerlink" title="修改ospf的hello interval和dead interval"></a>修改ospf的hello interval和dead interval</h3><p>R1(config)#int s0/0</p>
<p>R1(config-if)#ip ospf hello-interval 10</p>
<p>R1(config-if)#ip ospf dead-interval 10</p>
<h3 id="指定路由器（DR）和备份指定路由器（BDR）"><a href="#指定路由器（DR）和备份指定路由器（BDR）" class="headerlink" title="指定路由器（DR）和备份指定路由器（BDR）"></a>指定路由器（DR）和备份指定路由器（BDR）</h3><p>对于OSPF路由协议来说，在多路访问网络中LSA的泛洪存在两个问题：</p>
<ol>
<li>构建相关路由器之间的邻接关系时，会创建很多不必要的LSA。</li>
<li>LSA的泛洪会比较混乱。</li>
</ol>
<p>在OSPF网络中，如果要在每一台路由器和它的邻居路由器形成完全网状的OSPF邻接关系，5台路由器需要形成10个邻接关系，产生25条LSA通告</p>
<p><img src="/2018/06/06/CCNPDAY5/2e0ddb7c43ba17bcbd64f9fb99dec1c5.png" alt=""></p>
<p>图 5‑4 OSPF建立邻接关系示意图</p>
<p>为了在多路访问的网络环境中避免这些问题的发生，可以在网络上选举一台指定路由器完成以下工作：</p>
<ul>
<li>描述这个多路访问网络和OSPF区域内其余相连的路由器；</li>
<li>管理这个多路访问网络上的LSA泛洪。</li>
</ul>
<p>DR描述一个多路访问网络，网络上的其他路由器都将和这个指定路由器形成邻接关系，而不是所有路由器都相互形成邻接关系。</p>
<p><img src="/2018/06/06/CCNPDAY5/918bbd34de401fb354a5d2baa15db59a.png" alt=""></p>
<p>图 5‑5 OSPF DR建立邻接关系示意图</p>
<p>关于指定路由器的一个重要问题：如果DR失效，就必须重新选举一台新的指定路由器。网络上的所有路由器也要重新的建立邻接关系。为了避免这个问题，网络上除了选举DR之外，还选举BDR。DR和BDR形成邻接关系，当DR失效，BDR将成为新的DR。并且BDR也和其他路由器形成邻接关系，所以当BDR成为新的DR时，无需重新建立邻接关系，将影响降低到最小。</p>
<p>DR和BDR的选举过程：</p>
<ol>
<li>路由器和邻居路由器之间首先要建立two-way状态，接着查看hello包的优先级、DR、BDR字段，列出所有具有DR和BDR选举资格的路由器列表（即优先级要大于0）</li>
<li>所有路由器都宣称自己是DR和BDR</li>
<li>通过优先级高的选举为BDR，如果优先级相同选择RID最高的最为BDR</li>
<li>由于没有DR的存在，BDR成为DR，重新选举BDR。</li>
</ol>
<p>在选举成功后，其他的路由器都叫做DRother。即使接入一台优先级更高的路由器，也不会成为新的DR，它只能等待DR失效，原来的BDR成为DR，它再成为BDR。</p>
<h2 id="数据库描述数据包（DBD）"><a href="#数据库描述数据包（DBD）" class="headerlink" title="数据库描述数据包（DBD）"></a>数据库描述数据包（DBD）</h2><p>DBD包用于正在建立的邻接关系。DBD包的主要目的是描述始发路由器数据库中的LSA摘要信息，以便接收路由器能够确定所收到的LSA在其数据库中是否已经存在这些LSA。LSA的摘要信息只需要列出该LSA的头部即可。</p>
<p><img src="/2018/06/06/CCNPDAY5/64363b616340496337e251b52bd49d48.png" alt=""></p>
<p>图 5‑6 OSPF DBD数据报文格式</p>
<h3 id="DBD报文详细描述"><a href="#DBD报文详细描述" class="headerlink" title="DBD报文详细描述"></a>DBD报文详细描述</h3><p>表 5‑3 DBD报文详细描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>报文内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>接口MTU（Interface MTU）</td>
<td>是指在数据包不分片的情况下，始发路由器接口可以发送的最大IP数据包大小</td>
</tr>
<tr>
<td>2</td>
<td>I位（Initial位）</td>
<td>当发送DBD包是第一个时，该位置位为1，后续DBD包将该位设置为0</td>
</tr>
<tr>
<td>3</td>
<td>M位（More位）</td>
<td>当发送的DBD包不是最后一个包时，该位置位1，最后一个DBD包将该位置0</td>
</tr>
<tr>
<td>4</td>
<td>MS位（Master/Slave位）</td>
<td>在数据库同步过程中，该位置1，用来指明始发DBD数据包的路由器是一个主路由器。从路由器将该位置0</td>
</tr>
<tr>
<td>5</td>
<td>数据库描述序列号（DBD Sequence Number）</td>
<td>在数据库的同步过程中，确保路由器能够收到完整的数据库描述数据包序列。使用序列号进行隐式确认。</td>
</tr>
<tr>
<td>6</td>
<td>LSA头部（LSA Header）</td>
<td>列出始发路由器的链路状态数据库中的LSA头部信息。在LSA头部信息里有足够的信息可以唯一的标识一个LSA</td>
</tr>
</tbody>
</table>
</div>
<p>主从关系的选举：通过Router-ID的比较，Router-id大的为master</p>
<p>确认机制：</p>
<ul>
<li>显式确认：通过ack明确的进行确认。</li>
<li>隐式确认：从路由器使用主路由器相同的序列号进行确认。<ol>
<li>链路状态请求包（LSR）</li>
</ol>
</li>
</ul>
<p>在数据库同步过程中如果收到了DBD包，路由器将会查看DBD里有哪些LSA不在自己的数据库中，或者哪些LSA比自己数据库中的LSA更新。然后将这些LSA记录在链路请求列表中。接着路由器会发送LSR包向它的邻居请求完整的LSA。</p>
<p><img src="/2018/06/06/CCNPDAY5/5185b5e880a01413053aea9e5c0a6cc8.png" alt=""></p>
<p>图 5‑7 OSPF LSR报文格式</p>
<h3 id="LSR报文详细描述"><a href="#LSR报文详细描述" class="headerlink" title="LSR报文详细描述"></a>LSR报文详细描述</h3><p>表 5‑4 LSR报文详细描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>报文内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>链路状态类型（Link State Type）</td>
<td>用来指明LSA的类型</td>
</tr>
<tr>
<td>2</td>
<td>链路状态ID（Link State ID）</td>
<td>用来指明LSA的名字</td>
</tr>
<tr>
<td>3</td>
<td>通告路由器（Advertising Router）</td>
<td>是指发送LSA的路由器的RID</td>
</tr>
</tbody>
</table>
</div>
<h2 id="链路状态更新包（LSU）"><a href="#链路状态更新包（LSU）" class="headerlink" title="链路状态更新包（LSU）"></a>链路状态更新包（LSU）</h2><p>用于LSA的泛洪和响应LSR请求包。</p>
<p><img src="/2018/06/06/CCNPDAY5/5d070a7a5f78057abef26515e941d86b.png" alt=""></p>
<p>图 5‑8 OSPF LSR报文机构</p>
<p>LSA数量（Number of LSA）：支持这个LSR包中包含的LSA的数量。</p>
<p>链路状态通告（LSA）：LSU数据包中携带的完整的链路状态通告信息，一个LSU可以携带多个LSA。</p>
<h2 id="链路状态确认包（LSAck）"><a href="#链路状态确认包（LSAck）" class="headerlink" title="链路状态确认包（LSAck）"></a>链路状态确认包（LSAck）</h2><p>保证LSA可靠的泛洪扩散。一台路由器从它的邻居路由器收到的每一个LSA都必须在LSAck包中进行明确的确认。被确认的LSA是根据在LSAck包里包含它的头部来辨别的，多个LSA可以通过单个SLAck确认。一个LSAck包的组成除了OSPF头部和一个LSA不透的列表之外，没有其他多余的内容了。</p>
<p><img src="/2018/06/06/CCNPDAY5/44685677dd80ff0709919b1a4fd5962d.png" alt=""></p>
<p>图 5‑9 OSPF LSAck报文结构</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>OSPF</tag>
      </tags>
  </entry>
  <entry>
    <title>EIGRP ADVANCED</title>
    <url>/2018/05/29/CCNPDAY4/</url>
    <content><![CDATA[<h1 id="EIGRP-query和reply报文"><a href="#EIGRP-query和reply报文" class="headerlink" title="EIGRP query和reply报文"></a>EIGRP query和reply报文</h1><p>路由表形成后，EIGRP拓扑表里的条目为P（passive）状态，EIGRP没有周期性更新，因此在拓扑没有变更时，路由都处于被动状态。</p>
<p>当拓扑发生变更时，例如后继路由器（S）失效，路由器首先执行本地计算，即对所有的可行后继路由器，重新计算到达目的地的距离，距离最小的FS成为S。当路由器进行本地计算时，路由条目仍然处于被动状态，发送路由更新即可。</p>
<a id="more"></a>
<p>如果拓扑表中没有FS，那么路由器将要进行扩散计算，路由器将路由改为active状态，向邻居路由器发送查询报文，在完成扩散计算回到被动状态之前，路由器不能改变后继路由器，不能开始进行另一个扩散更新算法。</p>
<p>对于每一台接收查询的邻居路由器，如果有到达目标的路由，回复reply包，如果没有到达目标的路由，继续向除了收到查询的邻居路由器发送查询报文，直至到网络边界路由器没有该路由，回复reply通告没有该路由，本地路由器将设置一个答复状态标记来不断的跟踪所有未处理的查询报文。当本地路由器收到所有发送到邻居路由器的查询的答复时，扩散计算就算完成了。</p>
<p><img src="/2018/05/29/CCNPDAY4/8ef6d2188694e4aee64860cbc9757f13.png" alt=""></p>
<p>图 1‑1 EIGRP扩散查询过程</p>
<h2 id="query报文格式"><a href="#query报文格式" class="headerlink" title="query报文格式"></a>query报文格式</h2><p><img src="/2018/05/29/CCNPDAY4/304939fd28e0f827ae806699b85ca7db.png" alt=""></p>
<p>图 1‑2 EIGRP查询报文格式</p>
<p>由图1-2可以发现，EIGRP<br>query报文实际上由EIGRP报头+内部路由类型TLV报文组成的，被查询的路由延迟为4294967295，即0xFFFFFFFF。</p>
<h2 id="reply报文格式"><a href="#reply报文格式" class="headerlink" title="reply报文格式"></a>reply报文格式</h2><p><img src="/2018/05/29/CCNPDAY4/eb079048b2a54bd2577f9e1ac6864c91.png" alt=""></p>
<p>图 1‑3 EIGRP reply报文格式</p>
<p>由图1-3可以发现，EIGRP<br>reply报文实际上也是由EIGRP报头+内部路由类型TLV报文组成的，被查询的路由延迟为4294967295，即0xFFFFFFFF，通过单播方式反馈查询路由器。</p>
<p>查看查询包和应答包：</p>
<p><img src="/2018/05/29/CCNPDAY4/9d8215b72449ef50c6263c1e2d9a6603.png" alt=""></p>
<p>图 1‑4 EIGRP数据包查询截图</p>
<h2 id="EIGRP-SIA"><a href="#EIGRP-SIA" class="headerlink" title="EIGRP SIA"></a>EIGRP SIA</h2><p>如果路由器没有收到发出的每一个查询的答复报文，路由器通过活动计时器（active<br>timer）3min之后宣告该路由“卡”在活动状态（stuck-in-active，SIA），将没有答复的邻居从邻居列表中删除，并认为该邻居回复了一个无穷大的度量，重置邻居关系。</p>
<p>修改活动计时器：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span>\<span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span>\<span class="selector-id">#timers</span> active-<span class="selector-tag">time</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p>
<h2 id="EIGRP查询流程"><a href="#EIGRP查询流程" class="headerlink" title="EIGRP查询流程"></a>EIGRP查询流程</h2><p><img src="/2018/05/29/CCNPDAY4/6bbe0cb8273254c99b14304426242624.png" alt=""></p>
<p>图 1‑5 EIGRP查询过程</p>
<p>拓扑说明：</p>
<p>A、B为中心站点，C、D、E为分支站点，A、B为以太链路，其余为低速链路，A到达.0网络的S为B，没有FS，C、D、E到10.1.1.0网络的S为B，FS为A，当10.1.1.0网络失效时，B发送查询报文给A、C、D、E，C、D、E都有FS，因此会向B回复reply，同时A也收到B的查询包，而A没有FS，A继续向C、D、E发送查询包，由于C、D、E的FS就是A，因此无法将A再回复给A，继续向B发送查询，结果，原本是B发出的查询，反而又向B查询。</p>
<h2 id="EIGRP-SIA解决方案："><a href="#EIGRP-SIA解决方案：" class="headerlink" title="EIGRP SIA解决方案："></a>EIGRP SIA解决方案：</h2><ul>
<li><p>路由汇总</p>
</li>
<li><p>stub区域</p>
<ol>
<li>EIGRP路由汇总</li>
</ol>
</li>
</ul>
<p><img src="/2018/05/29/CCNPDAY4/42dc57c20e1a4722e2be686f31b38d86.png" alt=""></p>
<p>图 1‑6 EIGRP路由汇总实验拓扑图<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span>\<span class="selector-id">#int</span> f1/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span>\<span class="selector-id">#ip</span> summary-<span class="selector-tag">address</span> eigrp <span class="number">100</span> <span class="number">3.3</span>.<span class="number">3.0</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/05/29/CCNPDAY4/0b8a3f9049d03fde46ed6d0d0d1e3ff2.png" alt=""></p>
<p>图 1‑7 R2 EIGRP路由表</p>
<p>汇总路由如何减小EIGRP的查询范围？</p>
<p>当一条明细路由失效，路由器发送查询包查询的是明细路由，而邻居路由器的路由表只有汇总路由，没有明细路由，直接回复reply告知该明细路由不可达。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span>\<span class="selector-id">#int</span> loopback0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span>\#shutdown</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/05/29/CCNPDAY4/b26e552d8cb3abda8d61ccea77601800.png" alt=""></p>
<p>图 1‑8 R2 debug query报文截图</p>
<p><img src="/2018/05/29/CCNPDAY4/a8210eb2e13caa82c638c4d94c94f363.png" alt=""></p>
<p>图 1‑9 R1 debug query报文截图</p>
<h3 id="EIGRP-stub"><a href="#EIGRP-stub" class="headerlink" title="EIGRP stub"></a>EIGRP stub</h3><p>配置了eigrp<br>stub的路由器在hello包中标识自己为stub路由器，邻居路由器收到该hello包，不会再向这台路由器发送查询包。</p>
<p><img src="/2018/05/29/CCNPDAY4/a0891584ff37b5428e51795a6154c19d.png" alt=""></p>
<p>图 1‑10 EIGRP stub实验拓扑图</p>
<p>R2没有配置eigrp stub之前</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span>\<span class="selector-id">#interface</span> lo0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span>\#shutdwon</span><br><span class="line"></span><br><span class="line">R3\<span class="number">#deb</span>ug eigrp packet query</span><br></pre></td></tr></table></figure>
<p><img src="/2018/05/29/CCNPDAY4/0c07b0ea822ca46475a60ce49b6a3263.png" alt=""></p>
<p>图 1‑11 R3 debug query报文截图</p>
<p>R2配置eigrp stub<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span>\<span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-router)</span></span>\<span class="selector-id">#eigrp</span> stub</span><br></pre></td></tr></table></figure></p>
<p>再次shutdown lo0，R3不向R2发送查询包</p>
<h1 id="Eigrp-自动汇总"><a href="#Eigrp-自动汇总" class="headerlink" title="Eigrp 自动汇总"></a>Eigrp 自动汇总</h1><h2 id="EIGRP自动汇总"><a href="#EIGRP自动汇总" class="headerlink" title="EIGRP自动汇总"></a>EIGRP自动汇总</h2><p><img src="/2018/05/29/CCNPDAY4/abf7d0e2d588cfcfa9586ac6bee1394b.png" alt=""></p>
<p>图 2‑1 EIGRP自动汇总实验拓扑图</p>
<p>R1：</p>
<p><img src="/2018/05/29/CCNPDAY4/304921ff2b0fd754c309c503b2dfa8ad.png" alt=""></p>
<p>图 2‑2 R1 EIGRP路由表截图</p>
<p>.3/32并没有被汇总</p>
<p>R2：</p>
<p><img src="/2018/05/29/CCNPDAY4/188ab195e9341a5e1923c8871b771f79.png" alt=""></p>
<p>图 2‑3 R2 EIGRP路由表截图</p>
<p>Null0，空接口，相当于发往该接口的数据包被丢弃。为什么要产生一条指向null0的汇总路由，假设不产生该汇总路由，R2上有一条默认路由指向R1，R1又有汇总路由指向R2，容易产生环路。EIGRP自动汇总和手动汇总都会产生指向null0的汇总路由。</p>
<h2 id="Eigrp自动汇总和RIP自动汇总的区别"><a href="#Eigrp自动汇总和RIP自动汇总的区别" class="headerlink" title="Eigrp自动汇总和RIP自动汇总的区别"></a>Eigrp自动汇总和RIP自动汇总的区别</h2><p>将上图的路由协议改为ripv2，同样是R2开启auto-summary</p>
<p>R1：</p>
<p><img src="/2018/05/29/CCNPDAY4/aba4d03b6af6c44cf8434a5eb5857b80.png" alt=""></p>
<p>图 2‑4 R1 RIP路由表截图</p>
<p>所有路由都被汇总。</p>
<p>R2：</p>
<p><img src="/2018/05/29/CCNPDAY4/8f7501860fc7c1b833da8aa22fe11747.png" alt=""></p>
<p>图 2‑5 R2 RIP路由表截图</p>
<p>没有产生指向null0的汇总路由。因此rip汇总时，建议手动添加一条指向null0的静态汇总路由。</p>
<p>小结：eigrp只对路由器直连路由进行汇总，rip对整个路由表的路由都进行汇总。</p>
<h1 id="EIGRP认证"><a href="#EIGRP认证" class="headerlink" title="EIGRP认证"></a>EIGRP认证</h1><p>MD5校验是EIGRP协议唯一支持的认证方式，因为明文认证大多使用在邻居设备不能全部支持MD5认证的情况下，而EIGRP只在cisco设备之间宣告，因此都支持MD5认证。</p>
<p>EIGRP认证的步骤：和RIP的MD5认证类似</p>
<ol>
<li>定义钥匙链：</li>
</ol>
<p><code>R1(config)\#key chain ccie</code></p>
<ol>
<li><p>在钥匙链上定义一把或一组钥匙</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-keychain)</span></span>\<span class="selector-id">#key</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-keychain-key)</span></span>\<span class="selector-id">#key-string</span> cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-keychain)</span></span>\<span class="selector-id">#key</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-keychain-key)</span></span>\<span class="selector-id">#key-string</span> cisco123</span><br></pre></td></tr></table></figure>
</li>
<li><p>在接口上启用认证并制定使用的钥匙链</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span>\<span class="selector-id">#interface</span> FastEthernet0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span>\<span class="selector-id">#ip</span> <span class="selector-tag">address</span> .<span class="number">1</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span>\<span class="selector-id">#ip</span> authentication mode eigrp <span class="number">100</span> md5</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span>\<span class="selector-id">#ip</span> authentication key-chain eigrp <span class="number">100</span> ccie</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="EIGRP被动接口"><a href="#EIGRP被动接口" class="headerlink" title="EIGRP被动接口"></a>EIGRP被动接口</h1><p>回顾rip passive interface，不发送路由更新，但接收路由更新</p>
<p>Eigrp passive interface<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)\#router eigrp 100</span><br><span class="line"></span><br><span class="line">R1(config-router)\#passive-interface f0/0</span><br><span class="line"></span><br><span class="line">R1(config-router)\#</span><br><span class="line"></span><br><span class="line">\*Mar 1 00:10:34.027: %DUAL-5-NBRCHANGE: IP-EIGRP(0) 100:<span class="built_in"> Neighbor </span>.2</span><br><span class="line">(FastEthernet0/0) is down:<span class="built_in"> interface </span>passive</span><br><span class="line"></span><br><span class="line">R1(config-router)\#end</span><br><span class="line"></span><br><span class="line">R1\#<span class="builtin-name">debug</span> eigrp packet</span><br><span class="line"></span><br><span class="line">EIGRP Packets debugging is on</span><br><span class="line"></span><br><span class="line">(UPDATE, REQUEST, QUERY, REPLY, HELLO, IPXSAP, PROBE, ACK, STUB, SIAQUERY,</span><br><span class="line">SIAREPLY)</span><br></pre></td></tr></table></figure></p>
<p>总结：EIGRP被动接口不发送也不接收任何eigrp报文，断邻居。</p>
<h1 id="EIGRP报文带宽占用率"><a href="#EIGRP报文带宽占用率" class="headerlink" title="EIGRP报文带宽占用率"></a>EIGRP报文带宽占用率</h1><p>通常在一个大型的EIGRP网络中引起SIA的原因<br>是网络拥塞严重数据链路带宽较低以及路由器内存过低或CPU利用率负荷过大等等。如果这些有限的资源必须处理数量很大的查询的话，这一个问题将会进步恶化。</p>
<p>interface FastEthernet0/0</p>
<p>bandwidth 10</p>
<p>ip address .1 255.255.255.0</p>
<p>ip bandwidth-percent eigrp 100 200</p>
<p>将eigrp报文占用带宽比例设置为200%，为设置bandwidth的200%，并非实际带宽的200%</p>
<h1 id="EIGRP默认路由"><a href="#EIGRP默认路由" class="headerlink" title="EIGRP默认路由"></a>EIGRP默认路由</h1><p><img src="/2018/05/29/CCNPDAY4/b3eaecfa0e8faaff7278f1c089f6d2f0.png" alt=""></p>
<p>图 6‑1 EIGRP默认路由实验拓扑图</p>
<h2 id="ip-default-network"><a href="#ip-default-network" class="headerlink" title="ip default-network"></a>ip default-network</h2><ol>
<li><p>创建一个主类地址</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>.2 255.0.0.0</span><br></pre></td></tr></table></figure>
</li>
<li><p>宣告进eigrp</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">router eigrp 100</span><br><span class="line"></span><br><span class="line">network .0</span><br><span class="line"></span><br><span class="line">network .2 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> auto-summary</span><br></pre></td></tr></table></figure>
</li>
<li><p>宣告默认网络</p>
</li>
</ol>
<p>ip default-network .0</p>
<p><img src="/2018/05/29/CCNPDAY4/7372c3d9e134aa39c0b379ddbd5d4a75.png" alt=""></p>
<p>图 6‑2 R1 EIGRP路由表截图</p>
<p>与rip不同，rip只要在网关路由器的路由表中有这条路由，然后宣告默认网络即可，而eigrp必须在路由表中存在的是有类路由！</p>
<h2 id="重分发静态路由"><a href="#重分发静态路由" class="headerlink" title="重分发静态路由"></a>重分发静态路由</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span>\<span class="selector-id">#ip</span> route .<span class="number">0</span> <span class="number">0.0</span>.<span class="number">0.0</span> f1/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span>\<span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-router)</span></span>\<span class="selector-id">#redistribute</span> static</span><br></pre></td></tr></table></figure>
<p>将静态路由重分发进eigrp的路由进程</p>
<p><img src="/2018/05/29/CCNPDAY4/96d5350ce9d1fc269cd920afffa06b69.png" alt=""></p>
<p>图 6‑3 R1 EIGRP路由表截图</p>
<h1 id="EIGRP-Leak-map"><a href="#EIGRP-Leak-map" class="headerlink" title="EIGRP Leak-map"></a>EIGRP Leak-map</h1><p>在eigrp发送汇总路由的同时也发送明细路由<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span>\<span class="number">#acc</span>ess-list <span class="number">1</span> permit <span class="number">2.2</span>.<span class="number">2.2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span>\<span class="selector-id">#route-map</span> cisco permit <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-route-map)</span></span>\<span class="selector-id">#match</span> ip <span class="selector-tag">address</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span>\<span class="selector-id">#int</span> s0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span>\<span class="selector-id">#ip</span> summary-<span class="selector-tag">address</span> eigrp <span class="number">100</span> <span class="number">2.2</span>.<span class="number">0.0</span> <span class="number">255.255</span>.<span class="number">0.0</span> leak-map cisco</span><br><span class="line"></span><br><span class="line">R1\<span class="selector-id">#show</span> ip route eigrp</span><br><span class="line"></span><br><span class="line"><span class="number">2.0</span>.<span class="number">0.0</span>/<span class="number">8</span> is variably subnetted, <span class="number">2</span> subnets, <span class="number">2</span> masks</span><br><span class="line"></span><br><span class="line">D <span class="number">2.2</span>.<span class="number">2.2</span>/<span class="number">32</span> [<span class="number">90</span>/<span class="number">2297856</span>] via <span class="number">192.168</span>.<span class="number">1.2</span>, <span class="number">00</span>:<span class="number">07</span>:<span class="number">10</span>, Serial0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line">D <span class="number">2.2</span>.<span class="number">0.0</span>/<span class="number">16</span> [<span class="number">90</span>/<span class="number">2297856</span>] via <span class="number">192.168</span>.<span class="number">1.2</span>, <span class="number">00</span>:<span class="number">10</span>:<span class="number">55</span>, Serial0/<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>EIGRP</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell script basic</title>
    <url>/2018/04/25/basic-shell-script/</url>
    <content><![CDATA[<h1 id="Shell脚本的用处"><a href="#Shell脚本的用处" class="headerlink" title="Shell脚本的用处"></a>Shell脚本的用处</h1><p>经常会在网上看到一些一键XXX脚本。例如一键LAMP,LNMP脚本。只需要执行简单的命令，然后跟着脚本提示操作就能够完成搭建一个简单的网站，带数据库后台和各种环境。Shell脚本可以帮助我们完成很多冗杂的工作，也可以通过编写shell脚本达到快速部署环境的目的。能够大大提高工作效率。类似windows里的.BAT文件。</p>
<h1 id="编写简单的Shell脚本"><a href="#编写简单的Shell脚本" class="headerlink" title="编写简单的Shell脚本"></a>编写简单的Shell脚本</h1><p>编写Shell脚本的方式非常简单。只需要使用常用的文本编辑器如VIM创建一个文件，然后在文件中输入命令即可。例如，如果想查看当前所在的工作路径并列出当前目录下所有文件及属性信息，实现这个功能的脚本就可以这么编写</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# vi example.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">this is a example <span class="keyword">for</span> shell script </span></span><br><span class="line">pwd</span><br><span class="line">ls -al</span><br></pre></td></tr></table></figure>
<p>那么一个个来解释这其中的含义吧</p>
<ul>
<li>第一行#!/bin/bash 代表脚本声明，即告诉系统使用哪种命令解释器执行这个脚本。</li>
<li>第二行#为注释信息。如果有学过C语言或者其他编程语言应该能很快了解。注释信息<strong>不会被执行</strong>。是对这个脚本功能的解释。方便他人查看脚本的时候知道这个脚本的功能。</li>
<li>后面的就是Linux的命令，就不再赘述了。另外。Linux<strong>不以后缀名分辨文件类型</strong>。也可以说Linux中没有后缀名的概念。所以脚本名字的.sh是一个约定俗成的规矩 表示这是一个可执行的脚本。</li>
</ul>
<p>一个写好的脚本文件可以通过bash去执行。结果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# bash example.sh </span><br><span class="line">/root</span><br><span class="line">total 556</span><br><span class="line">dr-xr-x---.  3 root root   4096 May  2 03:09 .</span><br><span class="line">drwxr-xr-x. 19 root root   4096 May  2 03:05 ..</span><br><span class="line">-rw-------.  1 root root    871 Mar  1 19:49 anaconda-ks.cfg</span><br><span class="line">-rw-------.  1 root root   7075 Apr 18 04:17 .bash_history</span><br><span class="line">-rw-r--r--.  1 root root     18 Dec 28  2013 .bash_logout</span><br><span class="line">-rw-r--r--.  1 root root    176 Dec 28  2013 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root root    176 Dec 28  2013 .bashrc</span><br><span class="line">-rw-r--r--.  1 root root    100 Dec 28  2013 .cshrc</span><br><span class="line">-rw-r--r--.  1 root root     60 May  2 03:09 example.sh</span><br><span class="line">-rw-r--r--.  1 root root 513076 Feb 28 04:36 GitPython-1.0.1-5.el7.noarch.rpm</span><br><span class="line">-rw-------.  1 root root     46 Mar  1 21:07 .lesshst</span><br><span class="line">drwxr-xr-x.  3 root root     36 Apr 17 06:01 mirrors.163.com</span><br><span class="line">-rw-r--r--.  1 root root    129 Dec 28  2013 .tcshrc</span><br><span class="line">-rw-------.  1 root root    808 Mar  1 21:24 .viminfo</span><br></pre></td></tr></table></figure>
<p>除了用bash这种方式执行之外，还可以使用<strong>“./”</strong>去执行。但是可能会报错提示权限不足。这边先使用chmod命令给脚本执行的权限。权限部分的知识在这暂且不提。在此只需要知道脚本的另一种执行方法就行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# ./example.sh</span><br><span class="line">-bash: ./example.sh: Permission denied</span><br><span class="line"></span><br><span class="line">[root@remilia ~]# chmod u+x example.sh </span><br><span class="line">[root@remilia ~]# ./example.sh </span><br><span class="line">/root</span><br><span class="line">total 556</span><br><span class="line">dr-xr-x---.  3 root root   4096 May  2 03:09 .</span><br><span class="line">drwxr-xr-x. 19 root root   4096 May  2 03:05 ..</span><br><span class="line">-rw-------.  1 root root    871 Mar  1 19:49 anaconda-ks.cfg</span><br><span class="line">-rw-------.  1 root root   7075 Apr 18 04:17 .bash_history</span><br><span class="line">-rw-r--r--.  1 root root     18 Dec 28  2013 .bash_logout</span><br><span class="line">-rw-r--r--.  1 root root    176 Dec 28  2013 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root root    176 Dec 28  2013 .bashrc</span><br><span class="line">-rw-r--r--.  1 root root    100 Dec 28  2013 .cshrc</span><br><span class="line">-rwxr--r--.  1 root root     60 May  2 03:09 example.sh</span><br><span class="line">-rw-r--r--.  1 root root 513076 Feb 28 04:36 GitPython-1.0.1-5.el7.noarch.rpm</span><br><span class="line">-rw-------.  1 root root     46 Mar  1 21:07 .lesshst</span><br><span class="line">drwxr-xr-x.  3 root root     36 Apr 17 06:01 mirrors.163.com</span><br><span class="line">-rw-r--r--.  1 root root    129 Dec 28  2013 .tcshrc</span><br><span class="line">-rw-------.  1 root root    808 Mar  1 21:24 .viminfo</span><br></pre></td></tr></table></figure>
<h2 id="接收用户的参数"><a href="#接收用户的参数" class="headerlink" title="接收用户的参数"></a>接收用户的参数</h2><p>上面这种简单的shell脚本只能执行一些预先定义好的功能。有时候需要接收用户的输入，才能更好的满足需求。</p>
<p>在Shell语言中，内设了用于接收参数的变量。变量之间可以用空格间隔。例如$0代表当前shell脚本程序的名称，$#对应的是总共有几个参数。、$*对应的是所有位置的参数值,$?对应的是上一个命令执行的返回值。$1 $2 $3 … $N代表第一个，第二个，第三个….第N个参数的值</p>
<a id="more"></a>
<p>尝试编写一个脚本程序示例，通过引用上面的变量参数来看下真实效果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# cat example.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo "当前脚本名称为$0"</span><br><span class="line">echo "总共有$#个参数,分别是$*"</span><br><span class="line">echo "第一个参数为$1,第五个为$5"</span><br><span class="line">[root@remilia ~]# bash example.sh 1 2 3 4 5</span><br><span class="line">当前脚本名称为example.sh</span><br><span class="line">总共有5个参数,分别是1 2 3 4 5</span><br><span class="line">第一个参数为1,第五个为5</span><br></pre></td></tr></table></figure>
<h2 id="判断用户的参数"><a href="#判断用户的参数" class="headerlink" title="判断用户的参数"></a>判断用户的参数</h2><p>系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回其他随机数值。条件测试语法的执行格式如下:</p>
<p>[ 条件表达式 ]注意两边<strong>一定要有空格</strong></p>
<p>按照测试对象来划分,条件测试语句可以分为4种</p>
<ul>
<li><p>文件测试语句</p>
</li>
<li><p>逻辑测试语句</p>
</li>
<li><p>整数值比较语句</p>
</li>
<li><p>字符串比较语句</p>
<p>文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符.具体参数如下:</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-d</td>
<td>测试文件是否为目录类型</td>
</tr>
<tr>
<td>-e</td>
<td>测试文件是否存在</td>
</tr>
<tr>
<td>-f</td>
<td>判断是否为一般文件</td>
</tr>
<tr>
<td>-r</td>
<td>测试当前用户是否有权限读取</td>
</tr>
<tr>
<td>-w</td>
<td>测试当前用户是否有权限写入</td>
</tr>
<tr>
<td>-x</td>
<td>测试当前用户是否有权限执行</td>
</tr>
</tbody>
</table>
</div>
<p>下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设<strong>$?</strong>变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着目录不存在：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# [ -d /etc/fstab ]</span><br><span class="line">[root@remilia ~]# echo $?</span><br><span class="line">1</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<p>再使用文件测试语句来判断/etc/fstab是否为一般文件，如果返回值为0，则代表文件存在，且为一般文件:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# [ -e /etc/fstab ]</span><br><span class="line">[root@remilia ~]# echo $?</span><br><span class="line">0</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>First contact with linux</title>
    <url>/2018/04/17/first-contact-with-linux/</url>
    <content><![CDATA[<h1 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h1><p>个人所用的是虚拟机环境,使用的是<strong>RHEL7</strong>。大体上应该没有什么太大的关系。机器是两张网卡，一张VMNET10一张VMNET1都是仅主机模式。使用<strong>SecureCRT</strong>进行连接操作。环境的搭建就不写了。</p>
<h1 id="必须掌握的几个Linux命令"><a href="#必须掌握的几个Linux命令" class="headerlink" title="必须掌握的几个Linux命令"></a>必须掌握的几个Linux命令</h1><h2 id="我们为什么要学习Linux的命令？"><a href="#我们为什么要学习Linux的命令？" class="headerlink" title="我们为什么要学习Linux的命令？"></a>我们为什么要学习Linux的命令？</h2><p>初学者上手Linux系统会很懵。不管你是否安装了图形化界面，或者去网上找一些教程。或者一些Linux的应用 总会看到密密麻麻的命令。很难得看懂，直接导致一些人放弃学习。这边简单用Windows举个例子吧。</p>
<a id="more"></a>
<p>​    例如在Windows中，我们总会打开<strong>我的电脑</strong>或者一些文件夹，能看到这样一种界面：</p>
<p><img src="/2018/04/17/first-contact-with-linux/1.PNG" alt="1"></p>
<p>这是windows比较友好的地方。这整个叫做<strong>图形化用户接口</strong>，简称<strong>GUI</strong>。我们可以通过双击某个分区来浏览里面的数据 比方说到D盘的VIDEO里找到Charlotte文件夹,能够看到我下好的动漫 直接双击就可以观看了。</p>
<p><img src="/2018/04/17/first-contact-with-linux/2.PNG" alt="2"></p>
<p>这整个过程可以理解为<strong>“你”</strong>在和<strong>“电脑”</strong>交互。你的鼠标双击告诉电脑要切换目录，于是电脑切换到该目录然后显示文件夹里的内容。</p>
<p>其实在Windows执行这些命令，也是一样的。我们来看一下。</p>
<p>打开CMD。一个黑乎乎的框框。在这里面我们可以输入命令 来达到同样的效果。</p>
<p><img src="/2018/04/17/first-contact-with-linux/3.PNG" alt="3"></p>
<p>没有任何区别 只是通过文字的方法显示出来 让人难免感觉有些别扭。</p>
<p>直接输入文件名回车就可以运行了。在很久以前的DOS系统想要玩仙剑奇侠传1就是这么弄的。只不过后来逐渐有了图形化界面。</p>
<p>而Linux系统其实也有很多版本是有桌面环境的。像国产的DEEPIN。国外的UBUNTU。我所用的RHEL其实也可以有桌面环境。但是对于服务器系统来说，桌面环境毕竟还是比较消耗资源的。而且真正用起来，大部分时候命令行还是比图形化界面方便。（前提是你用的比较熟）所以掌握Linux中的命令就显得尤为重要了。就像我们第一次使用电脑的时候，会先学着<strong>打开“我的电脑”</strong> 然后是<strong>安装软件</strong>，<strong>打开浏览器</strong>，<strong>下载软件</strong> 等等等等。在我们初学Linux的时候也是要学习一些基本操作。而这些基本操作都是用命令去完成的。</p>
<p>接下来一起看一下Linux中一些常用的操作需要哪些命令来完成吧。</p>
<blockquote>
<p>  注意：</p>
<p>  Linux里的每个命令有的必须带选项才能执行 有的可以不带选项执行。有的可以带多个选项。那么我们规定如下</p>
<ul>
<li><strong>粗体字</strong>表示实际需要输入的命令和关键字，在实际的配置示例和输出信息(不是一般的命令语法)中，粗体字表示你要手工输入的命令(比如<strong>echo</strong>命令)；</li>
<li><em>斜体字</em> 表示需要用实际数值替换的参数</li>
<li>竖线(|)表示在几个选项中选择一项</li>
<li>方括号[]表示可选的参数;</li>
<li>大括号{}表示一个必需的选项</li>
<li>方括号里面带一个大括号[{}]表示在一个可选项中的必选项。</li>
</ul>
</blockquote>
<h1 id="常用基本命令"><a href="#常用基本命令" class="headerlink" title="常用基本命令"></a>常用基本命令</h1><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><p>echo命令用于在屏幕上输出字符串或者变量提取后的值，格式为</p>
<p><strong>echo</strong> [<em>字符串</em>|$变量]</p>
<p>比方说想要在屏幕上显示你好。可以输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# echo hello</span><br><span class="line">hello</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<p>如果想要提取一个变量SHELL。则可以输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# echo $SHELL</span><br><span class="line">/bin/bash</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<p>我们可以暂时不用管这个SHELL是什么。看结果就可以。</p>
<p>在测试命令的时候我们尽量不要用中文吧。养成好习惯。</p>
<p>如果你输入<strong>echo 你好</strong> 可能会出现 <strong>echo ??</strong> 所以尽量使用英文</p>
<h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><p>如果你安装的是没有图形化界面的系统。你会注意到整个界面就像WINDOWS里的CMD一样。除了一个光标在不停闪烁可以说其他的什么都没有</p>
<p>如果想查看当前的系统时间怎么办呢。这个时候可以使用date命令。</p>
<p>格式为<strong>date</strong> “[选项] [+指定的格式]”</p>
<p>只需要在date命令中输入以“+”开头的参数,就可以按照指定的格式来输出系统的时间。</p>
<p>date常用的参数格式和作用如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">%t</td>
<td style="text-align:center">tab键</td>
</tr>
<tr>
<td style="text-align:center">%H</td>
<td style="text-align:center">小时(0~23)</td>
</tr>
<tr>
<td style="text-align:center">%I</td>
<td style="text-align:center">小时(0-12)</td>
</tr>
<tr>
<td style="text-align:center">%M</td>
<td style="text-align:center">分钟(0-59)</td>
</tr>
<tr>
<td style="text-align:center">%S</td>
<td style="text-align:center">秒(0-59)</td>
</tr>
<tr>
<td style="text-align:center">%j</td>
<td style="text-align:center">今年中的第几天</td>
</tr>
</tbody>
</table>
</div>
<p>比如按照默认的格式输出当前系统时间是这样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# date</span><br><span class="line">Tue Apr 17 03:45:33 EDT 2018</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<p>按照”年-月-日 小时:分钟:秒”的格式查看系统当前时间是这样的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# date "+%Y-%m-%d %H:%M:%S"</span><br><span class="line">2018-04-17 03:47:16</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<p>这边要说明一下Linux中每个命令都不尽相同。而且大部分命令都区分大小写。甚至有的时候%M 和 %m的意义都不一样。这个时候怎么办呢。</p>
<h2 id="man命令"><a href="#man命令" class="headerlink" title="man命令"></a>man命令</h2><p>man命令会显示某个命令的手册(manual)里面会告诉你每个参数都是什么意义。但是全是英文的。不过稍微有点基础的人都能看懂。学这个要是很抗拒英文的话是学不好的。</p>
<p>man命令的常用格式如下:</p>
<p><strong>man</strong> {<em>命令</em>}</p>
<p>如果直接输入man 则会显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# man</span><br><span class="line">What manual page do you want?</span><br></pre></td></tr></table></figure>
<p>他会直接问你想要获取什么的帮助手册。所以我认为直接man没有啥意义。</p>
<p>那么拿date来举例。如果想看date的每个参数都是什么意思的话，则输入以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# man date</span><br><span class="line">DATE(1)                          User Commands                         DATE(1)</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">       date - print or set the system date and time</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       date [OPTION]... [+FORMAT]</span><br><span class="line">       date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]]</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Display the current time in the given FORMAT, or set the system date.</span><br><span class="line"></span><br><span class="line">       Mandatory  arguments  to  long  options are mandatory for short options</span><br><span class="line">       too.</span><br><span class="line"></span><br><span class="line">       -d, --date=STRING</span><br><span class="line">              display time described by STRING, not 'now'</span><br><span class="line"></span><br><span class="line">       -f, --file=DATEFILE</span><br><span class="line">              like --date once for each line of DATEFILE</span><br><span class="line"></span><br><span class="line">       -I[TIMESPEC], --iso-8601[=TIMESPEC]</span><br><span class="line">              output date/time in ISO 8601 format.  TIMESPEC='date'  for  date</span><br><span class="line"> Manual page date(1) line 1 (press h for help or q to quit)</span><br></pre></td></tr></table></figure>
<p>这个手册内容太多了 一页显示不完。所以可以通过按下回车下翻一行，通过空格下翻一页。按q退出</p>
<p>稍微下翻一下以后会发现大量参数和说明。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FORMAT controls the output.  Interpreted sequences are:</span><br><span class="line"></span><br><span class="line">     %%     a literal %</span><br><span class="line"></span><br><span class="line">     %a     locale's abbreviated weekday name (e.g., Sun)</span><br><span class="line"></span><br><span class="line">     %A     locale's full weekday name (e.g., Sunday)</span><br><span class="line"></span><br><span class="line">     %b     locale's abbreviated month name (e.g., Jan)</span><br><span class="line"></span><br><span class="line">     %B     locale's full month name (e.g., January)</span><br><span class="line"></span><br><span class="line">     %c     locale's date and time (e.g., Thu Mar  3 23:05:25 2005)</span><br><span class="line"></span><br><span class="line">     %C     century; like %Y, except omit last two digits (e.g., 20)</span><br><span class="line"></span><br><span class="line">     %d     day of month (e.g., 01)</span><br><span class="line"></span><br><span class="line">     %D     date; same as %m/%d/%y</span><br><span class="line"></span><br><span class="line">     %e     day of month, space padded; same as %_d</span><br></pre></td></tr></table></figure>
<p>比方说这边有%d的解释 解释是 <strong>“day of month”</strong>翻译过来就算一个月的某一天。后面的<strong>(e.g., 01)</strong>其中的eg代表for example 也就是他给你的例子。比方说01</p>
<p>那么我们来试一下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# date "+%d"</span><br><span class="line">17</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<p>今天确实是17号。如果你稍微找一找就能发现<code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>这个可以有如下解释</p>
<ul>
<li><p>%Y     year</p>
</li>
<li><p>%m     month (01..12)</p>
</li>
<li><p>%d     day of month (e.g., 01)</p>
</li>
<li><p>%H     hour (00..23)</p>
</li>
<li><p>%M     minute (00..59)</p>
</li>
<li><p>%S     second (00..60)</p>
<p>以及你会发现一些其他的。类似：</p>
</li>
<li><p>%F     full date; same as %Y-%m-%d</p>
</li>
<li><p>%T     time; same as %H:%M:%S</p>
<p>虽然不太明白 但是这个意思好像是%F就等于%Y-%m-%d，然后%T就等于%H:%M:%S</p>
<p>那么我们的<code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>能不能写成<code>date &quot;+%F %T&quot;</code>呢。</p>
<p>试一下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# date "+%F %T"</span><br><span class="line">2018-04-17 04:07:19</span><br><span class="line">[root@remilia ~]# date "+%Y-%m-%d %H:%M:%S"</span><br><span class="line">2018-04-17 04:07:42</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ul>
<p>就结果来看 确实是一样的。这里应该是给了简写的方法。所以遇到陌生的命令可以尝试使用man去了解命令的基本用法。</p>
<h2 id="reboot命令"><a href="#reboot命令" class="headerlink" title="reboot命令"></a>reboot命令</h2><p>reboot命令用于重启系统，其格式为<strong>reboot</strong></p>
<p>由于重启计算机这种操作会涉及硬件资源的管理权限，因此默认只能使用root管理员来重启。</p>
<p>其命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# reboot</span><br></pre></td></tr></table></figure>
<p>回车之后就重启了。</p>
<h2 id="poweroff命令"><a href="#poweroff命令" class="headerlink" title="poweroff命令"></a>poweroff命令</h2><p>poweroff命令用于关闭系统,其格式为<strong>poweroff</strong></p>
<p>该命令与reboot命令相同，都会涉及硬件资源的管理权限，因此默认只有root管理员才可以关闭电脑，其命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# poweroff</span><br></pre></td></tr></table></figure>
<p>敲了就关机了</p>
<h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><p>wget命令用于下载网络中的文件。格式为 <strong>wget</strong> [参数]  {<em>下载地址</em>}</p>
<p>如果没有Linux系统的管理经验，当前只需了解一下wget命令的参数以及作用，然后看一下下面的演示实验即可，切记不要急于求成。后面章节将逐步讲解Linux系统的配置管理方法，可以等您掌握了网卡的配置方法后再来进行这个实验操作。下表所示为wget命令的参数以及参数的作用。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-b</td>
<td style="text-align:center">后台下载模式</td>
</tr>
<tr>
<td style="text-align:center">-P</td>
<td style="text-align:center">下载到指定目录</td>
</tr>
<tr>
<td style="text-align:center">-t</td>
<td style="text-align:center">最大尝试次数</td>
</tr>
<tr>
<td style="text-align:center">-c</td>
<td style="text-align:center">断点续传</td>
</tr>
<tr>
<td style="text-align:center">-p</td>
<td style="text-align:center">下载页面内所有资源，包括图片视频等</td>
</tr>
<tr>
<td style="text-align:center">-r</td>
<td style="text-align:center">递归下载</td>
</tr>
</tbody>
</table>
</div>
<p>例如，尝试使用wget命令下载163镜像站中的某个RPM包。这个文件完整路径为</p>
<p><a href="http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/GitPython-1.0.1-5.el7.noarch.rpm" target="_blank" rel="noopener">http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/GitPython-1.0.1-5.el7.noarch.rpm</a></p>
<p>命令如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# wget http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/GitPython-1.0.1-5.el7.noarch.rpm</span><br><span class="line">--2018-04-17 05:56:44--  http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/GitPython-1.0.1-5.el7.noarch.rpm</span><br><span class="line">Resolving mirrors.163.com (mirrors.163.com)... 59.111.0.251</span><br><span class="line">Connecting to mirrors.163.com (mirrors.163.com)|59.111.0.251|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 513076 (501K) [application/x-redhat-package-manager]</span><br><span class="line">Saving to: ‘GitPython-1.0.1-5.el7.noarch.rpm’</span><br><span class="line"></span><br><span class="line"><span class="meta">100%</span><span class="bash">[======================================&gt;] 513,076     1.82MB/s   <span class="keyword">in</span> 0.3s   </span></span><br><span class="line"></span><br><span class="line">2018-04-17 05:56</span><br></pre></td></tr></table></figure>
<p>接下来尝试用wget递归下载该镜像源力的某个文件夹里的所有数据，然后会保存在当前目录下mirros.163.com文件夹中。执行该操作的命令为</p>
<p>wget -r -p <a href="http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/repodata/" target="_blank" rel="noopener">http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/repodata/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# wget -r -p http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/repodata/</span><br><span class="line">--2018-04-17 06:01:35--  http://mirrors.163.com/centos/7/cloud/x86_64/openstack-queens/repodata/</span><br><span class="line">Resolving mirrors.163.com (mirrors.163.com)... 59.111.0.251</span><br><span class="line">Connecting to mirrors.163.com (mirrors.163.com)|59.111.0.251|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">省略下载过程</span><br></pre></td></tr></table></figure>
<h2 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h2><p>ps命令</p>
<p>ps命令用于查看系统中的进程状态，格式为<strong>ps</strong> [参数]</p>
<p>ps命令一般和管道符一起使用,用来抓取某个服务进程对应的PID值。在windows中可以使用<code>ctrl+shift+esc</code>呼出任务管理器。直接查看某个进程的PID。如图：</p>
<p><img src="/2018/04/17/first-contact-with-linux/4.PNG" alt=""></p>
<p>而Linux就需要通过命令来看了。常见的参数和作用如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">-a</td>
<td style="text-align:center">显示所有进程(包括其他用户)</td>
</tr>
<tr>
<td style="text-align:center">-u</td>
<td style="text-align:center">用户及其他详细信息</td>
</tr>
<tr>
<td style="text-align:center">-x</td>
<td style="text-align:center">显示没有终端控制的进程</td>
</tr>
</tbody>
</table>
</div>
<p>Linux系统中时刻运行着许多进程，如果能够合理地管理它们，则可以优化系统的性能。在Linux系统中，有5种常见的进程状态，分别为运行、中断、不可中断、僵死与停止，其各自含义如下所示。</p>
<ul>
<li>R(运行):进程正在运行或在运行队列中等待</li>
<li>S(中断):进程处于休眠。当某个条件形成后或者接收到信号的时候，则脱离休眠状态</li>
<li>D(不可中断):进程不响应系统异步信号,即使用kill也不能将其中断。</li>
<li>Z(僵死):进程已经终止,但进程描述符亦然存在，直到父进程调用wait4()系统函数后将进程释放</li>
<li>T(停止):进程收到停止信号后停止运行</li>
</ul>
<p>在执行 ps -aux之后会看到如下结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# ps -aux</span><br><span class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root          1  0.1  0.3  50796  7212 ?        Ss   02:45   0:01 /usr/lib/systemd/systemd --swi</span><br><span class="line">root          2  0.0  0.0      0     0 ?        S    02:45   0:00 [kthreadd]</span><br><span class="line">root          3  0.0  0.0      0     0 ?        S    02:45   0:00 [ksoftirqd/0]</span><br><span class="line">root          5  0.0  0.0      0     0 ?        S&lt;   02:45   0:00 [kworker/0:0H]</span><br><span class="line">root          7  0.0  0.0      0     0 ?        S    02:45   0:00 [migration/0]</span><br><span class="line">root          8  0.0  0.0      0     0 ?        S    02:45   0:00 [rcu_bh]</span><br><span class="line">root          9  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/0]</span><br><span class="line">root         10  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/1]</span><br><span class="line">root         11  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/2]</span><br><span class="line">root         12  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/3]</span><br><span class="line">root         13  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/4]</span><br><span class="line">root         14  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/5]</span><br><span class="line">root         15  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/6]</span><br><span class="line">root         16  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/7]</span><br><span class="line">root         17  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/8]</span><br><span class="line">root         18  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/9]</span><br><span class="line">root         19  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/10]</span><br><span class="line">root         20  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/11]</span><br><span class="line">root         21  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/12]</span><br><span class="line">root         22  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/13]</span><br><span class="line">root         23  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/14]</span><br><span class="line">root         24  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/15]</span><br><span class="line">root         25  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/16]</span><br><span class="line">root         26  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/17]</span><br><span class="line">root         27  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/18]</span><br><span class="line">root         28  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/19]</span><br><span class="line">root         29  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/20]</span><br><span class="line">root         30  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/21]</span><br><span class="line">root         31  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/22]</span><br><span class="line">root         32  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/23]</span><br><span class="line">root         33  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/24]</span><br><span class="line">root         34  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/25]</span><br><span class="line">root         35  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/26]</span><br><span class="line">root         36  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/27]</span><br><span class="line">root         37  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/28]</span><br><span class="line">root         38  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/29]</span><br><span class="line">root         39  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/30]</span><br><span class="line">root         40  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/31]</span><br><span class="line">root         41  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/32]</span><br><span class="line">root         42  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/33]</span><br><span class="line">root         43  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/34]</span><br><span class="line">root         44  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/35]</span><br><span class="line">root         45  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/36]</span><br><span class="line">root         46  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/37]</span><br><span class="line">root         47  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/38]</span><br><span class="line">root         48  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/39]</span><br><span class="line">root         49  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/40]</span><br><span class="line">root         50  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/41]</span><br><span class="line">root         51  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/42]</span><br><span class="line">root         52  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/43]</span><br><span class="line">root         53  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/44]</span><br><span class="line">root         54  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/45]</span><br><span class="line">root         55  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/46]</span><br><span class="line">root         56  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/47]</span><br><span class="line">root         57  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/48]</span><br><span class="line">root         58  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/49]</span><br><span class="line">root         59  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/50]</span><br><span class="line">root         60  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/51]</span><br><span class="line">root         61  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/52]</span><br><span class="line">root         62  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/53]</span><br><span class="line">root         63  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/54]</span><br><span class="line">root         64  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/55]</span><br><span class="line">root         65  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/56]</span><br><span class="line">root         66  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/57]</span><br><span class="line">root         67  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/58]</span><br><span class="line">root         68  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/59]</span><br><span class="line">root         69  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/60]</span><br><span class="line">root         70  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/61]</span><br><span class="line">root         71  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/62]</span><br><span class="line">root         72  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/63]</span><br><span class="line">root         73  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/64]</span><br><span class="line">root         74  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/65]</span><br><span class="line">root         75  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/66]</span><br><span class="line">root         76  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/67]</span><br><span class="line">root         77  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/68]</span><br><span class="line">root         78  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/69]</span><br><span class="line">root         79  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/70]</span><br><span class="line">root         80  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/71]</span><br><span class="line">root         81  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/72]</span><br><span class="line">root         82  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/73]</span><br><span class="line">root         83  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/74]</span><br><span class="line">root         84  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/75]</span><br><span class="line">root         85  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/76]</span><br><span class="line">root         86  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/77]</span><br><span class="line">root         87  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/78]</span><br><span class="line">root         88  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/79]</span><br><span class="line">root         89  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/80]</span><br><span class="line">root         90  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/81]</span><br><span class="line">root         91  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/82]</span><br><span class="line">root         92  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/83]</span><br><span class="line">root         93  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/84]</span><br><span class="line">root         94  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/85]</span><br><span class="line">root         95  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/86]</span><br><span class="line">root         96  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/87]</span><br><span class="line">root         97  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/88]</span><br><span class="line">root         98  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/89]</span><br><span class="line">root         99  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/90]</span><br><span class="line">root        100  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/91]</span><br><span class="line">root        101  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/92]</span><br><span class="line">root        102  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/93]</span><br><span class="line">root        103  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/94]</span><br><span class="line">root        104  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/95]</span><br><span class="line">root        105  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/96]</span><br><span class="line">root        106  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/97]</span><br><span class="line">root        107  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/98]</span><br><span class="line">root        108  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/99]</span><br><span class="line">root        109  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/100]</span><br><span class="line">root        110  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/101]</span><br><span class="line">root        111  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/102]</span><br><span class="line">root        112  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/103]</span><br><span class="line">root        113  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/104]</span><br><span class="line">root        114  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/105]</span><br><span class="line">root        115  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/106]</span><br><span class="line">root        116  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/107]</span><br><span class="line">root        117  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/108]</span><br><span class="line">root        118  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/109]</span><br><span class="line">root        119  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/110]</span><br><span class="line">root        120  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/111]</span><br><span class="line">root        121  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/112]</span><br><span class="line">root        122  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/113]</span><br><span class="line">root        123  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/114]</span><br><span class="line">root        124  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/115]</span><br><span class="line">root        125  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/116]</span><br><span class="line">root        126  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/117]</span><br><span class="line">root        127  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/118]</span><br><span class="line">root        128  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/119]</span><br><span class="line">root        129  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/120]</span><br><span class="line">root        130  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/121]</span><br><span class="line">root        131  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/122]</span><br><span class="line">root        132  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/123]</span><br><span class="line">root        133  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/124]</span><br><span class="line">root        134  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/125]</span><br><span class="line">root        135  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/126]</span><br><span class="line">root        136  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuob/127]</span><br><span class="line">root        137  0.0  0.0      0     0 ?        R    02:45   0:00 [rcu_sched]</span><br><span class="line">root        138  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/0]</span><br><span class="line">root        139  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/1]</span><br><span class="line">root        140  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/2]</span><br><span class="line">root        141  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/3]</span><br><span class="line">root        142  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/4]</span><br><span class="line">root        143  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/5]</span><br><span class="line">root        144  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/6]</span><br><span class="line">root        145  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/7]</span><br><span class="line">root        146  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/8]</span><br><span class="line">root        147  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/9]</span><br><span class="line">root        148  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/10]</span><br><span class="line">root        149  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/11]</span><br><span class="line">root        150  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/12]</span><br><span class="line">root        151  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/13]</span><br><span class="line">root        152  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/14]</span><br><span class="line">root        153  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/15]</span><br><span class="line">root        154  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/16]</span><br><span class="line">root        155  0.0  0.0      0     0 ?        S    02:45   0:00 [rcuos/17]</span><br><span class="line">省略部分输出...</span><br></pre></td></tr></table></figure>
<p>其中的一些参数意义如下表格</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>USER</strong></th>
<th><strong>PID</strong></th>
<th><strong>%CPU</strong></th>
<th><strong>%MEM</strong></th>
<th><strong>VSZ</strong></th>
<th><strong>RSS</strong></th>
<th><strong>TTY</strong></th>
<th><strong>STAT</strong></th>
<th><strong>START</strong></th>
<th><strong>TIME</strong></th>
<th><strong>COMMAND</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>进程的所有者</td>
<td>进程ID号</td>
<td>运算器占用率</td>
<td>内存占用率</td>
<td>虚拟内存使用量（单位是KB）</td>
<td>占用的固定内存量（单位是KB）</td>
<td>所在终端</td>
<td>进程  状态</td>
<td>被启动  的时间</td>
<td>实际使用  CPU的时间</td>
<td>命令名称与参数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="top命令"><a href="#top命令" class="headerlink" title="top命令"></a>top命令</h2><p>top命令用于动态地监视进程活动与系统负载信息等。其格式为<strong>top</strong></p>
<p>top命令非常强大。可以看作是Linux中的任务管理器。由于运行了top之后其中的数据会不断变换，这里只截取一次，实际是不停变化的。按q可退出。结果如下:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# top</span><br><span class="line">top - 03:02:24 up 16 min,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks: 418 total,   1 running, 417 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.0 us,  0.2 sy,  0.0 ni, 99.8 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem:   1870784 total,   285556 used,  1585228 free,      784 buffers</span><br><span class="line">KiB Swap:  2097148 total,        0 used,  2097148 free.    91104 cached Mem</span><br><span class="line"></span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                    </span><br><span class="line">   714 root      20   0       0      0      0 S   0.3  0.0   0:00.06 xfsaild/dm-0               </span><br><span class="line">     1 root      20   0   50796   7220   2484 S   0.0  0.4   0:01.42 systemd                    </span><br><span class="line">     2 root      20   0       0      0      0 S   0.0  0.0   0:00.02 kthreadd                   </span><br><span class="line">     3 root      20   0       0      0      0 S   0.0  0.0   0:00.00 ksoftirqd/0                </span><br><span class="line">     5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H               </span><br><span class="line">     7 root      rt   0       0      0      0 S   0.0  0.0   0:00.34 migration/0                </span><br><span class="line">     8 root      20   0       0      0      0 S   0.0  0.0   0:00.00 rcu_bh</span><br></pre></td></tr></table></figure>
<p>在如上的结果中，前5行为系统整体的统计信息。其所代表的含义如下</p>
<ul>
<li>第1行：系统时间、运行时间、登录终端数、系统负载（三个数值分别为1分钟、5分钟、15分钟内的平均值，数值越小意味着负载越低）。</li>
<li>第2行：进程总数、运行中的进程数、睡眠中的进程数、停止的进程数、僵死的进程数。</li>
<li>第3行：用户占用资源百分比、系统内核占用资源百分比、改变过优先级的进程资源百分比、空闲的资源百分比等。</li>
</ul>
<blockquote>
<p>  注:第3行中的数据均为CPU数据并以百分比格式显示，例如“97.1 id”意味着有97.1%的CPU处理器资源处于空闲。</p>
</blockquote>
<ul>
<li><p>第4行：物理内存总量、内存使用量、内存空闲量、作为内核缓存的内存量。</p>
</li>
<li><p>第5行：虚拟内存总量、虚拟内存使用量、虚拟内存空闲量、已被提前加载的内存量。</p>
</li>
</ul>
<h2 id="pidof命令"><a href="#pidof命令" class="headerlink" title="pidof命令"></a>pidof命令</h2><p>pidof命令用于查询某个指定服务进程的PID值，格式为“<strong>pidof</strong> {[参数][<em>服务名称</em>]}”。<br>每个进程的进程号码值（PID）是唯一的，因此可以通过PID来区分不同的进程。例如，可以使用如下命令来查询本机上sshd服务程序的PID：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# pidof sshd</span><br><span class="line">2156</span><br></pre></td></tr></table></figure></p>
<h2 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h2><p>kill命令用于终止某个指定PID的服务进程，格式为“<strong>kill</strong> [参数][<em>进程PID</em>]”。<br>接下来，我们使用kill命令把上面用pidof命令查询到的PID所代表的进程终止掉，其命令如下所示。这种操作的效果等同于强制停止sshd服务。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# kill 2156</span><br></pre></td></tr></table></figure></p>
<h2 id="killall命令"><a href="#killall命令" class="headerlink" title="killall命令"></a>killall命令</h2><p>killall命令用于终止某个指定名称的服务所对应的全部进程，格式为：“<strong>killall</strong> [参数][<em>进程名称</em>]”。<br>通常来讲，复杂软件的服务程序会有多个进程协同为用户提供服务，如果逐个去结束这些进程会比较麻烦，此时可以使用killall命令来批量结束某个服务程序带有的全部进程。下面以httpd服务程序为例，来结束其全部进程。由于RHEL7系统默认没有安装httpd服务程序，因此此时只需看操作过程和输出结果即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# pidof httpd</span><br><span class="line">13581 13580 13579 13578 13577 13576</span><br><span class="line">[root@remilia ~]# killall httpd</span><br><span class="line">[root@remilia ~]# pidof httpd</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<blockquote>
<p>  注：    </p>
<p>  如果我们在系统终端中执行一个命令后想立即停止它，可以同时按下Ctrl + C组合键（生产环境中比较常用的一个快捷键），这样将立即终止该命令的进程。或者，如果有些命令在执行时不断地在屏幕上输出信息，影响到后续命令的输入，则可以在执行命令时在末尾添加上一个&amp;符号，这样命令将进入系统后台来执行。</p>
</blockquote>
<h1 id="系统状态检测命令"><a href="#系统状态检测命令" class="headerlink" title="系统状态检测命令"></a>系统状态检测命令</h1><p>作为一名合格的运维人员，想要更快、更好地了解Linux服务器，必须具备快速查看Linux系统运行状态的能力，因此接下来会逐个说明与网卡网络、系统内核、系统负载、内存使用情况、当前启用终端数量、历史登录记录、命令执行记录以及救援诊断等相关命令的使用方法。这些命令都超级实用。是必须掌握的命令。</p>
<h2 id="ifconfig命令"><a href="#ifconfig命令" class="headerlink" title="ifconfig命令"></a>ifconfig命令</h2><p>ifconfig命令用于获取网卡配置与网络状态等信息，格式为“<strong>ifconfig</strong> [网络设备][参数]”。</p>
<p>使用ifconfig命令来查看本机当前的网卡配置与网络状态等信息时，其实主要查看的就是网卡名称、inet参数后面的IP地址、ether参数后面的网卡物理地址（又称为MAC地址），以及RX、TX的接收数据包与发送数据包的个数及累计流量：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# ifconfig</span><br><span class="line"></span><br><span class="line">eno16777728: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line"></span><br><span class="line">        inet 192.168.10.10  netmask 255.255.255.0  broadcast 192.168.10.255</span><br><span class="line"></span><br><span class="line">        inet6 fe80::20c:29ff:fec4:a409  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line"></span><br><span class="line">        ether 00:0c:29:c4:a4:09  txqueuelen 1000  (Ethernet)</span><br><span class="line"></span><br><span class="line">        RX packets 36  bytes 3176 (3.1 KiB)</span><br><span class="line"></span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line"></span><br><span class="line">        TX packets 38  bytes 4757 (4.6 KiB)</span><br><span class="line"></span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line"></span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line"></span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line"></span><br><span class="line">        loop  txqueuelen 0  (Local Loopback)</span><br><span class="line"></span><br><span class="line">        RX packets 386  bytes 32780 (32.0 KiB)</span><br><span class="line"></span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line"></span><br><span class="line">        TX packets 386  bytes 32780 (32.0 KiB)</span><br><span class="line"></span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>
<h2 id="uname命令"><a href="#uname命令" class="headerlink" title="uname命令"></a>uname命令</h2><p>uname命令用于查看系统内核与系统版本等信息，格式为“<strong>uname</strong> [-a]”。</p>
<p>在使用uname命令时，一般会固定搭配上-a参数来完整地查看当前系统的内核名称、主机名、内核发行版本、节点名、系统时间、硬件名称、硬件平台、处理器类型以及操作系统名称等信息。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# uname -a</span><br><span class="line">Linux remilia.com 3.10.0-123.el7.x86_64 #1 SMP Mon May 5 11:16:57 EDT 2017 </span><br><span class="line">x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>
<p>顺带一提，如果要查看当前系统版本的详细信息，则需要查看redhat-release文件，其命令以及相应的结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# cat /etc/redhat-release</span><br><span class="line">Red Hat Enterprise Linux Server release 7.0 (Maipo)</span><br></pre></td></tr></table></figure>
<h2 id="free命令"><a href="#free命令" class="headerlink" title="free命令"></a>free命令</h2><p>free用于显示当前系统中内存的使用量信息，格式为“<strong>free</strong> [-h]”。</p>
<p>为了保证Linux系统不会因资源耗尽而突然宕机，运维人员需要时刻关注内存的使用量。在使用free命令时，可以结合使用-h参数以更人性化的方式输出当前内存的实时使用量信息。表2-8所示为在的电脑上执行free -h命令之后的输出信息。需要注意的是，输出信息中的中文注释是额外添加的内容，实际输出时没有相应的参数解释。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>内存总量</th>
<th>已用量</th>
<th>可用量</th>
<th>进程共享的内存量</th>
<th>磁盘缓存的内存量</th>
<th>缓存的  内存量</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>total</td>
<td>used</td>
<td>free</td>
<td>shared</td>
<td>buffers</td>
<td>cached</td>
</tr>
<tr>
<td>Mem</td>
<td>1.8GB</td>
<td>1.3GB</td>
<td>542MB</td>
<td>9.8MB</td>
<td>1.6MB</td>
<td>413MB</td>
</tr>
<tr>
<td>-/+ buffers/cache</td>
<td></td>
<td>869MB</td>
<td>957MB</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Swap</td>
<td>2.0GB</td>
<td>0</td>
<td>2.0GB</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h2 id="who命令"><a href="#who命令" class="headerlink" title="who命令"></a>who命令</h2><p>who用于查看当前登入主机的用户终端信息，格式为“<strong>who</strong> [参数]”。</p>
<p>这三个简单的字母可以快速显示出所有正在登录本机的用户的名称以及他们正在开启的终端信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# who</span><br></pre></td></tr></table></figure>
<p>​                                                     执行who命令的结果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>登录的用户名</th>
<th>终端设备</th>
<th>登录到系统的时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>root</td>
<td>:0</td>
<td>2018-04-24 17:52  (:0)</td>
</tr>
<tr>
<td>root</td>
<td>pts/0</td>
<td>2018-04-24 17:52  (:0)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="last命令"><a href="#last命令" class="headerlink" title="last命令"></a>last命令</h2><p>last命令用于查看所有系统的登录记录，格式为“<strong>last</strong> [参数]”。</p>
<p>使用last命令可以查看本机的登录记录。但是，由于这些信息都是以日志文件的形式保存在系统中，因此入侵者可以很容易地对内容进行篡改。千万不要单纯以该命令的输出信息而判断系统有无被恶意入侵！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# last</span><br><span class="line">root       pts/0       :0               Mon Aug  24 17:52   still  logged in</span><br><span class="line">root       :0          :0               Mon Aug  24 17:52   still  logged in</span><br><span class="line">(unknown   :0          :0               Mon Aug  24 17:50 - 17:52   (00:02)</span><br><span class="line">reboot     system boot 3.10.0-123.el7.x Tue Aug  25 01:49 - 18:17   (-7:-32)</span><br><span class="line">root       pts/0       :0               Mon Aug  24 15:40 - 08:54   (7+17:14)</span><br><span class="line">root       pts/0       :0               Fri Jul  10 10:49 - 15:37   (45+04:47)</span><br><span class="line">………………省略部分登录信息………………</span><br></pre></td></tr></table></figure>
<h2 id="history命令"><a href="#history命令" class="headerlink" title="history命令"></a>history命令</h2><p>history命令用于显示历史执行过的命令，格式为“<strong>history</strong> [-c]”。</p>
<p>执行history命令能显示出当前用户在本地计算机中执行过的最近1000条命令记录。如果觉得1000不够用，还可以自定义/etc/profile文件中的HISTSIZE变量值。在使用history命令时，如果使用-c参数则会清空所有的命令历史记录。还可以使用“!编码数字”的方式来重复执行某一次的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# history</span><br><span class="line">1 tar xzvf VMwareTools-9.9.0-2304977.tar.gz</span><br><span class="line">2 cd vmware-tools-distrib/</span><br><span class="line">3 ls</span><br><span class="line">4 ./vmware-install.pl -d</span><br><span class="line">5 reboot</span><br><span class="line">6 df -h</span><br><span class="line">7 cd /run/media/</span><br><span class="line">8 ls</span><br><span class="line">9 cd root/</span><br><span class="line">10 ls</span><br><span class="line">11 cd VMware\ Tools/</span><br><span class="line">12 ls</span><br><span class="line">13 cp VMwareTools-9.9.0-2304977.tar.gz /home</span><br><span class="line">14 cd /home</span><br><span class="line">15 ls</span><br><span class="line">16 tar xzvf VMwareTools-9.9.0-2304977.tar.gz</span><br><span class="line">17 cd vmware-tools-distrib/</span><br><span class="line">18 ls</span><br><span class="line">19 ./vmware-install.pl -d</span><br><span class="line">20 reboot</span><br><span class="line">21 history</span><br><span class="line">[root@remilia ~]# !15</span><br><span class="line">anaconda-ks.cfg  Documents  initial-setup-ks.cfg  Pictures  Templates</span><br><span class="line">Desktop          Downloads  Music                 Public    Videos</span><br></pre></td></tr></table></figure>
<p>历史命令会被保存到用户家目录中的.bash_history文件中。Linux系统中以点（.）开头的文件均代表隐藏文件，这些文件大多数为系统服务文件，可以用cat命令查看其文件内容。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# cat ~/.bash_history</span><br></pre></td></tr></table></figure>
<p>要清空当前用户在本机上执行的Linux命令历史记录信息，可执行如下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# history -c</span><br></pre></td></tr></table></figure>
<h2 id="sosreport命令"><a href="#sosreport命令" class="headerlink" title="sosreport命令"></a>sosreport命令</h2><p>sosreport命令用于收集系统配置及架构信息并输出诊断文档，格式为sosreport。</p>
<p>当Linux系统出现故障需要联系技术支持人员时，大多数时候都要先使用这个命令来简单收集系统的运行状态和服务配置信息，以便让技术支持人员能够远程解决一些小问题，亦或让他们能提前了解某些复杂问题。在下面的输出信息中，加粗的部分是收集好的资料压缩文件以及校验码，将其发送给技术支持人员即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# sosreport</span><br><span class="line">sosreport (version 3.0)</span><br><span class="line">This command will collect diagnostic and configuration information from</span><br><span class="line">this Red Hat Enterprise Linux system and installed applications.</span><br><span class="line"></span><br><span class="line">An archive containing the collected information will be generated in</span><br><span class="line">/var/tmp and may be provided to a Red Hat support representative.</span><br><span class="line">Any information provided to Red Hat will be treated in accordance with</span><br><span class="line">the published support policies at:</span><br><span class="line">https://access.redhat.com/support/</span><br><span class="line">The generated archive may contain data considered sensitive and its</span><br><span class="line">content should be reviewed by the originating organization before being</span><br><span class="line">passed to any third party.</span><br><span class="line"></span><br><span class="line">No changes will be made to system configuration.</span><br><span class="line">Press ENTER to continue, or CTRL-C to quit. 此处敲击回车来确认收集信息</span><br><span class="line"></span><br><span class="line">Please enter your first initial and last name [remilia.com]: 此处敲击回车来确认主机编号</span><br><span class="line">Please enter the case number that you are generating this report for: 此处敲击回车来确认主机编号</span><br><span class="line"></span><br><span class="line">Running plugins. Please wait ...</span><br><span class="line">Running 70/70: yum...</span><br><span class="line">Creating compressed archive...</span><br><span class="line">Your sosreport has been generated and saved in:</span><br><span class="line"></span><br><span class="line">/var/tmp/sosreport-remilia.com-20170905230631.tar.xz</span><br><span class="line">The checksum is: 79436cdf791327040efde48c452c6322</span><br><span class="line">Please send this file to your support representative.</span><br></pre></td></tr></table></figure>
<h1 id="工作目录切换命令"><a href="#工作目录切换命令" class="headerlink" title="工作目录切换命令"></a>工作目录切换命令</h1><p>工作目录指的是用户当前在系统中所处的位置。由于工作目录会牵涉系统存储结构相关的知识，因此后面将详细讲解这部分内容。现在只需简单了解一下这里的操作实验即可，如果不能完全掌握也没有关系，毕竟Linux系统的知识体系太过庞大，每一位初学人员都需要经历这么一段时期。</p>
<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><p>pwd命令用于显示用户当前所处的工作目录，格式为“<strong>pwd</strong> [选项]”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia etc]# pwd</span><br><span class="line">/etc</span><br></pre></td></tr></table></figure>
<h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><p>cd命令用于切换工作路径，格式为<strong>cd</strong> [目录名称]</p>
<p>这个命令应该是最常用的一个Linux命令了。可以通过cd命令迅速、灵活地切换到不同的工作目录。除了常见的切换目录方式，还可以使用“cd -”命令返回到上一次所处的目录，使用“cd..”命令进入上级目录，以及使用“cd ~”命令切换到当前用户的家目录，亦或使用“cd ~username”切换到其他用户的家目录。例如，可以使用“cd 路径”的方式切换进<strong>/etc</strong>目录中和<strong>/bin</strong>目录中,如果想返回上次切换的目录还可以通过<strong>“cd -”</strong>来实现。若想快速切换到当前用户家目录 可以通过<strong>cd ~</strong>实现</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia bin]# cd /etc/</span><br><span class="line">[root@remilia etc]# cd /bin</span><br><span class="line">[root@remilia bin]# cd -</span><br><span class="line">/etc</span><br><span class="line">[root@remilia etc]# cd ~</span><br><span class="line">[root@remilia ~]#</span><br></pre></td></tr></table></figure>
<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><p>ls命令用于显示目录中的文件信息，格式为<strong>“ls [选项] [文件] “</strong></p>
<p>所处的工作目录不同，当前工作目录的文件也不同。使用<strong>-a</strong>参数可以看到所有文件（包括隐藏的文件）。使用<strong>“-l”</strong>参数可以查看文件属性，大小等详细信息。将这两个结合起来就像这样</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# ls -al</span><br><span class="line">total 556</span><br><span class="line">dr-xr-x---.  3 root root   4096 May  2 03:09 .</span><br><span class="line">drwxr-xr-x. 19 root root   4096 May  2 03:05 ..</span><br><span class="line">-rw-------.  1 root root    871 Mar  1 19:49 anaconda-ks.cfg</span><br><span class="line">-rw-------.  1 root root   7158 May  2 03:56 .bash_history</span><br><span class="line">-rw-r--r--.  1 root root     18 Dec 28  2013 .bash_logout</span><br><span class="line">-rw-r--r--.  1 root root    176 Dec 28  2013 .bash_profile</span><br><span class="line">-rw-r--r--.  1 root root    176 Dec 28  2013 .bashrc</span><br><span class="line">-rw-r--r--.  1 root root    100 Dec 28  2013 .cshrc</span><br><span class="line">-rwxr--r--.  1 root root     60 May  2 03:09 example.sh</span><br><span class="line">-rw-r--r--.  1 root root 513076 Feb 28 04:36 GitPython-1.0.1-5.el7.noarch.rpm</span><br><span class="line">-rw-------.  1 root root     46 Mar  1 21:07 .lesshst</span><br><span class="line">drwxr-xr-x.  3 root root     36 Apr 17 06:01 mirrors.163.com</span><br><span class="line">-rw-r--r--.  1 root root    129 Dec 28  2013 .tcshrc</span><br><span class="line">-rw-------.  1 root root    808 Mar  1 21:24 .viminfo</span><br></pre></td></tr></table></figure>
<p>如果想查看某个目录的属性信息。就要加上-d参数。例如查看/etc的目录权限和属性信息:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# ls -ld /etc/</span><br><span class="line">drwxr-xr-x. 77 root root 8192 May  2 03:05 /etc/</span><br></pre></td></tr></table></figure>
<h1 id="文件文本编辑命令"><a href="#文件文本编辑命令" class="headerlink" title="文件文本编辑命令"></a>文件文本编辑命令</h1><p>在Linux中，有着著名的<strong>“一切皆文件”</strong>的说法。而对服务程序进行配置自然也就是编辑程序的配置文件。本节将讲解几条用于查看文本文件内容的命令。至于编辑器使用起来比较复杂，因此将放到第4章与Shell脚本内容一起讲解。</p>
<h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><p>cat命令用于查看纯文本文件（内容较少的），格式为“<strong>cat</strong> [选项] {文件}”。</p>
<p>Linux系统中有多个用于查看文本内容的命令，每个命令都有自己的特点，比如这个cat命令就是用于查看内容较少的纯文本文件的。</p>
<p>如果在查看文本的时候顺便还想显示行号的话。可以加上-n参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# cat -n anaconda-ks.cfg </span><br><span class="line">     1  #version=RHEL7</span><br><span class="line">     2  # System authorization information</span><br><span class="line">     3  auth --enableshadow --passalgo=sha512</span><br><span class="line">     4</span><br><span class="line">     5  # Use CDROM installation media</span><br><span class="line">     6  cdrom</span><br><span class="line">     7  # Run the Setup Agent on first boot</span><br><span class="line">     8  firstboot --enable</span><br><span class="line">     9  ignoredisk --only-use=sda</span><br><span class="line">    10  # Keyboard layouts</span><br><span class="line">    11  keyboard --vckeymap=us --xlayouts='us'</span><br><span class="line">    12  # System language</span><br><span class="line">    13  lang en_US.UTF-8</span><br><span class="line">    14</span><br><span class="line">    15  # Network information</span><br><span class="line">    16  network  --bootproto=dhcp --device=eno16777736 --ipv6=auto --activate</span><br><span class="line">    17  network  --bootproto=dhcp --device=eno33554960 --onboot=off --ipv6=auto</span><br><span class="line">    18  network  --hostname=remilia</span><br><span class="line">    19  # Root password</span><br><span class="line">    20  rootpw --iscrypted $6$4nqD7ZOlxIeZbUyb$K6./B9FtCU4481YL713K50c40xuHJlglpsv2zFfF7YKY6dXYMoYiDr4blyjNl0Kqekxa6rkonWIT7MxFYPxJL.</span><br><span class="line">    21  # System timezone</span><br><span class="line">    22  timezone America/New_York --isUtc</span><br><span class="line">    23  # System bootloader configuration</span><br><span class="line">    24  bootloader --location=mbr --boot-drive=sda</span><br><span class="line">    25  autopart --type=lvm</span><br><span class="line">    26  # Partition clearing information</span><br><span class="line">    27  clearpart --none --initlabel </span><br><span class="line">    28</span><br><span class="line">    29  %packages</span><br><span class="line">    30  @core</span><br><span class="line">    31</span><br><span class="line">    32  %end</span><br><span class="line">    33</span><br></pre></td></tr></table></figure>
<h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><p>more命令用于查看纯文本文件（内容较多的），格式为“<strong>more</strong> [选项] {文件}”。</p>
<p>如果需要阅读长篇小说或者非常长的配置文件，那么cat就真的不适合了。因为一旦使用cat命令阅读长篇的文本内容，信息就会在屏幕上快速翻滚，导致自己还没有来得及看到，内容就已经翻篇了。因此对于长篇的文本内容，推荐使用more命令来查看。more命令会在最下面使用百分比的形式来提示你已经阅读了多少内容。你还可以使用空格键或回车键向下翻页：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# more anaconda-ks.cfg </span><br><span class="line"><span class="meta">#</span><span class="bash">version=RHEL7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use CDROM installation media</span></span><br><span class="line">cdrom</span><br><span class="line"><span class="meta">#</span><span class="bash"> Run the Setup Agent on first boot</span></span><br><span class="line">firstboot --enable</span><br><span class="line">ignoredisk --only-use=sda</span><br><span class="line"><span class="meta">#</span><span class="bash"> Keyboard layouts</span></span><br><span class="line">keyboard --vckeymap=us --xlayouts='us'</span><br><span class="line"><span class="meta">#</span><span class="bash"> System language</span></span><br><span class="line">lang en_US.UTF-8</span><br><span class="line"><span class="meta">--More--(34%</span><span class="bash">)</span></span><br></pre></td></tr></table></figure>
<h2 id="head命令"><a href="#head命令" class="headerlink" title="head命令"></a>head命令</h2><p>head命令用于查看格式为“<strong>head</strong>[选项] {文件}。</p>
<p>在阅读文本内容时，谁也难以保证会按照从头到尾的顺序往下看完整个文件。如果只想查看文本中前5行的内容，该怎么办呢？head命令可以派上用场了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@remilia ~]# head -n 5 anaconda-ks.cfg </span><br><span class="line"><span class="meta">#</span><span class="bash">version=RHEL7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> System authorization information</span></span><br><span class="line">auth --enableshadow --passalgo=sha512</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Use CDROM installation media</span></span><br></pre></td></tr></table></figure>
<h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><p>tail命令用于查看纯文本文档的后N行或持续刷新内容，格式为“<strong>tai</strong>l [选项] {文件}”。</p>
<p>我们可能还会遇到另外一种情况，比如需要查看文本内容的最后20行，这时就需要用到tail命令了。tail命令的操作方法与head命令非常相似，只需要执行“tail -n 20 文件名”命令就可以达到这样的效果。tail命令最强悍的功能是可以持续刷新一个文件的内容，当想要实时查看最新日志文件时，这特别有用，此时的命令格式为“<strong>tail</strong> -f {文件名}”：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# tail -f /var/log/messages </span><br><span class="line">May 15 09:34:30 Remilia chronyd[969]: System clock wrong by 0.777201 seconds, adjustment started</span><br><span class="line">May 15 09:34:30 Remilia chronyd[969]: Out of order sample detected, discarding history for 5.79.108.34</span><br><span class="line">May 15 09:34:30 Remilia chronyd[969]: Can't synchronise: no reachable sources</span><br><span class="line">May 15 09:34:30 Remilia chronyd[969]: Selected source 85.199.214.101</span><br><span class="line">May 15 09:34:30 Remilia chronyd[969]: Out of order sample detected, discarding history for 85.199.214.101</span><br><span class="line">May 15 09:34:30 Remilia chronyd[969]: Can't synchronise: no reachable sources</span><br><span class="line">May 15 09:34:33 Remilia chronyd[969]: Selected source 108.59.2.24</span><br><span class="line">May 15 09:34:42 Remilia systemd-logind: New session 2 of user root.</span><br><span class="line">May 15 09:34:42 Remilia systemd: Starting Session 2 of user root.</span><br><span class="line">May 15 09:34:42 Remilia systemd: Started Session 2 of user root.</span><br></pre></td></tr></table></figure>
<h2 id="tr命令"><a href="#tr命令" class="headerlink" title="tr命令"></a>tr命令</h2><p>tr命令用于替换文本文件中的字符，格式为“<strong>tr</strong> {原始字符} {目标字符}”。</p>
<p>在很多时候，我们想要快速地替换文本中的一些词汇，又或者把整个文本内容都进行替换，如果进行手工替换，难免工作量太大，尤其是需要处理大批量的内容时，进行手工替换更是不现实。这时，就可以先使用cat命令读取待处理的文本，然后通过管道符把这些文本内容传递给tr命令进行替换操作即可。例如，把某个文本内容中的英文全部替换为大写：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# cat anaconda-ks.cfg | tr [a-z] [A-Z]</span><br><span class="line"><span class="meta">#</span><span class="bash">VERSION=RHEL7</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SYSTEM AUTHORIZATION INFORMATION</span></span><br><span class="line">AUTH --ENABLESHADOW --PASSALGO=SHA512</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> USE CDROM INSTALLATION MEDIA</span></span><br><span class="line">CDROM</span><br><span class="line"><span class="meta">#</span><span class="bash"> RUN THE SETUP AGENT ON FIRST BOOT</span></span><br><span class="line">FIRSTBOOT --ENABLE</span><br><span class="line">IGNOREDISK --ONLY-USE=SDA</span><br><span class="line"><span class="meta">#</span><span class="bash"> KEYBOARD LAYOUTS</span></span><br><span class="line">KEYBOARD --VCKEYMAP=US --XLAYOUTS='US'</span><br><span class="line"><span class="meta">#</span><span class="bash"> SYSTEM LANGUAGE</span></span><br><span class="line">LANG EN_US.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> NETWORK INFORMATION</span></span><br><span class="line">NETWORK --BOOTPROTO=DHCP --DEVICE=ENO16777728 --ONBOOT=OFF --IPV6=AUTO</span><br><span class="line">NETWORK --HOSTNAME=LOCALHOST.LOCALDOMAIN</span><br><span class="line"><span class="meta">#</span><span class="bash"> ROOT PASSWORD</span></span><br><span class="line">ROOTPW --ISCRYPTED $6$PDJJF42G8C6PL069$II.PX/YFAQPO0ENW2PA7MOMKJLYOAE2ZJMZ2UZJ7</span><br><span class="line">BH3UO4OWTR1.WK/HXZ3XIGMZGJPCS/MGPYSSOI8HPCT8B/</span><br><span class="line"><span class="meta">#</span><span class="bash"> SYSTEM TIMEZONE</span></span><br><span class="line">TIMEZONE AMERICA/NEW_YORK --ISUTC</span><br><span class="line">USER --NAME=LINUXPROBE --PASSWORD=$6$A9V3INSTNBWEIR7D$JEGFYWBCDOOOKJ9SODECCDO.</span><br><span class="line">ZLF4OSH2AZ2SS2R05B6LZ2A0V2K.RJWSBALL2FEKQVGF640OA/TOK6J.7GUTO/ --ISCRYPTED --</span><br><span class="line">GECOS="LINUXPROBE"</span><br><span class="line"><span class="meta">#</span><span class="bash"> X WINDOW SYSTEM CONFIGURATION INFORMATION</span></span><br><span class="line">XCONFIG --STARTXONBOOT</span><br><span class="line"><span class="meta">#</span><span class="bash"> SYSTEM BOOTLOADER CONFIGURATION</span></span><br><span class="line">BOOTLOADER --LOCATION=MBR --BOOT-DRIVE=SDA</span><br><span class="line">AUTOPART --TYPE=LVM</span><br><span class="line"><span class="meta">#</span><span class="bash"> PARTITION CLEARING INFORMATION</span></span><br><span class="line">CLEARPART --NONE --INITLABEL </span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">PACKAGES</span></span><br><span class="line">@BASE</span><br><span class="line">@CORE</span><br><span class="line">@DESKTOP-DEBUGGING</span><br><span class="line">@DIAL-UP</span><br><span class="line">@FONTS</span><br><span class="line">@GNOME-DESKTOP</span><br><span class="line">@GUEST-AGENTS</span><br><span class="line">@GUEST-DESKTOP-AGENTS</span><br><span class="line">@INPUT-METHODS</span><br><span class="line">@INTERNET-BROWSER</span><br><span class="line">@MULTIMEDIA</span><br><span class="line">@PRINT-CLIENT</span><br><span class="line">@X11</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash">END</span></span><br></pre></td></tr></table></figure>
<h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><p>wc命令用于统计指定文本的行数、字数、字节数，格式为“<strong>wc</strong> [参数] {文本}”。</p>
<p>wc的参数以及作用:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-l</td>
<td>只显示行数</td>
</tr>
<tr>
<td>-w</td>
<td>只显示单词数</td>
</tr>
<tr>
<td>-c</td>
<td>只显示字节数</td>
</tr>
</tbody>
</table>
</div>
<p>在Linux系统中，passwd是用于保存系统账户信息的文件，要统计当前系统中有多少个用户，可以使用下面的命令来进行查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# wc -l /etc/passwd</span><br><span class="line">38 /etc/passwd</span><br></pre></td></tr></table></figure>
<h2 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h2><p>stat命令用于查看文件的具体存储信息和时间等信息，格式为“<strong>stat</strong> {文件名称}”。</p>
<p>stat命令可以用于查看文件的存储信息和时间等信息，命令<code>stat anaconda-ks.cfg</code>会显示出文件的三种时间状态：Access、Modify、Change。这三种时间的区别将在下面的touch命令中详细详解：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# stat anaconda-ks.cfg </span><br><span class="line">  File: ‘anaconda-ks.cfg’</span><br><span class="line">  Size: 922             Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd00h/64768d    Inode: 67919995    Links: 1</span><br><span class="line">Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Context: system_u:object_r:admin_home_t:s0</span><br><span class="line">Access: 2018-02-27 09:06:00.730409939 +0800</span><br><span class="line">Modify: 2018-02-27 09:06:00.731424138 +0800</span><br><span class="line">Change: 2018-02-27 09:06:00.732438336 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">[root@Remilia ~]#</span><br></pre></td></tr></table></figure>
<h2 id="cut命令"><a href="#cut命令" class="headerlink" title="cut命令"></a>cut命令</h2><p>cut命令用于按“列”提取文本字符，格式为“<strong>cut</strong> [参数] {文本}”。</p>
<p>在Linux系统中，如何准确地提取出最想要的数据，这也是我们应该重点学习的内容。一般而言，按基于<strong>“行”</strong>的方式来提取数据是比较简单的，只需要设置好要搜索的关键词即可。但是如果按列搜索，不仅要使用<strong>-f</strong>参数来设置需要看的列数，还需要使用<strong>-d</strong>参数来设置间隔符号。passwd在保存用户数据信息时，用户信息的每一项值之间是采用冒号来间隔的，接下来我们使用下述命令尝试提取出passwd文件中的用户名信息，即提取以冒号（：）为间隔符号的第一列内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# cut -d: -f1 /etc/passwd</span><br><span class="line">root</span><br><span class="line">bin</span><br><span class="line">daemon</span><br><span class="line">adm</span><br><span class="line">lp</span><br><span class="line">sync</span><br><span class="line">shutdown</span><br><span class="line">halt</span><br><span class="line">mail</span><br><span class="line">operator</span><br><span class="line">games</span><br><span class="line">ftp</span><br><span class="line">nobody</span><br><span class="line">dbus</span><br><span class="line">polkitd</span><br><span class="line">avahi</span><br><span class="line">avahi-autoipd</span><br><span class="line">postfix</span><br><span class="line">sshd</span><br><span class="line">chrony</span><br><span class="line">[root@Remilia ~]#</span><br></pre></td></tr></table></figure>
<h2 id="diff命令"><a href="#diff命令" class="headerlink" title="diff命令"></a>diff命令</h2><p>diff命令用于比较多个文本文件的差异，格式为“<strong>diff</strong> [参数] {文件}”。</p>
<p>在使用diff命令时，不仅可以使用<strong>—brief</strong>参数来确认两个文件是否不同，还可以使用<strong>-c</strong>参数来详细比较出多个文件的差异之处，这绝对是判断文件是否被篡改的有力神器。例如，先使用cat命令分别查看diffa和diffb文件的内容，然后进行比较：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# echo welcom &gt; diffa</span><br><span class="line">[root@Remilia ~]# echo welcome &gt; diffb</span><br><span class="line"></span><br><span class="line">[root@Remilia ~]# cat diffa</span><br><span class="line">welcom</span><br><span class="line">[root@Remilia ~]# cat diffb</span><br><span class="line">welcome</span><br><span class="line">[root@Remilia ~]#</span><br></pre></td></tr></table></figure>
<p>接下来使用diff —brief命令显示比较后的结果，判断文件是否相同： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# diff --brief diffa diffb</span><br><span class="line">Files diffa and diffb differ</span><br></pre></td></tr></table></figure>
<p>最后使用带有-c参数的diff命令来描述文件内容具体的不同： </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# diff -c diffa diffb</span><br><span class="line">*** diffa       2018-05-15 09:44:14.941323235 +0800</span><br><span class="line">--- diffb       2018-05-15 09:44:29.308260323 +0800</span><br><span class="line">***************</span><br><span class="line">*** 1 ****</span><br><span class="line">! welcom</span><br><span class="line">--- 1 ----</span><br><span class="line">! welcome</span><br><span class="line">[root@Remilia ~]#</span><br></pre></td></tr></table></figure>
<h1 id="文件目录管理命令"><a href="#文件目录管理命令" class="headerlink" title="文件目录管理命令"></a>文件目录管理命令</h1><p>在Linux系统的日常运维工作中，还需要掌握对文件的创建、修改、复制、剪切、更名与删除等操作。 </p>
<h2 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h2><p>touch命令用于创建空白文件或设置文件的时间，格式为“<strong>touch</strong> [选项] {文件}”。<br>在创建空白的文本文件方面，这个touch命令相当简捷，简捷到没有必要特别去研究。比如，touch test命令可以创建出一个名为test的空白文本文件。对touch命令来讲，有难度的操作主要是体现在设置文件内容的修改时间（mtime）、文件权限或属性的更改时间（ctime）与文件的读取时间（atime）上面。touch命令的参数及其作用如下</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-a</td>
<td>仅修改“读取时间”（atime）</td>
</tr>
<tr>
<td>-m</td>
<td>仅修改“修改时间”（mtime）</td>
</tr>
<tr>
<td>-d</td>
<td>同时修改atime与mtime</td>
</tr>
</tbody>
</table>
</div>
<p>接下来，我们先使用ls命令查看一个文件的修改时间，然后修改这个文件，最后再通过touch命令把修改后的文件时间设置成修改之前的时间 :</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# ls -l anaconda-ks.cfg </span><br><span class="line">-rw-------. 1 root root 922 Feb 27 09:06 anaconda-ks.cfg</span><br><span class="line">[root@Remilia ~]# echo `test` &gt;&gt; anaconda-ks.cfg </span><br><span class="line">[root@Remilia ~]# ls -l anaconda-ks.cfg </span><br><span class="line">-rw-------. 1 root root 923 May 15 09:49 anaconda-ks.cfg</span><br><span class="line">[root@Remilia ~]# touch -d "2012-05-15 9:50" anaconda-ks.cfg </span><br><span class="line">[root@Remilia ~]# ls -l anaconda-ks.cfg </span><br><span class="line">-rw-------. 1 root root 923 May 15  2012 anaconda-ks.cfg</span><br></pre></td></tr></table></figure>
<h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><p>mkdir命令用于创建空白的目录，格式为“<strong>mkdir</strong> [选项] {目录}”。</p>
<p>在Linux系统中，文件夹是最常见的文件类型之一。除了能创建单个空白目录外，mkdir命令还可以结合<strong>-p</strong>参数来递归创建出具有嵌套叠层关系的文件目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@Remilia ~]# mkdir -p a/b/c/d</span><br><span class="line">[root@Remilia ~]# cd a</span><br><span class="line">[root@Remilia a]# cd b</span><br><span class="line">[root@Remilia b]# cd c</span><br><span class="line">[root@Remilia c]# cd d</span><br><span class="line">[root@Remilia d]# pwd</span><br><span class="line">/root/a/b/c/d</span><br><span class="line">[root@Remilia d]#</span><br></pre></td></tr></table></figure>
<h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><p>cp命令用于复制文件或目录，格式为“<strong>cp</strong> [选项] {源文件} {目标文件}”。</p>
<p>大家对文件复制操作应该不陌生，在Linux系统中，复制操作具体分为3种情况：</p>
<ul>
<li><p>如果目标文件是目录，则会把源文件复制到该目录中；</p>
</li>
<li><p>如果目标文件也是普通文件，则会询问是否要覆盖它；</p>
</li>
<li><p>如果目标文件不存在，则执行正常的复制操作。</p>
<p> cp命令常用参数如下:</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-p</td>
<td>保留原始文件的属性</td>
</tr>
<tr>
<td>-d</td>
<td>若对象为“链接文件”，则保留该“链接文件”的属性</td>
</tr>
<tr>
<td>-r</td>
<td>递归持续复制（用于目录）</td>
</tr>
<tr>
<td>-i</td>
<td>若目标文件存在则询问是否覆盖</td>
</tr>
<tr>
<td>-a</td>
<td>相当于-pdr（p、d、r为上述参数）</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>EIGRP BASIC</title>
    <url>/2018/04/12/CCNPDAY3/</url>
    <content><![CDATA[<p><strong>EIGRP路由协议基础部分</strong></p>
<h1 id="EIGRP的概述"><a href="#EIGRP的概述" class="headerlink" title="EIGRP的概述"></a>EIGRP的概述</h1><p>EIGRP是一种高级距离矢量路由协议，具有一定链路状态性质的距离矢量路由协议。</p>
<p>距离矢量路由协议：通过相邻路由器周期性更新整张路由表，获取路由信息，通过算法选出最佳路径，所有信息仅限于邻居之间共享。</p>
<p>链路状态路由协议：虽然只通告直连信息，但是这些信息可以在同一个区域内共享，使得路由器了解该区域的拓扑情况，构建同一区域的整张拓扑表，然后根据算法选出最佳路径。</p>
<p>EIGRP的高级距离矢量性：同样也构建拓扑表，但是这张拓扑表和链路状态路由协议不同的是：EIGRP的拓扑表示根据邻居传递的路由构造的，并不是根据链路状态信息。</p>
<a id="more"></a>
<h1 id="EIGRP的特点"><a href="#EIGRP的特点" class="headerlink" title="EIGRP的特点"></a>EIGRP的特点</h1><ol>
<li><p>高级距离矢量性</p>
</li>
<li><p>无类路由协议</p>
</li>
<li><p>快速收敛</p>
</li>
<li><p>增量更新</p>
</li>
<li><p>支持多种网络层协议（PDM，Protocol-dependent Modules）</p>
</li>
<li><p>使用组播（224.0.0.10）和单播更新</p>
</li>
<li><p>支持手工汇总</p>
</li>
<li><p>支持非等价负载均衡（cisco专利）</p>
</li>
</ol>
<h1 id="EIGRP的封装"><a href="#EIGRP的封装" class="headerlink" title="EIGRP的封装"></a>EIGRP的封装</h1><p>EIGRP数据包承载在IP之上，对应ip报头中protocol=88，EIGRP依靠私有协议RTP（可靠传输协议）保证EIGRP数据包的可靠传输。</p>
<p>RTP：用来管理EIGRP数据包的发送和接收，可靠的发送是指发送是有保障的(通过ack确认)而且数据包是有序的发送的（通过序列号）。</p>
<p><img src="/2018/04/12/CCNPDAY3/69077819e7becd93f224ac8cb5ce81be.png" alt=""></p>
<p>TLV：type/length/value，类型/长度/数值。</p>
<p><img src="/2018/04/12/CCNPDAY3/ee657253779cd59ea275a1423c0f3745.png" alt=""></p>
<p>图 3‑1 EIGRP报头格式截图</p>
<h2 id="EIGRP报头"><a href="#EIGRP报头" class="headerlink" title="EIGRP报头"></a>EIGRP报头</h2><ul>
<li><p>版本：2</p>
</li>
<li><p>操作码：EIGRP数据包类型</p>
</li>
</ul>
<blockquote>
<p>  1代表更新（update）：用于传递路由更新信息。和RIP不同，EIGRP只有在必要的时候传递必要的信息，并且仅仅传递给需要路由信息的路由器。第一个更新包使用组播发送，重传更新包用单播发送。更新包是可靠传输的。</p>
<p>  3代表查询（query）：向EIGRP邻居查询路由信息，查询包可以用组播或单播发送，是可靠传输。</p>
<p>  4代表回应（reply）：对路由器的查询信息进行响应，回应包总是单播发送的，是可靠传输。</p>
<p>  5代表hello或确认（ACK）：hello用于发现邻居和维护邻居关系，使用组播方式发送，并且是不可靠传输；当hello包不包含数据时就是ACK，ACK用于确认可靠传输的EIGRP数据包，ACK总是单播发送并且是不可靠传输。</p>
</blockquote>
<p>在高速链路上，例如以太网，点到点链路（PPP、HDLC），Hello的间隔时间为5秒，抑制时间为15秒，即15秒后还没收到邻居的hello包，便认为邻居失效，重置邻居。</p>
<p>在带宽小于等于1.544Mbps的低速链路，例如帧中继，ATM，hello的间隔时间为60秒，抑制时间为180秒。</p>
<p>接口下修改hello间隔时间：</p>
<p><code>R1(config-if)#ip hello-interval eigrp 100 5-----100为eigrp进程号，5为hello间隔时间。</code></p>
<p>接口下修改抑制时间：</p>
<p><code>R1(config-if)#ip hold-time eigrp 100 15----100为eigrp进程号，15为holdtime。</code></p>
<ul>
<li><p>校验和：计算EIGRP整个数据包。</p>
</li>
<li><p>序列号：RTP用于保证有序传输的机制。</p>
</li>
<li><p>确认号：RTP用于保证可靠传输的机制。一个非零ACK字段的hello包将视为确认包，而不是hello包。</p>
</li>
<li><p>自治域系统号：一个EIGRP协议域的标识号。</p>
<ol>
<li><p>EIGRP报文</p>
<ol>
<li>参数TLV的EIGRP报文</li>
</ol>
</li>
</ol>
</li>
</ul>
<p><img src="/2018/04/12/CCNPDAY3/a08d5b239f487a52105d24e36378d337.png" alt=""></p>
<p>图 3‑2 EIGRP报文格式截图</p>
<p>EIGRP的metric计算：</p>
<p>完整公式：<img src="/2018/04/12/CCNPDAY3/CodeCogsEqn.png" alt=""></p>
<p>（K5不等于0时）</p>
<p>默认情况下：K1（带宽系数）=1，K2（负载系数）=0，K3（延迟系数）=1，K4（可信度系数）=0，K5（MTU系数）=0</p>
<p>当K5=0时</p>
<p>Metric=K1XBW+K3Xdelay</p>
<p>BW(带宽)=[10^7/(整条链路最小的链路带宽，kbps)]*256</p>
<p>Delay（延迟）=[整条路径（路由进接口）的延迟总和，10usec]*256</p>
<p>注：如果10^7除最小带宽为非整数，则取整，例如串行链路带宽为1.544Mbps，10^7除1544=6476.68，取整为6476，如果10^7/最小带宽&lt;1，则取1，例如环回口，带宽为8Gbps，此时取1.</p>
<p>修改K值：<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">router eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line">metric weights <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>1（第一个值为tos只能为0，第二个K1带宽的系数，第三个K2负载的系数，第四个K3延迟的系数，第五个K4可信度的系数，第六个K5<br>MTU的系数）</p>
<p>等待时间：holdtime</p>
<h3 id="IP内部路由TLV的EIGRP报文"><a href="#IP内部路由TLV的EIGRP报文" class="headerlink" title="IP内部路由TLV的EIGRP报文"></a>IP内部路由TLV的EIGRP报文</h3><p><img src="/2018/04/12/CCNPDAY3/e9cafd0396e6ace98671785d3437006f.png" alt=""><br>图 3‑3 EIGRP报文格式截图</p>
<ul>
<li><p>延迟：路由进方向的接口延迟总和，单位为10us。一个0xFFFFFFFF的延迟标识一个不可达的路由</p>
</li>
<li><p>带宽：路由进方向整个路径上的最小接口带宽。</p>
</li>
<li><p>MTU（最大传输单元）：路由进方向整个链路上最小的MTU。</p>
</li>
</ul>
<p>跳数：一个在0x01-0xFF的数，即1到255跳，256跳表示路由不可达。</p>
<ul>
<li><p>可靠性：一个在0x01-0xFF的数，用来反映到达目的地出站接口的误码率总和。0xFF表示100%可靠链路。</p>
</li>
<li><p>负载：一个在0x01-0xFF的数，用来反映到达目的地出站接口负载的总和。0x01表示一条最小负载的链路。</p>
</li>
<li><p>前缀长度：即掩码长度。</p>
</li>
<li><p>目的地址：表示一个路由的目标地址。该字段长度可变，如果没有满足4个8位组的边界长，将用0补齐。</p>
</li>
</ul>
<h1 id="EIGRP的邻居列表"><a href="#EIGRP的邻居列表" class="headerlink" title="EIGRP的邻居列表"></a>EIGRP的邻居列表</h1><p><img src="/2018/04/12/CCNPDAY3/b404ae1f6f8cf78899bb6011000ce711.png" alt=""></p>
<p>图 4‑1 EIGRP邻居列表截图</p>
<p>EIGRP邻居列表的描述：</p>
<p>表 4‑1 EIGRP邻居列表内容描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>内容</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Process 100</td>
<td>AS号为100</td>
</tr>
<tr>
<td>2</td>
<td>H</td>
<td>邻居列表的序列号，从0开始计数</td>
</tr>
<tr>
<td>3</td>
<td>Address</td>
<td>邻居的接口ip地址</td>
</tr>
<tr>
<td>4</td>
<td>Interface</td>
<td>本地连接邻居的接口</td>
</tr>
<tr>
<td>5</td>
<td>Hold</td>
<td>holdtimer从15s开始倒计时</td>
</tr>
<tr>
<td>6</td>
<td>Uptime</td>
<td>邻居建立之后经过的时间</td>
</tr>
<tr>
<td>7</td>
<td>SRTT（smooth round-trip timer）</td>
<td>平滑往返时间，一个可靠报文发出至接收到ACK的时间，单位：毫秒</td>
</tr>
<tr>
<td>8</td>
<td>RTO(retransmission timeout)</td>
<td>发出一个可靠报文，如果没有收到ACK，经过RTO之后重传报文，一共重传16次，还没有收到ACK，重置邻居关系，该时间是通过cisco的算法得出，不是固定值，单位ms</td>
</tr>
<tr>
<td>9</td>
<td>Q</td>
<td>重传队列中等待发送数据包的数量</td>
</tr>
<tr>
<td>10</td>
<td>Seq</td>
<td>从邻居收到的最新可靠传输数据包的序列号， RTP跟踪这些序列号，保证数据包的有序性</td>
</tr>
</tbody>
</table>
</div>
<p>注：EIGRP的hello-interval和holdtime都不影响EIGRP的邻居建立。</p>
<ol>
<li><p>EIGRP拓扑表</p>
<ol>
<li>DUAL算法（扩散更新算法）</li>
</ol>
</li>
</ol>
<p>扩散更新算法是一个收敛算法，设计思想是即使是暂时的环路还是对网络性能造成影响。Cisco<br>EIGRP使用DUAL算法称该协议100%无环。</p>
<h2 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h2><ul>
<li><p>可行距离 (feasible distance，FD):到达每一个目标网段的最小度量值作为该目标网段的可行距离。</p>
</li>
<li><p>后继路由器（successor，S）：到达目标网络的最佳下一跳路由器。</p>
</li>
<li><p>可行后继路由器（feasible successor，FS）：作为后继路由器的备份下一跳路由器，如果后继路由器失效，FS将自动切换为S，即次佳下一跳。为了避免环路，不是所有的路由器都可以成为FS，必须要满足FC。</p>
</li>
<li><p>可行性条件（feasible condition，FC）：希望成为FS的路由器的通告距离AD小于目前的FD。</p>
</li>
<li><p>通告距离AD（advertise distance，AD）：下一跳路由器到达目标地址的距离。</p>
<ol>
<li>相关实验</li>
</ol>
</li>
</ul>
<p><img src="/2018/04/12/CCNPDAY3/f736fd984f75b4fb894e24c24021dc5e.png" alt=""></p>
<p>图 5‑1 EIGRP拓扑表实验拓扑图</p>
<p>R1可以收到从R2和R3发送的34.1.1.0/24路由，通过计算开销，R1以R3作为下一跳开销为200，R1以R2为下一跳开销为250，因此R1到34.1.1.0网络的FD为200，R3为最佳下一跳即S，R2是否能成为FS，首先看是否满足FC，R2的AD为150&lt;R1到34.1.1.0的FD为200，因此R2为R1到达34.1.1.0的FS。</p>
<p>查看完整的拓扑表：</p>
<p><img src="/2018/04/12/CCNPDAY3/56d5c5e4d55ce503f074c9b1160ec461.png" alt=""></p>
<p>查看通过dual算法计算后的拓扑表：</p>
<p><img src="/2018/04/12/CCNPDAY3/2c403ced877780c376966518e864d677.png" alt=""></p>
<h1 id="EIGRP路由表"><a href="#EIGRP路由表" class="headerlink" title="EIGRP路由表"></a>EIGRP路由表</h1><p>通过拓扑表计算出的最佳路径放进路由表，如下图所示：</p>
<p><img src="/2018/04/12/CCNPDAY3/fdc96809cfdd3c13252dc8ef9968c3bc.png" alt=""></p>
<p>图 6‑1 EIGRP路由表构建过程</p>
<h1 id="EIGRP邻据状态机制"><a href="#EIGRP邻据状态机制" class="headerlink" title="EIGRP邻据状态机制"></a>EIGRP邻据状态机制</h1><p><img src="/2018/04/12/CCNPDAY3/031d00fddca2a7795e2a69b5ba2b1fea.png" alt=""></p>
<p>图 7‑1 EIGRP邻居状态机</p>
<ol>
<li><p>EIGRP非等价负载均衡</p>
<ol>
<li>EIGRP等价负载均衡</li>
</ol>
</li>
</ol>
<p>EIGRP的默认负载均衡路径数为4，最大为16。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span><span class="selector-id">#maximum-paths</span> <span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<h2 id="EIGRP非等价负载均衡"><a href="#EIGRP非等价负载均衡" class="headerlink" title="EIGRP非等价负载均衡"></a>EIGRP非等价负载均衡</h2><p>EIGRP的非等价负载均衡必要条件：只有后继路由器（S）和可行后继路由器（FS）才能实现非等价负载均衡，并非所有链路都可以成为负载均衡的链路。</p>
<p>Variance（差异变量）用来确定哪些路由可以实现非等价负载均衡。Variance是一个倍数因子，默认为1，实现等价负载均衡。</p>
<p><img src="/2018/04/12/CCNPDAY3/0d3bff14f776a7e4fe76fb55b7e2981b.png" alt=""></p>
<p>图 8.2‑1 EIGRP非等价负载均衡实验拓扑图</p>
<p>拓扑说明：R1到.4的FD为300，R2为FS，R1通过R2到达4.4.4.4的开销为400，如果要实现非等价负载均衡，FD<em>variance&gt;=通过R2到达4.4.4.4的开销，即300</em>variance&gt;=400（variance值必须为整数）</p>
<p>实验配置：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span><span class="selector-id">#no</span> <span class="attribute">auto</span>-summary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span><span class="selector-id">#metric</span> weight <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">12.1</span>.<span class="number">1.1</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">13.1</span>.<span class="number">1.1</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span>#exit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> f0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#delay</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span>#exit</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-router)</span></span><span class="selector-id">#no</span> <span class="attribute">auto</span>-summary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-router)</span></span><span class="selector-id">#metric</span> weight <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">12.1</span>.<span class="number">1.2</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">23.1</span>.<span class="number">1.2</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-router)</span></span>#exit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> f1/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#delay</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span>#exit</span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span><span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-router)</span></span><span class="selector-id">#no</span> <span class="attribute">auto</span>-summary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-router)</span></span><span class="selector-id">#metric</span> weight <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">13.1</span>.<span class="number">1.3</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">23.1</span>.<span class="number">1.3</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">34.1</span>.<span class="number">1.3</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config)</span></span><span class="selector-id">#router</span> eigrp <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-router)</span></span><span class="selector-id">#no</span> <span class="attribute">auto</span>-summary</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-router)</span></span><span class="selector-id">#metric</span> weight <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">34.1</span>.<span class="number">1.4</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">4.4</span>.<span class="number">4.4</span> <span class="number">0.0</span>.<span class="number">0.0</span></span><br></pre></td></tr></table></figure></p>
<p>验证结果：</p>
<p><code>R1#show ip eigrp topology</code></p>
<p><code>P 4.4.4.4/32, 2 successors, FD is 133120</code></p>
<p>via 23.1.1.3 (133120/130560), FastEthernet1/0</p>
<p>via 12.1.1.1 (133120/131840), FastEthernet0/0</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>EIGRP</tag>
      </tags>
  </entry>
  <entry>
    <title>RIP</title>
    <url>/2018/04/11/CCNPDAY2/</url>
    <content><![CDATA[<p><strong>RIP路由信息协议</strong></p>
<h1 id="路由分类"><a href="#路由分类" class="headerlink" title="路由分类"></a>路由分类</h1><h2 id="动态路由协议按照范围来分："><a href="#动态路由协议按照范围来分：" class="headerlink" title="动态路由协议按照范围来分："></a>动态路由协议按照范围来分：</h2><ul>
<li>IGP（intra gateway protocol）内部网关路由协议</li>
</ul>
<p>Rip，eigrp，ospf</p>
<ul>
<li>EGP（edge gateway protocol）边界网关路由协议</li>
</ul>
<p>Egp，bgp</p>
<h2 id="动态路由协议按类型来分："><a href="#动态路由协议按类型来分：" class="headerlink" title="动态路由协议按类型来分："></a>动态路由协议按类型来分：</h2><ul>
<li><p>距离矢量路由协议:rip,eigrp</p>
</li>
<li><p>链路状态路由协议:ospf,is-is</p>
</li>
<li><p>路径矢量：bgp</p>
</li>
</ul>
<h2 id="距离矢量路由协议"><a href="#距离矢量路由协议" class="headerlink" title="距离矢量路由协议"></a>距离矢量路由协议</h2><p>距离矢量路由协议的由来是因为路由是以矢量（距离，方向）的方式被通告出去的，其中距离是根据度量（metric）定义的，方向是根据下一跳定义的。</p>
<a id="more"></a>
<h1 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h1><h2 id="RIP的特点"><a href="#RIP的特点" class="headerlink" title="RIP的特点"></a>RIP的特点</h2><p>管理距离：120</p>
<p>使用跳数作为选择路径的度量</p>
<p>如果某网络的跳数超过了15，RIP便无法提供到达该网络的路由。</p>
<p>默认情况下，每30秒通过广播或组播发送一次路由更新。</p>
<h2 id="RIP的版本"><a href="#RIP的版本" class="headerlink" title="RIP的版本"></a>RIP的版本</h2><ul>
<li><p>RIPv1</p>
</li>
<li><p>RIPv2</p>
</li>
<li><p>RIPng</p>
</li>
</ul>
<h2 id="RIPv1的消息格式"><a href="#RIPv1的消息格式" class="headerlink" title="RIPv1的消息格式"></a>RIPv1的消息格式</h2><p>RIP 消息的数据部分封装在 UDP<br>数据段内，其源端口号和目的端口号都被设为520。在消息从所有配置了 RIP<br>的接口发送出去之前，IP 报头和数据链路报头会加入广播地址作为目的地址。</p>
<p><img src="/2018/04/11/CCNPDAY2/766fac650570f69bb2db96d2a5d72d94.png" alt=""></p>
<p>图 2‑1 RIP数据包结构图</p>
<p>Rip请求包：每个配置了RIP的接口在启动时都会发送请求消息，要求所有邻居发送完整的路由表。</p>
<p>Rip应答包：默认情况下启用RIP的路由器每30秒通过广播发送一次完整的路由表进行路由更新；在收到请求包的情况下通过单播方式向请求方发送完整的路由表。</p>
<p>RIPv1的数据包内只有目标网络，但是没有子网掩码，因此RIPv1不支持VLSM（可变长子网掩码），只支持有类路由。</p>
<p>在有类网络环境中，假定同一主类网络使用相同掩码，由于路由传递过程中不携带掩码，接收方路由器以自己的接口掩码作为路由掩码。</p>
<h2 id="RIP路由更新的过程"><a href="#RIP路由更新的过程" class="headerlink" title="RIP路由更新的过程"></a>RIP路由更新的过程</h2><p>第一步：路由器只直连路由。</p>
<p><img src="/2018/04/11/CCNPDAY2/b0a87893f906c45a6b5ff5049320847c.png" alt=""></p>
<p>图 2‑2 RIP路由表更新示意图1</p>
<p>第二步：每30秒将自己的整张路由表通过Rip应答包发送出去，收到路由后通过跳数选择最优的路由放入路由表。</p>
<p><img src="/2018/04/11/CCNPDAY2/008d060a8a5a1757ab258e2a0f51474f.png" alt=""></p>
<p>图 2‑3 RIP路由表更新示意图2</p>
<p><img src="/2018/04/11/CCNPDAY2/3f9b9be7a5956c8c166b3e827cc6d7a5.png" alt=""></p>
<p>图 2‑4 RIP路由表更新示意图3</p>
<h2 id="有类路由收发规则"><a href="#有类路由收发规则" class="headerlink" title="有类路由收发规则"></a>有类路由收发规则</h2><ul>
<li><p>路由器发送路由更新，路由条目的掩码必须和出接口掩码相同，否则不发该路由条目；</p>
</li>
<li><p>路由器发送路由更新，如果路由条目掩码为32位，路由器认为该条路由为主机路由，即使和出接口掩码不同，仍然发送该路由条目；</p>
</li>
<li><p>路由器接收路由更新，由于路由更新中不携带掩码，路由器收到路由条目后，以进接口的掩码安装到路由条目中；</p>
</li>
<li><p>路由器接收路由更新，使用进接口的掩码匹配路由后，发现主机位不全为0，则认为该路由为主机路由，在路由表中生成32位主机路由。</p>
</li>
</ul>
<blockquote>
<p>  注：同一主类网络被划分的各个子网，叫做连续的子网</p>
</blockquote>
<p>假定拓扑：所有ip属于同一主类网络！</p>
<p><img src="/2018/04/11/CCNPDAY2/f0c874d3a36b4adee8a8de3b3e8e9f04.png" alt=""></p>
<p>图 2‑5 有类路由更新机制实验图</p>
<p>RIPv1的配置：<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#router</span> rip------开启rip进程</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span><span class="selector-id">#version</span> <span class="number">1</span>-------版本<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">172.16</span>.<span class="number">0.0</span>-----宣告直连的有类网络</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/11/CCNPDAY2/d76f950d67a34589b28c50c2979a5f08.png" alt=""></p>
<p>图 2‑6 RIP路由表截图</p>
<h3 id="情景1-将R2的loopback-0的掩码改为25位"><a href="#情景1-将R2的loopback-0的掩码改为25位" class="headerlink" title="情景1 将R2的loopback 0的掩码改为25位"></a>情景1 将R2的loopback 0的掩码改为25位</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#int</span> lo0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> add <span class="number">172.16</span>.<span class="number">2.1</span> <span class="number">255.255</span>.<span class="number">255.128</span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/04/11/CCNPDAY2/201d0ea5162af4581131e034c39862f0.png" alt=""></p>
<p>图 2‑7 情景1RIP路由表截图</p>
<p>现象：172.16.2.0的路由条目消失在R1的路由表中。</p>
<h3 id="情景2-将R2的loopback-0的掩码改为32位"><a href="#情景2-将R2的loopback-0的掩码改为32位" class="headerlink" title="情景2 将R2的loopback 0的掩码改为32位"></a>情景2 将R2的loopback 0的掩码改为32位</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#int</span> lo0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> add <span class="number">172.16</span>.<span class="number">2.1</span> <span class="number">255.255</span>.<span class="number">255.255</span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/04/11/CCNPDAY2/8f60dc8fda59d7aaa3119a730985b8a8.png" alt=""></p>
<p>图 2‑8情景2 RIP路由表截图</p>
<p>现象：R1的路由表中出现了172.16.2.1/32的路由条目</p>
<h3 id="情景3-将R1的F0-0接口掩码改为25位"><a href="#情景3-将R1的F0-0接口掩码改为25位" class="headerlink" title="情景3 将R1的F0/0接口掩码改为25位"></a>情景3 将R1的F0/0接口掩码改为25位</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#int</span> f0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> add <span class="number">172.16</span>.<span class="number">12.1</span> <span class="number">255.255</span>.<span class="number">255.128</span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/04/11/CCNPDAY2/a08be8985a0028c185a743ad6412fa03.png" alt=""></p>
<p>图 2‑9 情景3RIP路由表截图</p>
<p>现象：R1路由表中所有Rip条目都变为25位</p>
<h3 id="情景4：将R2的F0-0接口掩码改为25位，R2的loopback的地址改为172-16-2-129，掩码改为25位"><a href="#情景4：将R2的F0-0接口掩码改为25位，R2的loopback的地址改为172-16-2-129，掩码改为25位" class="headerlink" title="情景4：将R2的F0/0接口掩码改为25位，R2的loopback的地址改为172.16.2.129，掩码改为25位"></a>情景4：将R2的F0/0接口掩码改为25位，R2的loopback的地址改为172.16.2.129，掩码改为25位</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#int</span> lo0</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> add <span class="number">172.16</span>.<span class="number">2.129</span> <span class="number">255.255</span>.<span class="number">255.128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#int</span> f0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> add <span class="number">172.16</span>.<span class="number">12.2</span> <span class="number">255.255</span>.<span class="number">255.128</span></span><br></pre></td></tr></table></figure>
<p><img src="/2018/04/11/CCNPDAY2/2b10cf042d6b36b78f28c2d2d1f1ded9.png" alt=""></p>
<p>图 2‑10 情景4RIP路由表截图</p>
<p>现象：R1的路由表中产生了一条172.16.2.128/32的路由条目</p>
<h2 id="RIP边界汇总"><a href="#RIP边界汇总" class="headerlink" title="RIP边界汇总"></a>RIP边界汇总</h2><p>两个不同接口属于不同主类网络是RIP边界路由器，此路由器会自动将路由条目汇总为主类网络的掩码进行路由更新。</p>
<p><img src="/2018/04/11/CCNPDAY2/cb4404ed22e1eb8e51e90d9f28dcfc6e.png" alt=""></p>
<p>图 2‑11 RIP汇总实验拓扑图</p>
<p><img src="/2018/04/11/CCNPDAY2/551321b10b19a10df304be3452fc8760.png" alt=""></p>
<p>图 2‑12 R2 RIP路由表截图</p>
<p>R2的路由表中仍然是24位路由</p>
<p><img src="/2018/04/11/CCNPDAY2/3eff0fb1a3be4f02e7ed6995b2208dbd.png" alt=""></p>
<p>图 2‑13 R1 RIP路由表</p>
<p>R1的路由表中出现了.0/8的主类路由</p>
<p><img src="/2018/04/11/CCNPDAY2/281171e18bfa335af369acd49fdbecf1.png" alt=""></p>
<p>图 2‑14 R3 RIP路由表</p>
<p>R3的路由表中出现了172.16.0.0/16的主类路由</p>
<h2 id="RIP的被动接口"><a href="#RIP的被动接口" class="headerlink" title="RIP的被动接口"></a>RIP的被动接口</h2><p><img src="/2018/04/11/CCNPDAY2/a50483f556090103f103e576b4d5e039.png" alt=""></p>
<p>图 2‑15 RIP被动接口实验拓扑图</p>
<p>现在需求R1和R2相互更新RIP路由信息，R3和R4相互更新RIP路由信息，但不希望R2和R3之间相互更新路由信息。</p>
<p>对于R2来说很容易实现：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R2(config)#router rip</span><br><span class="line"></span><br><span class="line">R2(config-router)#network 192.168.12.0</span><br></pre></td></tr></table></figure></p>
<p>不宣告172.16.23.0网段就可以了。</p>
<p>但是R3如何实现呢？如何要向R4发送路由更新，就必须宣告172.16.34.0网段，但是rip宣告主类网络，172.16.0.0同时也包括了172.16.23.0网段。<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span><span class="selector-id">#router</span> rip</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-router)</span></span><span class="selector-id">#network</span> <span class="number">172.16</span>.<span class="number">0.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-router)</span></span><span class="selector-id">#passive-interface</span> fastEthernet <span class="number">0</span>/<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>Passive-interface：被动接口，使得RIP路由器只从此接口接收路由更新，不发送路由更新！</p>
<p>只希望F0/0发rip更新，其他接口都不发rip更新<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">router rip</span><br><span class="line"></span><br><span class="line">version 1</span><br><span class="line"></span><br><span class="line">passive-interface default-----所有接口都设置passive接口</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> passive-interface FastEthernet0/0</span><br><span class="line"></span><br><span class="line">network 172.16.0.0</span><br></pre></td></tr></table></figure></p>
<h2 id="RIP默认路由"><a href="#RIP默认路由" class="headerlink" title="RIP默认路由"></a>RIP默认路由</h2><p><img src="/2018/04/11/CCNPDAY2/843f551751ff22d4d46668b81ffc55fc.png" alt=""></p>
<p>图 2‑16 RIP默认路由实验拓扑图</p>
<p>拓扑说明：R1为内网路由器，R2为网关，R3为internet路由器，默认情况下，网关需要写一条静态缺省路由指向外网，但是内部的每一台路由器都需要这样操作吗？动态路由协议是否可以传递缺省路由呢？</p>
<h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R2:</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> route </span>.0 0.0.0.0 202.100.1.3---R2缺省路由指向R3</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"></span><br><span class="line">version 1</span><br><span class="line"></span><br><span class="line">network 172.16.0.0</span><br><span class="line"></span><br><span class="line">default-information originate----下发默认路由</span><br></pre></td></tr></table></figure>
<p>R1:</p>
<p><img src="/2018/04/11/CCNPDAY2/55edcb20e12f5369ea6d6efbb4cbd284.png" alt=""></p>
<p>图 2‑17 RIP默认路由实验方法一验证截图</p>
<h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><p><img src="/2018/04/11/CCNPDAY2/1d0ba72b6d1ca499b0c9bf03a9751267.png" alt=""></p>
<p>图 2‑18 RIP默认路由实验拓扑图</p>
<p><code>ip default-network</code><br>一个直连路由或静态路由（路由可以是子网路由，但是default-network只能接主类）</p>
<p>建议方案，在网关上添加一个环回口，使用该环回口当默认网络。</p>
<p>R2：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>2.2.2.2 255.255.255.255</span><br><span class="line"></span><br><span class="line">ip default-network 2.2.2.0</span><br></pre></td></tr></table></figure></p>
<p><img src="/2018/04/11/CCNPDAY2/06eaeb70376deea2d0f2bde75e329c6b.png" alt=""></p>
<p>图 2‑19 RIP默认路由实验方法二验证截图</p>
<p>R1：</p>
<p><img src="/2018/04/11/CCNPDAY2/b89ff37b7596e0a2c408674600d2fbaf.png" alt=""></p>
<p>图 2‑20 RIP默认路由实验方法二验证截图</p>
<p><code>注：先ip default-network 2.2.2.0，然后再ip route 0.0.0.0 0.0.0.0 202.100.1.2</code></p>
<h3 id="方法三："><a href="#方法三：" class="headerlink" title="方法三："></a>方法三：</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R4(config)#ip<span class="built_in"> route </span>.0 0.0.0.0 f0/0</span><br><span class="line"></span><br><span class="line">R4(config)#router rip</span><br><span class="line"></span><br><span class="line">R4(config-router)#redistribute static ----重分发静态路由，让rip可以学习静态路由</span><br></pre></td></tr></table></figure>
<h2 id="RIP环路"><a href="#RIP环路" class="headerlink" title="RIP环路"></a>RIP环路</h2><p><img src="/2018/04/11/CCNPDAY2/6c1b4c2edb5668230a6ceb5c00d6da46.png" alt=""></p>
<p>图 2‑21 RIP路由环路示意图</p>
<p>解决环路的方法：</p>
<ul>
<li>水平分割（默认开启，可以手动关闭）</li>
</ul>
<p>从一个接口收到的路由不会再从这个接口发出<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)#int f0/0</span><br><span class="line"></span><br><span class="line">R1(config-if)#<span class="literal">no</span><span class="built_in"> ip </span>split-horizon</span><br></pre></td></tr></table></figure></p>
<ul>
<li>最大跳数</li>
</ul>
<p>一条路由失效后立刻将其定义为16跳（不可达）</p>
<ul>
<li>触发更新</li>
</ul>
<p>路由器一条路由失效后立刻发送路由更新</p>
<ul>
<li>毒性逆转</li>
</ul>
<p>以上图为例，.0的路由down掉了之后，Router<br>C将10.4.0.0标记毒性路由（表示该路由不可达，rip使用16跳）发送给Router B，Router<br>B立刻向Router<br>C回复一条毒性路由，打破水平分割原则，防止C向B发毒性路由的同时，B将自己的路由更新给C，造成环路。</p>
<h2 id="RIP计时器"><a href="#RIP计时器" class="headerlink" title="RIP计时器"></a>RIP计时器</h2><ol>
<li><p>update<br>timer（更新计时器）：平均每30秒发送一次应答包，通过一个RIP_Jitter的随机抖动变量来错开更新时间（25.5-30S）</p>
</li>
<li><p>invalid<br>timer（无效计时器）：当180秒后还没收到路由更新，路由条目被变为16跳，标记为不可达。</p>
</li>
<li><p>flush timer（刷新计时器）：当无效计时器超时60秒后，该路由从路由表删除。</p>
</li>
<li><p>holddown<br>timer（抑制计时器）：180秒，路由器如果在相同的接口上收到某个路由条目的距离比原先收到的距离大，那么将启动一个抑制计时器，在抑制计时器的时间内该目的标记为不可到达，直到计时器超时，路由器才可以接受有关此路由的更新信息。</p>
</li>
<li><p>sleep<br>timer（触发更新计时器）：默认是5秒，表示随机抖动在1-5秒内，防止同时触发更新“风暴”。</p>
</li>
</ol>
<p>修改RIP计时器：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)#router rip</span><br><span class="line"></span><br><span class="line">R1(config-router)#timer basic 30（更新） 180（无效） 180（抑制） 240（刷新）</span><br><span class="line">5000（触发更新，毫秒为单位）</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注：在rip的database里面invalid timer时间 180秒到了 ,就进入holddown 180秒, 但是flush 计时器是和invalid 一起开始的, 所以总共240 秒一到.本路由就会被清除掉,而不是等到 holddown 的180秒 走完, 总共要等invaild+holddown=360, 实际的时间 最高就是240 秒左右(有一定的偏差)</p>
</blockquote>
<p>接口下修改rip更新间隔：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)#int f0/0</span><br><span class="line"></span><br><span class="line">R1(config-if)#ip<span class="built_in"> rip </span>advertise 10</span><br></pre></td></tr></table></figure></p>
<h2 id="RIPv1的局限性"><a href="#RIPv1的局限性" class="headerlink" title="RIPv1的局限性"></a>RIPv1的局限性</h2><h3 id="不支持不连续子网"><a href="#不支持不连续子网" class="headerlink" title="不支持不连续子网"></a>不支持不连续子网</h3><p><img src="/2018/04/11/CCNPDAY2/be1958779e94287a8e9626ed1102a897.png" alt=""></p>
<p>R1：</p>
<p><img src="/2018/04/11/CCNPDAY2/8ef02fb32f4dd813ae80a3d11d0efc08.png" alt=""></p>
<p>发现R1收到的是172.16.0.0的有类路由，并且有两个下一跳，负载均衡。</p>
<p><img src="/2018/04/11/CCNPDAY2/914059e72cc8cfcc6635a7ae9d3f6daa.png" alt=""></p>
<h3 id="不支持关闭自动汇总"><a href="#不支持关闭自动汇总" class="headerlink" title="不支持关闭自动汇总"></a>不支持关闭自动汇总</h3><p><img src="/2018/04/11/CCNPDAY2/be1958779e94287a8e9626ed1102a897.png" alt=""></p>
<p>我们希望R2,R3如果能关闭自动汇总，是否可以解决此问题？<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R2(config)#router rip</span><br><span class="line"></span><br><span class="line">R2(config-router)#<span class="literal">no</span> auto-summary</span><br><span class="line"></span><br><span class="line">R3(config)#router rip</span><br><span class="line"></span><br><span class="line">R3(config-router)#<span class="literal">no</span> auto-summary</span><br></pre></td></tr></table></figure></p>
<p>R1：</p>
<p><img src="/2018/04/11/CCNPDAY2/c32ef4017a1b7722708139410f0a0c05.png" alt=""></p>
<p>仍然汇总成主类路由，负载均衡。</p>
<h3 id="不支持手动汇总"><a href="#不支持手动汇总" class="headerlink" title="不支持手动汇总"></a>不支持手动汇总</h3><p><img src="/2018/04/11/CCNPDAY2/ce9f6c4ea46ca4c618abd5ae21d40742.png" alt=""></p>
<p>R1：</p>
<p><img src="/2018/04/11/CCNPDAY2/a1ab2b8d5f5af856288ef0fddc9ac774.png" alt=""></p>
<p>R2有很多172.16.0.0/16的子网网络，如果子网过多，增加路由条目，增加路由器R1的负担，172.16.2.0到172.16.5.0都属于172.16.0.0/21，我们希望可以用一条汇总来代替诸多繁杂的路由条目<br><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#int</span> f0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> summary-<span class="selector-tag">address</span> rip <span class="number">172.16</span>.<span class="number">0.0</span> <span class="number">255.255</span>.<span class="number">248.0</span></span><br></pre></td></tr></table></figure></p>
<p>R1：</p>
<p><img src="/2018/04/11/CCNPDAY2/6add30e5f919117eb5dbcf8cc0525f87.png" alt=""></p>
<p>说明R2并没有发出汇总路由，原因：手动汇总后，掩码改变，与发出路由更新接口不匹配，所以无法发出，并且原有明细路由也无法发出路由更新。</p>
<h2 id="RIPv2"><a href="#RIPv2" class="headerlink" title="RIPv2"></a>RIPv2</h2><p>RIPv2与RIPv1相同，封装在UDP<br>520端口，不同的是：使用组播地址224.0.0.9发送路由更新；支持子网掩码（即支持VLSM）；支持手动汇总；支持身份认证。</p>
<h2 id="RIPv2的消息格式"><a href="#RIPv2的消息格式" class="headerlink" title="RIPv2的消息格式"></a>RIPv2的消息格式</h2><p><img src="/2018/04/11/CCNPDAY2/e84f5214641eb716f73bba6dba17f516.png" alt=""></p>
<p>图 2‑22 RIP消息格式截图</p>
<p><img src="/2018/04/11/CCNPDAY2/d1835439753c94fc87b6d89302830994.png" alt=""></p>
<p>图 2‑23 RIPv2实验拓扑图</p>
<h2 id="RIPv2基本配置"><a href="#RIPv2基本配置" class="headerlink" title="RIPv2基本配置"></a>RIPv2基本配置</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"></span><br><span class="line">version 2</span><br><span class="line"></span><br><span class="line">network .0</span><br><span class="line"></span><br><span class="line">network 172.16.0.0</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> auto-summary</span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"></span><br><span class="line">version 2</span><br><span class="line"></span><br><span class="line">network .0</span><br><span class="line"></span><br><span class="line">network 172.16.0.0</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> auto-summary</span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"></span><br><span class="line">version 2</span><br><span class="line"></span><br><span class="line">network .0</span><br><span class="line"></span><br><span class="line">network .0</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> auto-summary</span><br></pre></td></tr></table></figure>
<p>查看路由表：</p>
<p><img src="/2018/04/11/CCNPDAY2/82fc6ea68819317530825205659048fd.png" alt=""></p>
<p>图 2‑24 R1路由表截图</p>
<p>非连续子网，收到的是无类路由！因为路由更新中携带子网掩码。</p>
<h2 id="RIPv2手动汇总"><a href="#RIPv2手动汇总" class="headerlink" title="RIPv2手动汇总"></a>RIPv2手动汇总</h2><p><img src="/2018/04/11/CCNPDAY2/0552634f95eac703f3491e616acc6bdf.png" alt=""></p>
<p>图 2‑25 RIPv2手工汇总实验拓扑图</p>
<p>原R1路由表：</p>
<p><img src="/2018/04/11/CCNPDAY2/a7617e612312308dd03f946fcae7c76f.png" alt=""></p>
<p>图 2‑26 汇总前R1路由表截图</p>
<p>R3有多个.0/21的子网网络，希望由汇总路由进行路由更新。</p>
<p>R3：出接口发汇总路由！</p>
<p>现R1路由表:</p>
<p><img src="/2018/04/11/CCNPDAY2/d45eff52a69e48edc19d660e7f3e3a04.png" alt=""></p>
<p>图 2‑27 汇总后R1路由表截图</p>
<p>大大简化路由表，减轻路由器的负担！</p>
<p>防止环路：</p>
<p><code>R3(config)#ip route 172.16.0.0 255.255.248.0 null0</code></p>
<h2 id="RIPv2身份认证"><a href="#RIPv2身份认证" class="headerlink" title="RIPv2身份认证"></a>RIPv2身份认证</h2><p>RIPv2是通过更改RIP消息中的正常情况下应该是第一个路由条目的字段来支持认证。因此在含有认证的单个更新消息中，最大可以携带的路由条目被减少到24条。认证是通过设置地址族标识符为0xFFFF来标识。路由标记设置为认证类型</p>
<p><img src="/2018/04/11/CCNPDAY2/f82dfc5740fc24854bd8e7e16f72c0be.png" alt=""></p>
<p>图 2‑28 RIPv2数据包认证字段</p>
<p>RIPv2的认证类型：</p>
<ol>
<li><p>明文认证</p>
</li>
<li><p>MD5认证</p>
</li>
</ol>
<h3 id="明文认证"><a href="#明文认证" class="headerlink" title="明文认证"></a>明文认证</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">key chain cisco</span><br><span class="line"></span><br><span class="line">key 1</span><br><span class="line"></span><br><span class="line">key-string cisco</span><br><span class="line"></span><br><span class="line">interface FastEthernet0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>12.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>authentication key-chain cisco</span><br></pre></td></tr></table></figure>
<h3 id="MD5认证"><a href="#MD5认证" class="headerlink" title="MD5认证"></a>MD5认证</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line"></span><br><span class="line">interface FastEthernet0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>12.1.1.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>authentication mode md5</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>authentication key-chain cisco</span><br></pre></td></tr></table></figure>
<h2 id="RIP版本"><a href="#RIP版本" class="headerlink" title="RIP版本"></a>RIP版本</h2><p>RIPv1：</p>
<p><img src="/2018/04/11/CCNPDAY2/7922380219f843e103b12755f7178fcb.png" alt=""></p>
<p>图 2‑29 查看路由协议截图</p>
<p>RIPv2：</p>
<p><img src="/2018/04/11/CCNPDAY2/d8479dbb250b325224e69abab4c77423.png" alt=""></p>
<p>图 2‑30 查看路由协议截图</p>
<p>默认版本：</p>
<p><img src="/2018/04/11/CCNPDAY2/9c42af9db6b86c2adccc9575ef7ec8ba.png" alt=""></p>
<p>图 2‑31 查看路由协议截图</p>
<p>总结：</p>
<p>默认版本———发送v1路由更新，接收v1，v2路由更新</p>
<p>RIPv1—————发送v1路由更新，接收v1路由更新</p>
<p>RIPv2—————发送v2路由更新，接收v2路由更新</p>
<p>修改RIP路由器收发路由更新版本：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">interface FastEthernet0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>172.16.12.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>send version 1 2-------发v1，v2</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>receive version 1 2-----收v1，v2</span><br></pre></td></tr></table></figure></p>
<h2 id="RIP的负载均衡"><a href="#RIP的负载均衡" class="headerlink" title="RIP的负载均衡"></a>RIP的负载均衡</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1(config)#router rip</span><br><span class="line"></span><br><span class="line">R1(config-router)#maximum-paths 16（默认是4）</span><br></pre></td></tr></table></figure>
<h2 id="RIP-Feature"><a href="#RIP-Feature" class="headerlink" title="RIP Feature"></a>RIP Feature</h2><h3 id="单播更新："><a href="#单播更新：" class="headerlink" title="单播更新："></a>单播更新：</h3><p>通过单播方式向RIP邻居发送路由更新，使用广播和组播的原因在于，不清楚RIP邻居在哪里，如果知道RIP邻居的IP地址，就可以让RIP路由器向指定邻居发送路由更新</p>
<p>回顾被动接口，如果只想让一个接口发送路由更新<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"></span><br><span class="line">version 1</span><br><span class="line"></span><br><span class="line">passive-interface default-----所有接口都设置passive接口</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> passive-interface FastEthernet0/0</span><br></pre></td></tr></table></figure></p>
<p>注：passive-interface只针对组播和广播路由更新</p>
<p>方法二：<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"></span><br><span class="line">passive-interface default</span><br><span class="line"></span><br><span class="line">network 172.16.0.0</span><br><span class="line"></span><br><span class="line">neighbor 172.16.12.2-----单播定向发送路由更新</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">router rip</span><br><span class="line"></span><br><span class="line">passive-interface default</span><br><span class="line"></span><br><span class="line">network 172.16.0.0</span><br><span class="line"></span><br><span class="line">neighbor 172.16.12.1</span><br></pre></td></tr></table></figure></p>
<h3 id="RIP触发更新"><a href="#RIP触发更新" class="headerlink" title="RIP触发更新"></a>RIP触发更新</h3><p>在低速链路上，如果定期发送广播更新，十分消耗原本就很紧张的带宽资源，如果使用触发更新，将很好的降低链路资源的消耗。</p>
<p>只能在点到点链路使用！并且需要两端都使用才生效。<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>172.16.12.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>triggered</span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line"></span><br><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>172.16.12.2 255.255.255.0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>triggered</span><br></pre></td></tr></table></figure></p>
<h3 id="RIP版本2发送广播"><a href="#RIP版本2发送广播" class="headerlink" title="RIP版本2发送广播"></a>RIP版本2发送广播</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">interface Serial0/0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> rip </span>v2-broadcast</span><br></pre></td></tr></table></figure>
<p>适用于比较老旧的设备不识别rip的组播地址。</p>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>CCNP</tag>
      </tags>
  </entry>
  <entry>
    <title>Static Route DHCP FR</title>
    <url>/2018/04/11/CCNPDAY1/</url>
    <content><![CDATA[<p><strong>静态路由、DHCP、帧中继</strong></p>
<ol>
<li><p>静态路由</p>
<ol>
<li>静态路由的相关概念</li>
</ol>
</li>
</ol>
<p>路由：网络信息从信源到信宿的路径。</p>
<p>路由器：路由器的作用就是将各个网络彼此连接起来。</p>
<p>路由器主要负责将数据包传送到本地和远程目的网络，其方法是：</p>
<p>1.确定发送数据包的最佳路径</p>
<p>2.将数据包转发到目的地</p>
<p><img src="/2018/04/11/CCNPDAY1/85ab332f5de0e94feecc6de479330f98.png" alt=""></p>
<p>图 1‑1 数据流向图</p>
<h2 id="路由表简介："><a href="#路由表简介：" class="headerlink" title="路由表简介："></a>路由表简介：</h2><p>路由器的主要功能是将数据包转发到目的网络，即转发到数据包目的 IP<br>地址。为此，路由器需要搜索存储在路由表中的路由信息。</p>
<p>路由表是保存在 RAM<br>中的数据文件，其中存储了与直连网络以及远程网络相关的信息。路由表包含网络与下一跳的关联信息。这些关联告知路由器：要以最佳方式到达某一目的地，可以将数据包发送到特定路由器（下一跳）或指定从某个接口发出（出接口）。</p>
<p><img src="/2018/04/11/CCNPDAY1/b6ff8373adb2c427b6a32c9a60715ec5.png" alt=""></p>
<p>图 1‑2 路由表截图</p>
<a id="more"></a>
<p>路由表的组成：</p>
<p>表 1‑1 路由表内容描述</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>截图内容</th>
<th>相关描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>172.16.0.0/24</td>
<td>主类网络是172.16.0.0，划分成了24位的子网</td>
</tr>
<tr>
<td>2</td>
<td>is subnetted,3 subnets</td>
<td>被划分了子网，总共有3个子网</td>
</tr>
<tr>
<td>3</td>
<td>S</td>
<td>代表路由类型：static，静态路由</td>
</tr>
<tr>
<td>4</td>
<td>172.16.1.0</td>
<td>目标子网网络号（目标网段）</td>
</tr>
<tr>
<td>5</td>
<td>172.16.2.2</td>
<td>下一跳地址</td>
</tr>
</tbody>
</table>
</div>
<p><img src="/2018/04/11/CCNPDAY1/8df0075b6bc9cad22c6610af533d9c86.png" alt=""></p>
<p>图 1‑3 数据包字段截图图</p>
<p>路由器收到数据包，查看IP数据包头部的目的地址，匹配路由表中的路由条目，找到下一跳或出接口，通过相应接口转发。</p>
<ol>
<li><p>静态路由的方式</p>
<ol>
<li>静态路由的配置方式：</li>
</ol>
</li>
</ol>
<ul>
<li>指定下一跳：</li>
</ul>
<p><code>ip route .0 255.255.255.0 12.1.1.2</code></p>
<ul>
<li>指定出接口：</li>
</ul>
<p><code>ip route .0 255.255.255.0 fastethernet 0/0</code></p>
<p>两种方式是否一样呢？</p>
<h3 id="静态路由实验"><a href="#静态路由实验" class="headerlink" title="静态路由实验"></a>静态路由实验</h3><p><img src="/2018/04/11/CCNPDAY1/dc35b84465e693d4df971726d9c9f4b5.png" alt=""></p>
<p>图 1‑4 静态路由实验拓扑图</p>
<h4 id="实验一-指定下一跳"><a href="#实验一-指定下一跳" class="headerlink" title="实验一 指定下一跳"></a>实验一 指定下一跳</h4><p><img src="/2018/04/11/CCNPDAY1/41e305f4fe9ca21c9ebc0060aacf56bd.png" alt=""></p>
<p>图 1‑5 静态路由配置及查看截图</p>
<p>R1 ping .3，数据包要发给下一跳12.1.1.2，R1<br>将ip包头封装到icmp包（ping包），继续封装以太网头部，发现不知道12.1.1.2的mac地址，无法完成封装，由于12.1.1.2和自己是同一网段，发出arp请求12.1.1.2的mac地址，R2收到arp广播后将F0/0的mac地址回复给R1，R1完成数据封装，发给R2，R2以同样方式发送给R3。</p>
<p><img src="/2018/04/11/CCNPDAY1/9d30622ef13c1bdc6b8d61e1feb5da8f.png" alt=""></p>
<p>图 1‑6 查看arp截图</p>
<p><img src="/2018/04/11/CCNPDAY1/f4b3c703a91bebdc76483b08888cddfe.png" alt=""></p>
<p>图 1‑7 查看接口截图</p>
<h4 id="实验二-指定出接口"><a href="#实验二-指定出接口" class="headerlink" title="实验二 指定出接口"></a>实验二 指定出接口</h4><p><img src="/2018/04/11/CCNPDAY1/62bab4fcb719483380377e12788cad58.png" alt=""></p>
<p>首先比较下路由表的不同，我们会发现一个现象：.0 is directly<br>connected，fastethernet0/0，路由器竟然认为3.3.3.0是直连路由。同样R1 ping<br>3.3.3.3，仍然无法完成二层目标mac的封装，因此发送arp请求，但是，由于R1认为3.3.3.0是直连网络，会直接请求3.3.3.3的mac地址！问题出现了，12.1.1.0网段有3.3.3.3这个主机吗？谁来回应R1？如果没有人来回应R1，那么就无法完成二层封装，数据无法发送出去，可是为什么会ping通？</p>
<p><img src="/2018/04/11/CCNPDAY1/7db145db8336ae6f7bcc121ff7b90575.png" alt=""></p>
<p>图 1‑8 查看arp截图</p>
<p><img src="/2018/04/11/CCNPDAY1/f4b3c703a91bebdc76483b08888cddfe.png" alt=""></p>
<p>图 1‑9 查看接口截图</p>
<p>我们发现R1请求到的.3的mac地址竟然是R2的F0/0的mac地址，说明R2欺骗了R1，但是这是一个善意的谎言，因为R2知道如何去3.3.3.3，因此只要R1把数据包交给R2,R2可以帮R1转发出去，此技术叫做代理ARP，R2知道如何去往目的地，因此代理目标主机回复ARP请求，将主机的mac回复给请求者。</p>
<h3 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h3><ul>
<li>使用下一跳：</li>
</ul>
<p>R1只会请求下一跳的mac地址</p>
<p><img src="/2018/04/11/CCNPDAY1/cbce817f6be6ae7262ce3250b521d1a7.png" alt=""></p>
<p>图 1‑10 查看arp截图</p>
<ul>
<li>使用出接口：</li>
</ul>
<p>由于R1认为目标与自己是直连的，所以会对每个目标发送arp请求，R2就得代理多次。</p>
<p><img src="/2018/04/11/CCNPDAY1/78a58afda4dff06c4c6c6f84b91dbe7f.png" alt=""></p>
<p>图 1‑11 查看arp截图</p>
<p>由此看出，使用出接口，不仅对同一网段不同目标访问都需要一次arp请求，占用arp缓存空间，并且需要R2开启代理arp功能。</p>
<p>cisco路由器默认开启代理arp</p>
<p>关闭代理arp的配置方法：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">R2(config)#int f0/0</span><br><span class="line"></span><br><span class="line">R2(config-if)#<span class="literal">no</span><span class="built_in"> ip </span>proxy-arp</span><br></pre></td></tr></table></figure>
<h3 id="静态指定arp"><a href="#静态指定arp" class="headerlink" title="静态指定arp"></a>静态指定arp</h3><p>arp是一种动态请求目标ip地址对应mac地址的协议，上面我们关闭了代理arp，动态无法进行地址解析，我们可以使用静态指定arp的方式进行地址解析。</p>
<p>R1(config)#ar.3 cc01.0b4c.0000 arpa</p>
<p><img src="/2018/04/11/CCNPDAY1/8ff4007cbc7d4252b381fd036b48f5af.png" alt=""></p>
<p>图 1‑12 查看arp截图</p>
<ol>
<li><p>静态默认路由</p>
<ol>
<li>默认路由的概念</li>
</ol>
</li>
</ol>
<p>默认路由的表现形式为0.0.0.0<br>0.0.0.0，即目标网络号为0.0.0.0，子网掩码为0.0.0.0，在ip地址中0.0.0.0表示任意，那么任意网络号加上任意掩码表示为任意路由。通常用于互联网出口设备，用于表示互联网路由。</p>
<h3 id="默认路由的配置"><a href="#默认路由的配置" class="headerlink" title="默认路由的配置"></a>默认路由的配置</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Router(config)#ip<span class="built_in"> route </span>.0 0.0.0.0 12.1.1.2</span><br><span class="line"></span><br><span class="line">R1#show<span class="built_in"> ip </span>route</span><br><span class="line"></span><br><span class="line">S* 0.0.0.0/0 [1/0] via 12.1.1.2</span><br></pre></td></tr></table></figure>
<ol>
<li><p>DHCP（Dynamic Host Configuration Protocol）</p>
<ol>
<li>DHCP的用途及工作机制</li>
</ol>
</li>
</ol>
<p>如果没有一个动态的分配ip地址的机制，所有人都需要手动指定ip地址，并且要记住网关和DNS服务器的地址，除此之外，非常容易造成地址冲突！ip地址分配，管理工作十分繁琐。</p>
<p>DHCP主要用途：动态的为网络中的主机分配IP地址</p>
<p>DHCP使用udp报文，client使用udp 68，server使用udp 67</p>
<p><img src="/2018/04/11/CCNPDAY1/4273f28a17d4bd4739e544826d2e3bb6.png" alt=""></p>
<p>图 2‑1 DHCP工作机制图</p>
<ul>
<li><p>第一个包discover：用于客户端寻找dhcp服务器</p>
</li>
<li><p>第二个包offer:用于服务器分配ip，子网掩码，dns，租期等信息</p>
</li>
<li><p>第三个包request：用于客户确认使用此ip</p>
</li>
<li><p>第四个包ack：被使用服务器端确认</p>
</li>
</ul>
<p>注：linux系统中第一、三个包是广播包；第二、四个包是单播包，cisco系统中四个包全部是广播。</p>
<ol>
<li><p>DHCP的配置：</p>
<ol>
<li>Server端配置</li>
</ol>
</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#service</span> dhcp------开启dhcp服务</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#ip</span> dhcp excluded-<span class="selector-tag">address</span> .<span class="number">253</span> <span class="number">12.1</span>.<span class="number">1.254</span>-----排除不分配的地址</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#ip</span> dhcp pool cisco------建立dhcp地址池命名为cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(dhcp-config)</span></span><span class="selector-id">#network</span> .<span class="number">0</span> <span class="number">255.255</span>.<span class="number">255.0</span>------分配的网段及掩码</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(dhcp-config)</span></span><span class="number">#def</span>ault-router .<span class="number">1</span>------默认网关</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(dhcp-config)</span></span><span class="selector-id">#dns</span> <span class="number">202.103</span>.<span class="number">24.68</span>-------dns服务器的地址</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(dhcp-config)</span></span><span class="selector-id">#lease</span> <span class="number">7</span>--------租期为<span class="number">7</span>天，一个地址可以用<span class="number">7</span>天，默认为<span class="number">1</span>天</span><br></pre></td></tr></table></figure>
<h3 id="Client端配置："><a href="#Client端配置：" class="headerlink" title="Client端配置："></a>Client端配置：</h3><p>路由器作为dhcp client端：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> f0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> <span class="selector-tag">address</span> dhcp</span><br></pre></td></tr></table></figure>
<h2 id="DHCP中继"><a href="#DHCP中继" class="headerlink" title="DHCP中继"></a>DHCP中继</h2><p><img src="/2018/04/11/CCNPDAY1/2f70e24dc7dc2db63aaae6022464b759.png" alt=""></p>
<p>图 2‑2 DHCP中继实验拓扑图</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> f0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> <span class="selector-tag">address</span> dhcp</span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> f0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> add .<span class="number">2</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> helper-<span class="selector-tag">address</span> .<span class="number">3</span></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span><span class="selector-id">#ip</span> dhcp pool office</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(dhcp-config)</span></span><span class="selector-id">#network</span> .<span class="number">0</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(dhcp-config)</span></span><span class="number">#def</span>ault-router .<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span><span class="selector-id">#ip</span> route .<span class="number">0</span> <span class="number">255.255</span>.<span class="number">255.0</span> <span class="number">23.1</span>.<span class="number">1.2</span></span><br></pre></td></tr></table></figure>
<h2 id="DHCP分配特定ip地址"><a href="#DHCP分配特定ip地址" class="headerlink" title="DHCP分配特定ip地址"></a>DHCP分配特定ip地址</h2><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span><span class="selector-id">#ip</span> dhcp pool cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(dhcp-config)</span></span><span class="selector-id">#host</span> <span class="number">192.168</span>.<span class="number">10.88</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(dhcp-config)</span></span><span class="selector-id">#client-identifier</span> <span class="number">01</span>aa<span class="selector-class">.bbcc</span><span class="selector-class">.ddee</span><span class="selector-class">.ff----</span>给mac地址为aabb<span class="selector-class">.ccdd</span><span class="selector-class">.eeff</span>的设备分配固定的<span class="number">192.168</span>.<span class="number">10.88</span>掩码为<span class="number">255.255</span>.<span class="number">255.0</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>帧中继</p>
<ol>
<li>帧中继相关概念</li>
</ol>
</li>
</ol>
<p>帧屮继是一种在20世纪90年代初期形成的包交换技术<br>,是一个提供高性能的数据链路层和物理层的规范。帧中继比点到点链路更划算,并且可以运行在64Kbs~<br>45Mb/s(T3)之间。帧中继提供动态分配带宽和拥塞控制特性。</p>
<p>包交换 (Packet<br>switching)这是一种WAN交换方法,允许和其他公司共享带宽以节省资金。可以将包交换想像为一种看起来像租用线路<br>,但费用更像电路交换的一种网络。不利因素是,如果需要经常传输数据,则不要考虑这种类型,应当使用租用线路。如果是偶然的突发性的数据传输,那么包交换可以满足需要。</p>
<h2 id="帧中继网络环境"><a href="#帧中继网络环境" class="headerlink" title="帧中继网络环境"></a>帧中继网络环境</h2><p><img src="/2018/04/11/CCNPDAY1/e05f2beef8dccb01107d401e20553d8a.png" alt=""></p>
<ol>
<li><p>帧中继术语</p>
<ol>
<li>帧中继封装类型</li>
</ol>
</li>
</ol>
<p>当在Cisco路由器上配置帧中继时,需要在串行接口上将帧中继指定为一种封装。帧中继有两种封装类型：</p>
<ul>
<li><p>cisco</p>
</li>
<li><p>IETF(Internet Engineering Task Force)</p>
<ol>
<li>虚电路</li>
</ol>
</li>
</ul>
<p>帧中继使用虚电路工作方式<br>,所谓“虚”是相对于租用线路使用的真正电路而言的。这些虚电路是由连接到提供商<br>“网云”上的几干台设各构成的链路。帧中继为两台DTE设备之间建立的虚电路<br>,使它们就像通过一条电路连接起来一样,实际上将帧放入一个很大的共享设施里<br>。有两种虚电路——永久虚电路和交换虚电路。</p>
<ul>
<li><p>永久虚电路 (Permanent Virtual<br>Circuits,PVC)是目前最常用的类型。永久的意思是电信公司在内部创建映射,并且只要你付费,虚电路就一直有效。</p>
</li>
<li><p>交换虚电路 (switched Virtual<br>Circuits,SVC)更像电话呼叫。当数据需要传输时,建立虚电路;数据传输完成后拆除虚电路。</p>
<ol>
<li>数据链路连接标识符 (DLCI)</li>
</ol>
</li>
</ul>
<p>帧中继PVC使用数据链路连接标识符 (Data Link Connection<br>Identifiers,DICI)标识DTE设备。帧中继服务提供商分配 DLCI值 ,帧中继用<br>DLCI值区分网络上的不同虚电路。因为在一个多点帧中继接口上可以有多个虚电路,所以这种接口可以有多个DLCI。</p>
<h3 id="本地管理接口-LMI"><a href="#本地管理接口-LMI" class="headerlink" title="本地管理接口(LMI)"></a>本地管理接口(LMI)</h3><p>本地管理接口(Local Management<br>Interface,LMI)是路由器和它所连接的第一个帧中继交换机之间使用的信令标准。它允许传递有关服务提供商网络和DTE(路由器)之间虚电路的操作和状态信息。</p>
<ul>
<li><p>KeepaIives(保持激活) 验证数据的通畅。</p>
</li>
<li><p>Multicasting(组播)这是一个可选的扩展LMI规范,允许在例如帧中继网络上有效<br>发布路由信息和ARP请求。组播使用 1019~1022之间的 DLCI保留号码。</p>
</li>
<li><p>G1obaI addressing(全局寻址)为 DLCI提供全局意义,允许帧 中继网云像LAN一样 。</p>
</li>
<li><p>Satus of virtual circuits(虚电路状态)提供DLCI状态信息。<br>当无规律LMI流量发送时,这些状态查询和状态信息用于保持激活。</p>
<ol>
<li>帧中继配置</li>
</ol>
</li>
</ul>
<p><img src="/2018/04/11/CCNPDAY1/54a3cc88bb0ba0bedd20a84e3a65fe91.png" alt=""></p>
<p>图 3‑1 帧中继实验拓扑</p>
<p>如图3-1，R1需要将数据发送给R2（ip为123.123.123.2）时，R1对数据进行2层封装使用DLCI=102来完成。数据到了帧中继交换机，帧中继交换机根据帧中继交换表进行交换转发：从S1接口收到一个DLCI为102的帧时，交换机把帧从S2接口发出，并且将二层地址改为201，这样R2就会接收R1发来的数据包。</p>
<p>通过以上的转发过程，发送方路由器R1需要知道3层封装目标ip=123.123.123.2时，2层地址应该封装哪一个DLCI。</p>
<p>静态指定映射：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">Interface s1</span><br><span class="line"></span><br><span class="line">encapsulation frame-relay</span><br><span class="line"></span><br><span class="line"><span class="literal">no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line">ip<span class="built_in"> address </span>123.123.123.1 255.255.255.0</span><br><span class="line"></span><br><span class="line">frame-relay map<span class="built_in"> ip </span>123.123.123.2 102</span><br></pre></td></tr></table></figure>
<p>帧中继是一个非广播多路访问的环境。如果路由器R1<br>DLCI=102的PVC上发送一个广播，只有R2可以收到，R3是无法收到的，如果R1发送的广播想让R2和R3都收到，必须分别在PVC<br>102和PVC 103上各发送一次，这就是非广播的含义。</p>
<p>帧中继配置：</p>
<p>帧中继交换机：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config)</span></span><span class="selector-id">#frame-relay</span> switching-------在路由器上开启帧中继交换机功能</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> s0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay-------将接口封装为帧中继协议</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> intf-type dce------帧中继交换机接口类型为dce端</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#clock</span> rate <span class="number">64000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco-----lmi的标准类型</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> route <span class="number">102</span> interface s0/<span class="number">1</span> <span class="number">201</span>-----创建帧中继交换表</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> route <span class="number">103</span> interface s0/<span class="number">2</span> <span class="number">301</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shutdown</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#interface</span> s0/<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> intf-type dce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#clock</span> rate <span class="number">64000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> route <span class="number">201</span> interface s0/<span class="number">0</span> <span class="number">102</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shut</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> s0/<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> intf-type dce</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#clock</span> rate <span class="number">64000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> route <span class="number">301</span> interface s0/<span class="number">0</span> <span class="number">103</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R4</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shutdown</span><br></pre></td></tr></table></figure>
<p>查看：</p>
<p><code>Show frame-relay route</code></p>
<p>DTE端：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> s0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> <span class="selector-tag">address</span> <span class="number">123.1</span>.<span class="number">1.1</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> map ip <span class="number">123.1</span>.<span class="number">1.2</span> <span class="number">102</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> map ip <span class="number">123.1</span>.<span class="number">1.3</span> <span class="number">103</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shutdown</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> s0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> <span class="selector-tag">address</span> <span class="number">123.1</span>.<span class="number">1.2</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> map ip <span class="number">123.1</span>.<span class="number">1.1</span> <span class="number">201</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R2</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shutdown</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config)</span></span><span class="selector-id">#interface</span> s0/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> frame-relay inverse-arp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span><span class="selector-id">#ip</span> <span class="selector-tag">address</span> <span class="number">123.1</span>.<span class="number">1.3</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> map ip <span class="number">123.1</span>.<span class="number">1.1</span> <span class="number">301</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R3</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shutdown</span><br></pre></td></tr></table></figure>
<p>查看：</p>
<p><code>Show frame-relay map</code></p>
<h2 id="帧中继子接口"><a href="#帧中继子接口" class="headerlink" title="帧中继子接口"></a>帧中继子接口</h2><p>帧中继在一个串行接口上有多条虚电路,并且将每条虚电路视为一个单独的接口,它被认为是子接口。将子接口想像为一个由IOS软件定义的逻辑接口。帧中继子接口可分为两种：</p>
<h3 id="点到点子接口（point-to-point）"><a href="#点到点子接口（point-to-point）" class="headerlink" title="点到点子接口（point-to-point）"></a>点到点子接口（point-to-point）</h3><p>   当一台虚电路连接一台路由器到另一个路由时<br>   ,使用点到点子接口。每个点到点子接口需要自己的子网。</p>
<p>   配置：</p>
 <figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#int</span> s2/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shutdown</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span>#exit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#int</span> s2/<span class="number">0.102</span> point-to-point</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-subif)</span></span><span class="selector-id">#ip</span> <span class="selector-tag">address</span> <span class="number">10.1</span>.<span class="number">1.1</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-subif)</span></span><span class="selector-id">#frame-relay</span> interface-dlci <span class="number">102</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-fr-dlci)</span></span>#exit</span><br></pre></td></tr></table></figure>
<h3 id="多点子接口"><a href="#多点子接口" class="headerlink" title="多点子接口"></a>多点子接口</h3><p>   当路由器位于星状虚电路的中心时,使用多点子接口。所有连接到帧中继交换机上的路由器接口都使用一个子网。</p>
<p>   配置：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#int</span> s2/<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#encapsulation</span> frame-relay</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#frame-relay</span> lmi-type cisco</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span><span class="selector-id">#no</span> shutdown</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-if)</span></span>#exit</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config)</span></span><span class="selector-id">#int</span> s2/<span class="number">0.103</span> multipoint</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-subif)</span></span><span class="selector-id">#ip</span> <span class="selector-tag">address</span> <span class="number">11.1</span>.<span class="number">1.1</span> <span class="number">255.255</span>.<span class="number">255.0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-subif)</span></span><span class="selector-id">#frame-relay</span> map ip <span class="number">11.1</span>.<span class="number">1.3</span> <span class="number">103</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">R1</span><span class="params">(config-subif)</span></span>#exit</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Cisco</tag>
        <tag>CCNP</tag>
      </tags>
  </entry>
</search>
